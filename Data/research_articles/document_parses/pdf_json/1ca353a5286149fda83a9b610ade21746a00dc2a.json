{
    "paper_id": "1ca353a5286149fda83a9b610ade21746a00dc2a",
    "metadata": {
        "title": "On Simulation in Automata Networks",
        "authors": [
            {
                "first": "Florian",
                "middle": [],
                "last": "Bridoux",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "CNRS",
                    "location": {
                        "settlement": "Marseille",
                        "region": "LIS",
                        "country": "France"
                    }
                },
                "email": "florian.bridoux@lis-lab.fr"
            },
            {
                "first": "Maximilien",
                "middle": [],
                "last": "Gadouleau",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Durham University",
                    "location": {
                        "settlement": "Durham",
                        "country": "UK"
                    }
                },
                "email": "m.r.gadouleau@durham.ac.uk"
            },
            {
                "first": "Guillaume",
                "middle": [],
                "last": "Theyssier",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "CNRS",
                    "location": {
                        "postCode": "I2M",
                        "settlement": "Marseille",
                        "country": "France"
                    }
                },
                "email": "guillaume.theyssier@cnrs.fr"
            }
        ]
    },
    "abstract": [
        {
            "text": "An automata network is a finite graph where each node holds a state from some finite alphabet and is equipped with an update function that changes its state according to the configuration of neighboring states. More concisely, it is given by a finite map f : Q n \u2192 Q n . In this paper we study how some (sets of) automata networks can be simulated by some other (set of) automata networks with prescribed update mode or interaction graph. Our contributions are the following. For non-Boolean alphabets and for any network size, there are intrinsically nonsequential transformations (i.e. that can not be obtained as composition of sequential updates of some network). Moreover there is no universal automaton network that can produce all non-bijective functions via compositions of asynchronous updates. On the other hand, we show that there are universal automata networks for sequential updates if one is allowed to use a larger alphabet and then use either projection onto or restriction to the original alphabet. We also characterize the set of functions that are generated by non-bijective sequential updates. Following Tchuente, we characterize the interaction graphs D whose semigroup of transformations is the full semigroup of transformations on Q n , and we show that they are the same if we force either sequential updates only, or all asynchronous updates.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "An automata network is a network of entities each equipped with a local update function that changes its state according to the states of neighboring entities. Automata networks have been used to model different kind of networks: gene networks, neural networks, social networks, or network coding (see [9] and references therein). They can also be considered as a model of distributed computation with various specialized definitions [18, 19] . The architecture of an automata network can be represented via its interaction graph, which indicates which update functions depend on which variables. An important stream of research is to determine how the interaction graph affects different properties of the network or to design networks with a prescribed interaction graph and with a specific dynamical property (see [8] for a review of known results). On the other hand, automata networks are usually associated with an update mode describing how local update functions of each entity are applied at each step of the evolution. In particular, three categories of update modes can be distinguished: sequential (one node update at a time), asynchronous (any subset of nodes at a time) or synchronous (all nodes simultaneously). Studying how changing the update mode affects the properties of an automata network with fixed local update functions is another major trend in this field [12, 13, 15] . Comparing the computational power of sequential and parallel machines is of course at the heart of computer science, but the questioning on update modes is also meaningful for applications of automata networks in modeling of natural systems where the synchronous update mode is often considered unrealistic.",
            "cite_spans": [
                {
                    "start": 302,
                    "end": 305,
                    "text": "[9]",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 434,
                    "end": 438,
                    "text": "[18,",
                    "ref_id": "BIBREF24"
                },
                {
                    "start": 439,
                    "end": 442,
                    "text": "19]",
                    "ref_id": "BIBREF25"
                },
                {
                    "start": 817,
                    "end": 820,
                    "text": "[8]",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 1382,
                    "end": 1386,
                    "text": "[12,",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 1387,
                    "end": 1390,
                    "text": "13,",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 1391,
                    "end": 1394,
                    "text": "15]",
                    "ref_id": "BIBREF21"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "For both parameters (interaction graphs and update modes), the set of properties that could be potentially affected is unlimited. In this paper, instead of choosing a set of properties to analyze, we adopt an intrinsic approach: we study how some (sets of) automata networks can be simulated by some other (set of) automata networks with prescribed update mode or interaction graph.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Notations. We will always consider alphabets of the form [[q]] = {0, . . . , q \u2212 1} for some q and usually denote by n the number of nodes of the network which are identified by integers in the interval [1, n] . An automata network is a map f :",
            "cite_spans": [
                {
                    "start": 203,
                    "end": 209,
                    "text": "[1, n]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "The rank of f is the size of its image. For any set of coordinates V \u2286 [1, n] ,",
            "cite_spans": [
                {
                    "start": 71,
                    "end": 77,
                    "text": "[1, n]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "] n denotes the following map:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "The notation is extended to words of subsets w = (w 1 , . . . , w k ) as follows:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "For v \u2208 [1, n] we overload this notation by f (v) = f ({v}) . We will often consider semigroups of functions under compositions: X where X is a set of functions that denotes the semigroup generated by compositions of elements of X. We denote the fact that S 1 is a sub-semigroup of S 2 by S 1 \u2264 S 2 . For any set X, Sym(X) is the set of permutations on X. We denote the set of all networks f :",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "] n as F(n, q). We denote by Sym(n, q) the set of f \u2208 F(n, q) which are bijective and by Sing(n, q) the set of f \u2208 F(n, q) which are non-bijective. For any set F of functions in F(n, q), what they can simulate (asynchronously, sequentially, synchronously) is denoted as follows:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Our Contributions. In this paper, we are further developing both strands of the theory of simulation of automata networks. We make the following contributions. We first consider simulation by a single network. Firstly, we show that for any q \u2265 3 and any n \u2265 2, there exists a network g \u2208 F(n, q) which is not sequentially simulatable. Secondly, we consider asynchronous simulation, and we show that there is no asynchronously complete network: for all f \u2208 F(n, q), Sing(n, q) \u2264 f Asy . This is a clear strengthening of the result in [2] for sequential simulation. Thirdly, we extend the framework to let a network over a large alphabet f \u2208 F(n, q ) simulate a network g \u2208 F(n, q) over a smaller alphabet. We consider two ways to extend the alphabet, and for each we prove the existence of sequentially complete networks for q = 2q and q = q + 1, respectively. We then consider simulation by large sets of networks. The seminal result in [4] shows that instructions (updates of the form f (v) for some v \u2208 [1, n]) can simulate any network; in this paper, we determine what singular instructions can simulate (and even idempotent instructions for q \u2265 3). We finally strengthen the main result in [16] by showing that it also holds when considering sequential and asynchronous updates as well.",
            "cite_spans": [
                {
                    "start": 533,
                    "end": 536,
                    "text": "[2]",
                    "ref_id": null
                },
                {
                    "start": 937,
                    "end": 940,
                    "text": "[4]",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 1194,
                    "end": 1198,
                    "text": "[16]",
                    "ref_id": "BIBREF22"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Proof. Complete proofs of all lemmas, propositions and theorems can be found in [3] .",
            "cite_spans": [
                {
                    "start": 80,
                    "end": 83,
                    "text": "[3]",
                    "ref_id": "BIBREF9"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "We say g \u2208 F(n, q) is sequentially simulatable if g \u2208 f Seq for some f \u2208 F(n, q). Recall that unless n = q = 2 any g \u2208 Sym(n, q) is sequentially simulatable since there is a universal f \u2208 F(n, q) such that f Seq = Sym(n, q) [7] . Concerning non-bijective maps, the situation is radically different for non-Boolean alphabets as shown in the following theorem. For any function \u03c6 \u2208 F(n, q), we denote by O(()\u03c6) the set of its orphans:",
            "cite_spans": [
                {
                    "start": 224,
                    "end": 227,
                    "text": "[7]",
                    "ref_id": "BIBREF13"
                }
            ],
            "ref_spans": [],
            "section": "Sequential Simulation"
        },
        {
            "text": "The analysis of oprhans configurations under sequential updates is the key behind the following theorem. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Sequential Simulation"
        },
        {
            "text": "F. Bridoux did an exhaustive search in F(n, 2) with n = 2 and n = 3 to test which one are sequentially simulatable [1] . It turns out that all f \u2208 F(3, 2) are sequentially simulatable. However, some functions in F(2, 2) are not and one example is the circular permutation 00 \u2192 01 \u2192 11 \u2192 10 \u2192 00 [1, Proposition 12] . More details (including the code of the test program) are available at http:// theyssier.org/san2020.",
            "cite_spans": [
                {
                    "start": 115,
                    "end": 118,
                    "text": "[1]",
                    "ref_id": null
                },
                {
                    "start": 299,
                    "end": 314,
                    "text": "Proposition 12]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Sequential Simulation"
        },
        {
            "text": "In this section, we consider asynchronous simulation, where at each step we allow any update f (T ) for T \u2286 [1, n] . We then refine the result in [2] that there is no network that can sequentially simulate all singular networks.",
            "cite_spans": [
                {
                    "start": 108,
                    "end": 114,
                    "text": "[1, n]",
                    "ref_id": null
                },
                {
                    "start": 146,
                    "end": 149,
                    "text": "[2]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Asynchronous Simulation"
        },
        {
            "text": "We say that a function h :",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Asynchronous Simulation"
        },
        {
            "text": "Proof. Suppose, for the sake of contradiction, that Sing(n, q) \u2264 f Asy . We first show that not all coordinate functions of f are balanced. There exists S \u2286 [1, n] such that f (S) has rank q n \u22121. (Otherwise, no function in f Asy has rank q n \u22121.)",
            "cite_spans": [
                {
                    "start": 157,
                    "end": 163,
                    "text": "[1, n]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Asynchronous Simulation"
        },
        {
            "text": "Let g \u2208 Sing(n, q) not be deficient, and have a nontrivial g v ; and suppose g =",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Asynchronous Simulation"
        },
        {
            "text": "Similarly to Theorem 1, the obstacle in Theorem 2 was found in the set of maps of rank q n \u2212 1. We now show that maps of rank q n \u2212 2 form another obstruction to having complete simulation in the asynchronous case. Let T (n, q) be the set of networks in F(n, q) whose rank is not equal to q n \u2212 1. It is clear that T (n, q) is a semigroup, generated by maps of rank q n or q n \u2212 2.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Asynchronous Simulation"
        },
        {
            "text": "Proof. Suppose, for the sake of contradiction, that T (n, q) \u2264 f Asy . Firstly, all the coordinate functions of f are balanced. Indeed, let g(x) = x + (1, . . . , 1) and By an argument similar to the proof of Theorem 2, there is no S \u2286 [1, n] such that f (S) is of type I. Let g be of type I and let us express it as g = f (w1\u00b7\u00b7\u00b7w k ) . Each f (w l ) has rank at least q n \u2212 2, and there exists 1 \u2264 i \u2264 k such that f (wi) is singular. By the argument above, f (wi) is of type II and so is h",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Asynchronous Simulation"
        },
        {
            "text": ", then g has rank at most q n \u2212 3; otherwise |g \u22121 (h (a))| = |g \u22121 (h (b))| = 2 and hence g is of type II, which is the desired contradiction.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Asynchronous Simulation"
        },
        {
            "text": "As said earlier, there is no universal automata network in F(n, q) able to sequentially simulate all functions of F(n, q) (actually Theorem 2 gives a stronger negative result). In this section, we revisit this problem when the simulator is allowed to use a larger alphabet. In this case we can consider two natural types of simulations: one requires the simulation to work on any initial configuration of the simulator and uses a projection onto configurations of the simulated functions; the other does not use projection, but works only on initial configurations using the alphabet of the simulated function. Definition 1. Let n \u2208 N, 2 \u2264 q < q and consider f \u2208 F(n, q ). We say that f is (n,q)-universal by factor if there is a surjection \u03c0 :",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Simulation Using Larger Alphabets"
        },
        {
            "text": "where \u03c0(x 1 , . . . , x n ) = (\u03c0(x 1 ), . . . , \u03c0(x n )). f is said (n,q)-universal by initialization if for any h \u2208 F(n, q) there is a word w \u2208 [1, n] * such that",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Simulation Using Larger Alphabets"
        },
        {
            "text": "We are going to show that universality can be achieved for each kind of simulation. In both cases, the larger alphabet allows us to encode more information than the configuration of the simulated function. This additional information is used as a global controlling state that commands transformations applied on the simulated configuration and evolves according to a finite automaton. In the case of simulation by factor, the encoding is straightforward but the global controlling state is uninitialized. The key is to use a control automaton with a synchronizing word (see Fig. 1 ). In the case of simulation by initialization, the difficulty lies in the encoding.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 575,
                    "end": 581,
                    "text": "Fig. 1",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Simulation Using Larger Alphabets"
        },
        {
            "text": "The following theorems were obtained by F. Bridoux during his PhD thesis [1] .",
            "cite_spans": [
                {
                    "start": 73,
                    "end": 76,
                    "text": "[1]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Simulation Using Larger Alphabets"
        },
        {
            "text": "For any q \u2265 2 and n \u2265 3, there exists f \u2208 F(n, 2q) which is (n, q)-universal by factor. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 3."
        },
        {
            "text": "if x = (0) n and (y = 011 or y = 001), 0 if x = 1(0) n\u22121 and y = 011, x 1 otherwise,",
            "cite_spans": [
                {
                    "start": 72,
                    "end": 73,
                    "text": "1",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Theorem 3."
        },
        {
            "text": "Then we define f by f (x, y) = \u03a8 (x, y), \u03c1(y) . We now prove properties about f implying that it is (n, q)-universal by factor. Proof. First, let us remark that updating q times coordinate 3 starting from (x, y), there are two cases: -y = 011 or x 1 = 0 or x 2 = 0 and then the component x is not modified; -y = 011 and x 1 = x 2 = 0, and then the modification x 3 \u2190 x 3 + 1 is applied q times.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 3."
        },
        {
            "text": "Therefore",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 3."
        },
        {
            "text": "To show that the update sequence ((3) q , 2, 3, 1, 1, 2, 1, 3) does not modify the component x, it is sufficient to verify the following:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 3."
        },
        {
            "text": "-coordinate 1 is not updated when y \u2208 {101, 011, 001}; -coordinate 2 is not updated when y = 111; -when coordinate 3 is updated and y = 011, it is updated q times.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 3."
        },
        {
            "text": "By definition of f ((3) q ,2,3,1,1,2,1,3) , we obtain:",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 19,
                    "end": 41,
                    "text": "((3) q ,2,3,1,1,2,1,3)",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Theorem 3."
        },
        {
            "text": "Let us now show that, starting from (x, 101), f can realize three kinds of transformations on x that will turn out to be sufficient to generate all F(n, q).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 3."
        },
        {
            "text": "-Let c \u2208 Sym(n, q) be the following circular permutation:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 3."
        },
        {
            "text": "then for any x \u2208 [[q]] n we have f (1,2,2,1,(3,4,. ..,n)) (x, 101) = (c(x), 011) because:",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 35,
                    "end": 50,
                    "text": "(1,2,2,1,(3,4,.",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Theorem 3."
        },
        {
            "text": "-Consider the transposition k = ((0) n \u2194 1(0) n\u22121 ), then we have, for any",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 3."
        },
        {
            "text": "x \u2208 [[q]] n , f (2,1,1) (x, 101) = (k(x), 011) because:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 3."
        },
        {
            "text": "-Finally, consider the assignment d = ((0) n \u2192 1(0) n\u22121 ), then for any x \u2208 [[q]] n it holds f (2,1,2,1) (x, 101) = (d(x), 001) because:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 3."
        },
        {
            "text": "Since functions c, k and d generate F(n, q) (see [14] or [11] ), the theorem follows.",
            "cite_spans": [
                {
                    "start": 49,
                    "end": 53,
                    "text": "[14]",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 57,
                    "end": 61,
                    "text": "[11]",
                    "ref_id": "BIBREF17"
                }
            ],
            "ref_spans": [],
            "section": "Theorem 3."
        },
        {
            "text": "For any q \u2265 2 and n \u2265 3q, there is f \u2208 F(n, q + 1) which is (n, q)-universal by initialization.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 4."
        },
        {
            "text": "So far we studied what a single function can simulate. We know shift our interest to semigroups generated by some sets of functions.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Simulation by Sets of Networks"
        },
        {
            "text": "An instruction is any f (v) for some f \u2208 F(n, q) and some v \u2208 [1, n] . Burckel showed that any network is the composition of instructions: F(n, q) Seq = f (v) : f \u2208 F(n, q), v \u2208 [1, n] = F(n, q). As an immediate consequence, any permutation in Sym(n, q) is the composition of permutation instructions: Sym(n, q) is exactly f (v) \u2208 Sym(n, q) : f \u2208 F(n, q), v \u2208 [1, n] . We now determine what singular instructions generate: let Any network f can be seen as a vertex colouring of the Hamming graph H(n, q) (x colored by f (x)). From the proposition above, networks in S(n, q) correspond to improper colouring. Since the chromatic number of H(n, q) is equal to q, we deduce that any network with rank at most q \u2212 1 can be generated by singular instructions. However, the network f (x) = (x 1 + . . . + x n , 0, . . . , 0) cannot be generated by singular instructions, since it generates a proper colouring of the Hamming graph.",
            "cite_spans": [
                {
                    "start": 62,
                    "end": 68,
                    "text": "[1, n]",
                    "ref_id": null
                },
                {
                    "start": 360,
                    "end": 366,
                    "text": "[1, n]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Singular Instructions"
        },
        {
            "text": "A network f is idempotent if f 2 = f . Idempotents are pivotal in the theory of semigroups, for they are the identity elements of the subgroups of a given semigroup. In particular it is interesting to know whether a semigroup S is generated by its set of idempotents, because then any element s \u2208 S can be expressed as a product of consecutively distinct idempotents: s = e 1 e 2 . . . e k . We remark that if f \u2208 S(n, q) is idempotent and has rank q n \u2212 1, then it must be an assignment instruction. Theorem 5. S(n, q) is generated by assignment instructions for q \u2265 3.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Singular Instructions"
        },
        {
            "text": "The previous result could be proved using the so-called fifteen-puzzle. In the original puzzle, an image is cut into a four-by-four grid of tiles; one of the tiles is removed, thus creating a hole; the remaining fifteen tiles are scrambled by sliding a tile into the hole. The player is then given the scrambled image, and has to reconstruct it by repeatedly sliding a tile in the hole.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Singular Instructions"
        },
        {
            "text": "Clearly, this game can be played on any simple graph D, where a hole is created at a vertex (say h), and one can \"slide\" one vertex into the hole, the hole thus moving to that vertex. If the hole goes back to its original place h, then we have created a permutation of V (D) \\ h. The set of all possible permutations is closed under composition and hence it forms a group, called the puzzle group G(D, h). Wilson [17] fully characterised that group for 2-connected simple graphs; we give a simpler version of the theorem below. Proof (Proof of Theorem 7). Clearly, 1 implies 2, which in turn is equivalent to 3. We prove 2 implies 4. Let D such that F(D, q) Asy = F(n, q). By Lemma 1, D is strong. We now prove that D has a vertex of in-degree n. Otherwise, let f \u2208 F(D, q) of rank q n \u2212 1. Let a \u2208 O(()f ) and b with |f \u22121 (b)| = 2 (and hence |f \u22121 (x)| = 1 for any other x). We then have",
            "cite_spans": [
                {
                    "start": 413,
                    "end": 417,
                    "text": "[17]",
                    "ref_id": "BIBREF23"
                }
            ],
            "ref_spans": [],
            "section": "Singular Instructions"
        },
        {
            "text": "On the other hand, it is easily seen that for any y \u2208",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Singular Instructions"
        },
        {
            "text": "|f \u22121 v (y)|y mod q = 0.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Singular Instructions"
        },
        {
            "text": "Doing this componentwise for all v, we obtain x\u2208 [[q] ] n f (x) = 0, which is the desired contradiction. We prove 4 implies 1. We only need to show that all instructions in F(n, q) belong to F(D, q) Seq . Let u be a vertex of in-degree n, then we already have any instruction updating u. Let v be another vertex, and g be an instruction updating v,",
            "cite_spans": [
                {
                    "start": 49,
                    "end": 53,
                    "text": "[[q]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Singular Instructions"
        },
        {
            "text": "where h is the instruction updating u such that h u = g v \u2022(u \u2194 v). Then (u \u2194 v) \u2208 F(D, q) Seq according to Lemma 1. Thus, any instruction can be generated.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Singular Instructions"
        },
        {
            "text": "The contrast between the complete sequential simulator for Sym(n, q) and the existence of non-bijective functions that are not sequentially simulatable in the non-Boolean case is striking. We would like first to settle the Boolean case: we conjecture that all functions of F(n, 2) are sequentially simulatable for large enough n. For q \u2265 3, in order to better understand the set of sequentially simulatable networks, one could for instance analyze how much synchronism is required to simulate them (how large are the sets V in the asynchronous updates f (V ) used to simulate them). In particular, one may ask whether, for all n, there exists some network with n entities that require a synchronous update f ( [1,n] ) in order to be simulated asynchronously. Besides, the networks considered in Sects. 2, 3 and 4 have an unconstrained interaction graph. The situation could be very different when restricting all networks to particular a family of interaction graphs (bounded degree, bounded tree-width, etc.). Finally, still concerning interaction graphs, the characterization of Theorem 7 is about reflexive graphs. We would like to extend it to any graph (not necessarily reflexive).",
            "cite_spans": [
                {
                    "start": 710,
                    "end": 715,
                    "text": "[1,n]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Future Work"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "If D is not bipartite and has at least eight vertices, then G(D, h) = Sym(V (D) \\ h)",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "If D is bipartite, then G(D, h) = Alt(V (D) \\ h)",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "Since H(n, q) is not bipartite for q \u2265 3 (and it has at least nine vertices for n \u2265 2), we can apply Wilson's theorem and, after a bit more work",
            "authors": [],
            "year": null,
            "venue": "Using assignment instructions (a \u2192 b) to simulate a network f of rank q n \u2212 1 can be viewed as playing the fifteen-puzzle on the Hamming graph H(n, q): the first",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "graph) which has vertex set V = [1, n] and has an arc from u to v if and only if f v depends essentially on u, i.e. there exists a, b \u2208 [[q]] n such that a V \\u = b V \\u and f v (a) = f v (b). For any graph D with n nodes, we denote the set of networks in F(n, q) whose interaction graph is a",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Note that for any reflexive graph D it holds F(D, q) Seq \u2286 F(D, q) Asy = F(D, q) Syn . The first inclusion is trivial; the equality follows from the fact that for any f \u2208 F(D, q) and any S \u2286 [1, n], f (S) belongs to F(D, q) as well. Moreover, it is clear that if F(H, q) Seq = F(n, q), then H is reflexive (otherwise, F(H, q) Seq would not contain any permutation). The reflexive graphs which can simulate the whole of F(n, q) synchronously were classified by",
            "authors": [],
            "year": null,
            "venue": "A graph is reflexive if for any vertex v, (v, v) is an arc in D",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "q) Seq contains all permutations of variables of F(n, q)",
            "authors": [
                {
                    "first": "",
                    "middle": [],
                    "last": "F(d",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "q) Asy contains all permutations of variables of F(n, q)",
            "authors": [
                {
                    "first": "",
                    "middle": [],
                    "last": "F(d",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Intrinsic simulations and complexities in automata networks. Theses, Aix-Marseile Universit\u00e9",
            "authors": [
                {
                    "first": "F",
                    "middle": [],
                    "last": "Bridoux",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Complete simulation of automata networks",
            "authors": [
                {
                    "first": "F",
                    "middle": [],
                    "last": "Bridoux",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Castillo-Ramirez",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Gadouleau",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "J. Comput. Syst. Sci",
            "volume": "109",
            "issn": "",
            "pages": "1--21",
            "other_ids": {}
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "Simulation of automata networks",
            "authors": [
                {
                    "first": "F",
                    "middle": [],
                    "last": "Bridoux",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Gadouleau",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Theyssier",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "Closed iterative calculus",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Burckel",
                    "suffix": ""
                }
            ],
            "year": 1996,
            "venue": "Theor. Comput. Sci",
            "volume": "158",
            "issn": "",
            "pages": "371--378",
            "other_ids": {}
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "Mapping computation with no memory",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Burckel",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Gioan",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Thom\u00e9",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "Proceedings of International Conference on Unconventional Computation",
            "volume": "",
            "issn": "",
            "pages": "85--97",
            "other_ids": {}
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "Computation with no memory, and rearrangeable multicast networks",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Burckel",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Gioan",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Thom\u00e9",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "Discrete Math. Theor. Comput. Sci",
            "volume": "16",
            "issn": "",
            "pages": "121--142",
            "other_ids": {}
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "Computing in permutation groups without memory",
            "authors": [
                {
                    "first": "P",
                    "middle": [
                        "J"
                    ],
                    "last": "Cameron",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Fairbairn",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Gadouleau",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "Chicago J. Theor. Comput. Sci",
            "volume": "2014",
            "issn": "07",
            "pages": "1--20",
            "other_ids": {}
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "On the influence of the interaction graph on a finite dynamical system",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Gadouleau",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Nat. Comput",
            "volume": "19",
            "issn": "1",
            "pages": "15--28",
            "other_ids": {
                "DOI": [
                    "10.1007/s11047-019-09732-y"
                ]
            }
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "Simple dynamics on graphs",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Gadouleau",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Richard",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Theor. Comput. Sci",
            "volume": "628",
            "issn": "",
            "pages": "62--77",
            "other_ids": {}
        },
        "BIBREF16": {
            "ref_id": "b16",
            "title": "Memoryless computation: new results, constructions, and extensions",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Gadouleau",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Riis",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "Theor. Comput. Sci",
            "volume": "562",
            "issn": "",
            "pages": "129--145",
            "other_ids": {}
        },
        "BIBREF17": {
            "ref_id": "b17",
            "title": "Classical Finite Transformation Semigroups: An Introduction",
            "authors": [
                {
                    "first": "O",
                    "middle": [],
                    "last": "Ganyushkin",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Mazorchuk",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "Algebra and Applications",
            "volume": "9",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF18": {
            "ref_id": "b18",
            "title": "Disjunctive networks and update schedules",
            "authors": [
                {
                    "first": "E",
                    "middle": [],
                    "last": "Goles",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Noual",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Adv. Appl. Math",
            "volume": "48",
            "issn": "5",
            "pages": "646--662",
            "other_ids": {}
        },
        "BIBREF19": {
            "ref_id": "b19",
            "title": "PSPACE-completeness of majority automata networks",
            "authors": [
                {
                    "first": "E",
                    "middle": [],
                    "last": "Goles",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Montealegre",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Salo",
                    "suffix": ""
                },
                {
                    "first": "I",
                    "middle": [],
                    "last": "T\u00f6rm\u00e4",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Theor. Comput. Sci",
            "volume": "609",
            "issn": "",
            "pages": "118--128",
            "other_ids": {
                "DOI": [
                    "10.1016/j.tcs.2015.09.014"
                ]
            }
        },
        "BIBREF20": {
            "ref_id": "b20",
            "title": "Fundamentals of Semigroup Theory",
            "authors": [
                {
                    "first": "J",
                    "middle": [
                        "M"
                    ],
                    "last": "Howie",
                    "suffix": ""
                }
            ],
            "year": 1995,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF21": {
            "ref_id": "b21",
            "title": "Synchronism versus asynchronism in monotonic Boolean automata networks",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Noual",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Sen\u00e9",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Nat. Comput",
            "volume": "17",
            "issn": "2",
            "pages": "393--402",
            "other_ids": {
                "DOI": [
                    "10.1007/s11047-016-9608-8"
                ]
            }
        },
        "BIBREF22": {
            "ref_id": "b22",
            "title": "Computation on binary tree-networks",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Tchuente",
                    "suffix": ""
                }
            ],
            "year": 1986,
            "venue": "Discrete Appl. Math",
            "volume": "14",
            "issn": "",
            "pages": "295--310",
            "other_ids": {}
        },
        "BIBREF23": {
            "ref_id": "b23",
            "title": "Graph puzzles, homotopy, and the alternating group",
            "authors": [
                {
                    "first": "R",
                    "middle": [
                        "M"
                    ],
                    "last": "Wilson",
                    "suffix": ""
                }
            ],
            "year": 1974,
            "venue": "J. Comb. Theory B",
            "volume": "16",
            "issn": "",
            "pages": "86--96",
            "other_ids": {}
        },
        "BIBREF24": {
            "ref_id": "b24",
            "title": "Cellular graph automata. I. basic concepts, graph property measurement, closure properties",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Wu",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Rosenfeld",
                    "suffix": ""
                }
            ],
            "year": 1979,
            "venue": "Inf. Control",
            "volume": "42",
            "issn": "3",
            "pages": "305--329",
            "other_ids": {}
        },
        "BIBREF25": {
            "ref_id": "b25",
            "title": "Cellular graph automata. II. graph and subgraph isomorphism, graph structure recognition",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Wu",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Rosenfeld",
                    "suffix": ""
                }
            ],
            "year": 1979,
            "venue": "Inf. Control",
            "volume": "42",
            "issn": "",
            "pages": "90296--90297",
            "other_ids": {
                "DOI": [
                    "10.1016/S0019-9958(79)90296-1"
                ]
            }
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "For any n \u2265 2 and q \u2265 3, there exists h \u2208 F(n, q) which is not sequentially simulatable. The functions which are not sequentially simulatable produced in the proof of Theorem 1 have two configurations a and b in [[q]] n with the same image and another d which is an orphan with the following property: for each coordinate i where a i and b",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "Secondly, the proof of Theorem 2 showed that there is no f (S) of rank q n \u2212 1. Now, there are two types of networks with rank q n \u2212 2: -Say g is of type I if there exists a \u2208 [[q]] n such that |g \u22121 (a)| = 3 (and hence any other x = a has |g \u22121 (x)| \u2264 1). -Say h is of type II if there exist a, b \u2208 [[q]] n such that |h \u22121 (a)| = |h \u22121 (b)| = 2 (and hence any other x / \u2208 {a, b} has |h \u22121 (x)| \u2264 1).",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "Definition and sequential behavior of \u03c1 : [[2]] 3 \u2192 [[2]] 3 from Theorem 3. Label on arcs represent the coordinate updated.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "For any (x, y) \u2208 [[q]] n \u00d7 [[2]] 3 it holds f ((3) q ,2,3,1,1,2,1,3) (x, y) = (x, 101).",
            "latex": null,
            "type": "figure"
        },
        "FIGREF4": {
            "text": "The semigroup S(n, q) generated by singular instructions consists of all networks f such that there exist a, b \u2208 [[q]] n with f (a) = f (b) and d H (a, b) = 1.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF5": {
            "text": "Theorem 6. (Wilson's fifteen-puzzle theorem). Let D be a 2-connected simple graph, then G(D, h) \u223c = G(D, h ) for all vertices h, h \u2208 V (D). Moreover, if D is the undirected cycle, then G(D, h) is trivial. Otherwise, the following hold.",
            "latex": null,
            "type": "figure"
        },
        "TABREF0": {
            "text": "Proof. We can see any configuration of [[2q]] n as a pair made of a configuration of [[q]] n and a Boolean configuration, so we can as well describe f as a function acting on [[q]] n \u00d7 [[2]] n to simplify notations and use the surjective map \u03c0 : [[q]] n \u00d7 [[2]] n \u2192 [[q]] n that projects onto the first component. We will actually choose f which is the identity map on the coordinates 4 to n on the Boolean component. So, to simplify even further, we will define a function f : [[q]] n \u00d7 [[2]] 3 \u2192 [[q]] n \u00d7 [[2]] 3 . Consider first the function \u03c1 : [[2]] 3 \u2192 [[2]] 3 defined by Fig. 1 and consider the map \u03a8 : [[q]] n \u00d7 [[2]] 3 \u2192 [[q]] n defined by:",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": [
        {
            "text": "Theorem 7. Let D be a reflexive graph on n vertices. Then the following are equivalent.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "annex"
        },
        {
            "text": "A permutation of variables is any network f :=\u03c6 defined by f i (x) = x \u03c6(i) for some \u03c6 \u2208 Sym ([1, n] ). We first show that we can permute variables freely if the graph is strongly connected (and is reflexive for the sequential case). Lemma 1. The following are equivalent for a reflexive graph D.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 93,
                    "end": 100,
                    "text": "([1, n]",
                    "ref_id": null
                }
            ],
            "section": "D is strongly connected and it has a vertex of in-degree n."
        }
    ]
}