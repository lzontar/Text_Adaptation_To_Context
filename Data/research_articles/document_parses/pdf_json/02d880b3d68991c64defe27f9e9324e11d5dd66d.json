{"paper_id": "02d880b3d68991c64defe27f9e9324e11d5dd66d", "metadata": {"title": "Four Flavors of Entailment", "authors": [{"first": "Sibylle", "middle": [], "last": "M\u00f6hle", "suffix": "", "affiliation": {"laboratory": "", "institution": "Johannes Kepler University Linz", "location": {"settlement": "Linz", "country": "Austria"}}, "email": ""}, {"first": "Roberto", "middle": [], "last": "Sebastiani", "suffix": "", "affiliation": {"laboratory": "", "institution": "University of Trento", "location": {"settlement": "Trento", "country": "Italy"}}, "email": ""}, {"first": "Armin", "middle": [], "last": "Biere", "suffix": "", "affiliation": {"laboratory": "", "institution": "Johannes Kepler University Linz", "location": {"settlement": "Linz", "country": "Austria"}}, "email": ""}]}, "abstract": [{"text": "We present a novel approach for enumerating partial models of a propositional formula, inspired by how theory solvers and the SAT solver interact in lazy SMT. Using various forms of dual reasoning allows our CDCL-based algorithm to enumerate partial models with no need for exploring and shrinking full models. Our focus is on model enumeration without repetition, with potential applications in weighted model counting and weighted model integration for probabilistic inference over Boolean and hybrid domains. Chronological backtracking renders the use of blocking clauses obsolete. We provide a formalization and examples. We further discuss important design choices for a future implementation related to the strength of dual reasoning, including unit propagation, using SAT or QBF oracles.", "cite_spans": [], "ref_spans": [], "section": "Abstract"}], "body_text": [{"text": "Model enumeration is a key task in various activities, such as lazy Satisfiability Modulo Theories [29] , predicate abstraction [13] , software product line engineering [7] , model checking [2, 18, 31] , and preimage computation [14, 30] .", "cite_spans": [{"start": 99, "end": 103, "text": "[29]", "ref_id": "BIBREF31"}, {"start": 128, "end": 132, "text": "[13]", "ref_id": "BIBREF14"}, {"start": 169, "end": 172, "text": "[7]", "ref_id": "BIBREF8"}, {"start": 190, "end": 193, "text": "[2,", "ref_id": "BIBREF1"}, {"start": 194, "end": 197, "text": "18,", "ref_id": "BIBREF19"}, {"start": 198, "end": 201, "text": "31]", "ref_id": "BIBREF33"}, {"start": 229, "end": 233, "text": "[14,", "ref_id": "BIBREF15"}, {"start": 234, "end": 237, "text": "30]", "ref_id": "BIBREF32"}], "ref_spans": [], "section": "Introduction"}, {"text": "Whereas in some applications enumerating models multiple times causes no harm, in others avoiding repetitions is crucial. Examples are weighted model counting (WMC) for probabilistic reasoning in Boolean domains and weighted model integration (WMI), which generalizes WMC for hybrid domains [22, 23] . There, the addends are partial satisfying assignments, i.e., some variables remain unassigned. Each of these assignments represents a set of total assignments, and consequently, the number of the addends is reduced. A formula might be represented in a concise manner by the disjunction of its pairwise contradicting partial models, which is of interest in digital circuit synthesis [1] . Partial models are relevant also in predicate abstraction [13] , preimage computation [14, 30] , and existential quantification [4] . They can be obtained by shrinking total models [32] . Alternatively, dual reasoning, where the formula is considered together with its negation, allows for pruning the search space early and detecting partial models. It is also applied in the context of model counting [3, 19] .", "cite_spans": [{"start": 291, "end": 295, "text": "[22,", "ref_id": "BIBREF24"}, {"start": 296, "end": 299, "text": "23]", "ref_id": "BIBREF25"}, {"start": 684, "end": 687, "text": "[1]", "ref_id": "BIBREF0"}, {"start": 748, "end": 752, "text": "[13]", "ref_id": "BIBREF14"}, {"start": 776, "end": 780, "text": "[14,", "ref_id": "BIBREF15"}, {"start": 781, "end": 784, "text": "30]", "ref_id": "BIBREF32"}, {"start": 818, "end": 821, "text": "[4]", "ref_id": "BIBREF4"}, {"start": 871, "end": 875, "text": "[32]", "ref_id": "BIBREF34"}, {"start": 1093, "end": 1096, "text": "[3,", "ref_id": "BIBREF3"}, {"start": 1097, "end": 1100, "text": "19]", "ref_id": "BIBREF21"}], "ref_spans": [], "section": "Introduction"}, {"text": "If only a subset X of the variables is significant, the models are projected onto these relevant variables. We say that we existentially quantify the formula over the irrelevant variables Y and write \u2203Y [ F (X, Y ) ], where F (X, Y ) is a formula over variables X and Y such that X \u2229 Y = \u2205. Projected model enumeration occurs in automotive configuration [34] , existential quantifier elimination [4] , image computation [9, 10] , predicate abstraction [13] , and bounded model checking [31] .", "cite_spans": [{"start": 354, "end": 358, "text": "[34]", "ref_id": "BIBREF36"}, {"start": 396, "end": 399, "text": "[4]", "ref_id": "BIBREF4"}, {"start": 420, "end": 423, "text": "[9,", "ref_id": "BIBREF10"}, {"start": 424, "end": 427, "text": "10]", "ref_id": "BIBREF11"}, {"start": 452, "end": 456, "text": "[13]", "ref_id": "BIBREF14"}, {"start": 486, "end": 490, "text": "[31]", "ref_id": "BIBREF33"}], "ref_spans": [], "section": "Introduction"}, {"text": "To avoid finding models multiple times, blocking clauses might be added to the formula under consideration [11, 18] . This method suffers from a potentially exponential blowup of the formula and consequent slowdown of unit propagation. Toda and Soh [33] address this issue by a variant of conflict analysis, which is motivated by Gebser et al. [8] and is exempt from blocking clauses. Chronological backtracking in Grumberg et al. [9] and our previous work [21] ensures that the search space is traversed in a systematic manner, similarly to DPLL [5] , and the use of blocking clauses is avoided. Whenever a model is found, the last (relevant) decision literal is flipped. No clause asserting this flipped decision is added, which might cause problems during later conflict analysis. This problem is addressed by modifying the implication graph [9] or by an alternative first UIP scheme [33] . Our contribution. We lift the way how theory and SAT solver interact in SMT to propositional projected model enumeration without repetition. Based on the notion of logical entailment, combined with dual reasoning, our algorithm detects partial models in a forward manner, rendering model shrinking superfluous. The test for entailment is crucial in our algorithm. Anticipating a future implementation, we present it in four flavors with different strengths together with examples. The main enumeration engine uses chronological CDCL [25] , is exempt from blocking clauses, and thus does not suffer from a formula blowup. Its projection capabilities make it suitable also for applications requiring model enumeration with projection. We conclude our presentation by a formalization of our algorithm and a discussion of the presented approach. Our work is motivated by projected model counting and weighted model integration. We therefore focus on (projected) model enumeration without repetition. Contrarily to Oztok and Darwiche [26] , we use an oracle and build a Disjoint Sum-of-Products (DSOP) [1] . The work by Lagniez and Marquis [12] is orthogonal to ours. It is led by a disjunctive decomposition of the formula under consideration after a full model is found and also decomposes it into disjoint connected components.", "cite_spans": [{"start": 107, "end": 111, "text": "[11,", "ref_id": "BIBREF12"}, {"start": 112, "end": 115, "text": "18]", "ref_id": "BIBREF19"}, {"start": 249, "end": 253, "text": "[33]", "ref_id": "BIBREF35"}, {"start": 344, "end": 347, "text": "[8]", "ref_id": "BIBREF9"}, {"start": 431, "end": 434, "text": "[9]", "ref_id": "BIBREF10"}, {"start": 457, "end": 461, "text": "[21]", "ref_id": "BIBREF23"}, {"start": 547, "end": 550, "text": "[5]", "ref_id": "BIBREF6"}, {"start": 845, "end": 848, "text": "[9]", "ref_id": "BIBREF10"}, {"start": 887, "end": 891, "text": "[33]", "ref_id": "BIBREF35"}, {"start": 1427, "end": 1431, "text": "[25]", "ref_id": "BIBREF27"}, {"start": 1923, "end": 1927, "text": "[26]", "ref_id": "BIBREF28"}, {"start": 1991, "end": 1994, "text": "[1]", "ref_id": "BIBREF0"}, {"start": 2029, "end": 2033, "text": "[12]", "ref_id": "BIBREF13"}], "ref_spans": [], "section": "Introduction"}, {"text": "A literal is a variable v or its negation \u00acv. We denote by V ( ) the variable of and extend this notation to sets and sequences of literals. We write for the complement of , i.e., = \u00ac , defining \u00ac\u00ac = . A formula in conjunctive normal form (CNF) over variables V is defined as a conjunction of clauses, which are disjunctions of literals with variable in V , whereas a formula in disjunctive normal form (DNF) is a disjunction of cubes, which are conjunctions of literals. We might interpret formulae, clauses, and cubes also as sets of clauses or cubes, and literals and write C \u2208 F for referring to a clause or cube C in a formula F and \u2208 C where is a literal in C. The empty CNF formula and the empty cube are denoted by 1, the empty DNF formula and the empty clause by 0.", "cite_spans": [], "ref_spans": [], "section": "Preliminaries"}, {"text": "A total assignment is a mapping from the set of variables V to the truth values 1 (true) and 0 (false). A trail I = 1 . . . n is a non-contradictory sequence of literals, which might also be interpreted as a (possibly partial) assignment, where I( ) = 1 if \u2208 I and I( ) = 0 if \u00ac \u2208 I. We denote the empty trail by \u03b5 and the set of variables of the literals on I by V (I). Trails and literals might be concatenated, written I = JK and I = J , provided V (J) \u2229 V (K) = \u2205 and V (J) \u2229 V ( ) = \u2205. We interpret I also as a set of literals and write \u2208 I to denote a literal on I. The residual of a formula F under a trail I, written F | I , is obtained by replacing the literals in F , where V ( ) \u2208 V (I), by their truth value, and by recursively propagating truth values through Boolean connectives. In particular, for a CNF formula this consists in removing satisfied clauses as well as falsified literals. By \"=\" in F | I = 1 and F | I = 0, notably by omitting quantifiers, we explicitly mean syntactical equality and consider the (possibly partial) assignment represented by I, i.e., only the literals on I. The notion of residual is extended similarly to clauses and literals. We denote by X \u2212 I the unassigned variables in X. By \u03c0(I, X) we refer to the projection of I onto X and extend this notation to sets of literals.", "cite_spans": [], "ref_spans": [], "section": "Preliminaries"}, {"text": "The decision level function \u03b4 :", "cite_spans": [], "ref_spans": [], "section": "Preliminaries"}, {"text": "first unassigns all literals on I and then assigns literal to decision level d. We mark the decision literals on I by a superscript, i.e., d , and denote the set consisting of the decision literals on I by", "cite_spans": [], "ref_spans": [], "section": "Preliminaries"}, {"text": "Similarly, we denote the set of unit literals in F or its residual under I by units(F ) or units(F | I ). Trails are partitioned into decision levels, and I n is the subsequence of I consisting of all literals where \u03b4( ) n.", "cite_spans": [], "ref_spans": [], "section": "Preliminaries"}, {"text": "Following Sebastiani [28] , we say that a (partial) assignment I entails a formula F , if all total extensions of I satisfy F . In this work it was noticed that, if I entails F , we can not conclude that F | I = 1, but only that F | I is valid. Consider as an example F = (x \u2227 y) \u2228 (x \u2227 \u00acy) over variables X = {x} and Y = {y} and the trail I = x ranging over X \u222a Y . The possible extensions of I are I = xy and I = x\u00acy. We have F | I = F | I = 1, therefore I entails F . Notice that F | I = y \u2228 \u00acy is valid but it syntactically differs from 1.", "cite_spans": [{"start": 21, "end": 25, "text": "[28]", "ref_id": "BIBREF30"}], "ref_spans": [], "section": "Preliminaries"}, {"text": "Our approach is inspired by how theory solvers and the SAT solver interact in lazy SMT. A general schema is described in Fig. 1 . Let F (X, Y ) be a formula over relevant variables X and irrelevant variables Y such that X \u2229Y = \u2205. A SAT solver executes enumeration, either DPLL-based [5, 6] or CDCL-based [17, 24] , on F , maintaining a trail I over variables X \u222a Y . In lines 1-16 and 23-24, we consider the CDCL-based enumeration engine with chronological backtracking of our framework [21] . Now assume unit propagation has been carried out until completion, no conflict occurred and there are still unassigned variables (line 17 [21] , the functions PropagateUnits() and AnalyzeConflict() are taken from our previous work [20] . Entails plays the role of an \"early pruning call\" to a theory solver in SMT, and F plays the role of the theory [29] . Redundant work is saved by applying unit propagation until completion before calling Entails. Modern SAT solvers mostly work on CNFs. Thus, following our dualization approach [19] , we may convert F (X, Y ) and \u00acF (X, Y ) into CNF formulae P (X, Y, S) and N (X, Y, T ), where S and T denote the variables introduced by the CNF encoding. Notice that I \u2227\u00acF is unsatisfiable iff I \u2227N is unsatisfiable. Table 1 lists four examples, which differ in the strength of the required entailment test. The first column lists the formula F , the second and third column show the definitions of X and Y . For a concise representation of formulae, we represent conjunction by juxtaposition and negation by overline. The fourth column contains the current trail I. The fifth to eighth column denote the tests, in ascending order by their strength:", "cite_spans": [{"start": 283, "end": 286, "text": "[5,", "ref_id": "BIBREF6"}, {"start": 287, "end": 289, "text": "6]", "ref_id": "BIBREF7"}, {"start": 304, "end": 308, "text": "[17,", "ref_id": null}, {"start": 309, "end": 312, "text": "24]", "ref_id": "BIBREF26"}, {"start": 487, "end": 491, "text": "[21]", "ref_id": "BIBREF23"}, {"start": 632, "end": 636, "text": "[21]", "ref_id": "BIBREF23"}, {"start": 725, "end": 729, "text": "[20]", "ref_id": "BIBREF22"}, {"start": 844, "end": 848, "text": "[29]", "ref_id": "BIBREF31"}, {"start": 1026, "end": 1030, "text": "[19]", "ref_id": "BIBREF21"}], "ref_spans": [{"start": 121, "end": 127, "text": "Fig. 1", "ref_id": "FIGREF0"}, {"start": 1250, "end": 1257, "text": "Table 1", "ref_id": "TABREF2"}], "section": "Early Pruning for Projected Model Enumeration"}, {"text": "In all examples, I entails F , and \" \" denotes the fact that I passes the test in the column, if applied to the formula in the row.", "cite_spans": [], "ref_spans": [], "section": "Early Pruning for Projected Model Enumeration"}, {"text": "Consider the first example, F = (x 1 \u2228 y \u2228 x 2 ) and I = x 1 . We have F | I = 1, and I entails F , which is detected by the syntactic check. For the second example, F = x 1 y \u2228 yx 2 , we have F | I = y \u2228 y, which is valid, but it syntactically differs from 1. The SAT solver therefore calls Entails on \u00acF \u2227 I. For \u00acF = (x 1 \u2228 y)(y \u2228 x 2 ), we find \u00acF | I = (y)(y). After propagating y, a conflict at decision level zero occurs, hence Entails returns 1, and an incomplete test is sufficient. In this example, \u00acF is already in CNF. The key idea conveyed by it can easily be lifted to the case where additional variables are introduced by the CNF transformation of \u00acF . For the third example, F = x 1 (x 2 y \u2228 x 2 y \u2228 x 2 y \u2228 x 2 y), both P | I and N | I are undefined and contain no units. However, N | I is unsatisfiable, the SAT oracle call on N \u2227I terminates with \"unsat\", and Entails returns 1. Hence, this example requires at least a SAT oracle. For the last example, F = x 1 (x 2 \u2194 y), we define", "cite_spans": [], "ref_spans": [], "section": "Early Pruning for Projected Model Enumeration"}, {"text": "We have P | I = 1. Neither P | I nor N | I contains a unit literal, hence the incomplete test is too weak. Assume a SAT solver is called to check unsatisfiability of N \u2227 I, and x 2 is decided first. After propagating t 2 , t 1 and y, a total model of N is found. The SAT solver answers \"sat\", and Entails returns 0. A QBF solver checking \u03d5 = \u2200X\u2203Y [ x 2 y \u2228 x 2 y ] returns 1. In fact, \u03d5 is true for I = x 2 y and I = x 2 y, and Entails answers 1. Thus, at least a QBF oracle is needed. ", "cite_spans": [], "ref_spans": [], "section": "Early Pruning for Projected Model Enumeration"}, {"text": "The algorithm listed in Fig. 1 can be expressed by means of a formal calculus (Fig. 2) . It extends our previous calculus [21] by projection and by a generalized precondition modeling an incremental call to an oracle for checking entailment (lines 17-22 in function Enumerate). Notably, in our work [21] , only total models are found, while entailment in our actual work enables the detection of partial models. The variables in Y and S (from the CNF encoding) are treated equally with respect to unit propagation and decision. We therefore merge those two variable sets into Y to simplify the formalization. This does not affect the outcome of the entailment test. In favor of a concise description of the rules, we emphasize the differences to our previous framework [21] and refer to this work for more details.", "cite_spans": [{"start": 122, "end": 126, "text": "[21]", "ref_id": "BIBREF23"}, {"start": 299, "end": 303, "text": "[21]", "ref_id": "BIBREF23"}, {"start": 769, "end": 773, "text": "[21]", "ref_id": "BIBREF23"}], "ref_spans": [{"start": 24, "end": 30, "text": "Fig. 1", "ref_id": "FIGREF0"}, {"start": 78, "end": 86, "text": "(Fig. 2)", "ref_id": "FIGREF1"}], "section": "Formalization"}, {"text": "The procedure terminates as soon as either a conflict at decision level zero occurs (rule EndFalse) or a possibly partial model is found and I contains no relevant decision literal (rule EndTrue). Requiring that no relevant decision is left on the trail prevents the recording of redundant models. The projection of I onto X is recorded. Rule Unit remains unchanged except for the missing precondition F | I = 1. If I entails F and contains relevant decision literals, the one at the highest decision level is flipped, and the projection of I onto X is recorded (rule BackTrue). Requiring that the last relevant decision literal is flipped prevents the recording of redundant models. Rule BackFalse remains unchanged. A decision is taken whenever F | I = 0 and F | I contains no unit. Relevant variables are prioritized (rule DecideX) over irrelevant ones (rule DecideY).", "cite_spans": [], "ref_spans": [], "section": "Formalization"}, {"text": "Although not mandatory for correctness, the applicability of rule Unit might be restricted to the case where F | I = 1. Similarly, a decision might be taken only if I does not entail F . Notice that in rules Unit, DecideX, and DecideY, the precondition F | I = 0 can also be omitted.", "cite_spans": [], "ref_spans": [], "section": "Formalization"}, {"text": "In many applications (projected) partial models play a central role. For this purpose, we have presented an algorithm and its formalization inspired by how theory solvers and the SAT solver interact in SMT. The basic idea was to detect partial assignments entailing the formula on-the-fly. We presented entailment tests of different strength and computational cost and discussed examples.", "cite_spans": [], "ref_spans": [], "section": "Conclusion"}, {"text": "The syntactic check \"F | I = 1\" is cheapest, using clause watches or counters for keeping track of the number of satisfied clauses or alternatively the number of assigned variables (line 11 in Fig. 1 ). It is also weakest, since F | I must syntactically coincide with 1. The incomplete check, denoted by \"F | I \u2248 1\", is slightly more involved. It calls a SAT solver on the negation of the formula, restricted, e.g., to unit propagation or a limited number of decision levels, and also might return \"unknown\". The SAT oracle executes an unsatisfiability check of \u00acF \u2227 I, given a (partial) assignment I, which might be too restrictive. The QBF oracle is the most powerful test, but also the most expensive one. It captures entailment under projection in a precise manner expressed by \u2200X\u2203Y [ F | I ] = 1. Combining dual reasoning with oracle calls allows to avoid shrinking of total models. Finally, chronological CDCL renders the use of blocking clauses superfluous.", "cite_spans": [], "ref_spans": [{"start": 193, "end": 199, "text": "Fig. 1", "ref_id": "FIGREF0"}], "section": "Conclusion"}, {"text": "We claim that this is the first method combining dual reasoning and chronological CDCL for partial model detection. It is anticipated that applications with short partial models benefit most, since oracle calls might be expensive. We plan to implement our method and validate its competitiveness on applications from weighted model integration and model counting with or without projection. We also plan to investigate methods concerning the implementation of QBF oracles required by flavour 4), e.g., dependency schemes introduced by Samer and Szeider [27] or incremental QBF solving proposed by Lonsing and Egly [15] .", "cite_spans": [{"start": 553, "end": 557, "text": "[27]", "ref_id": "BIBREF29"}, {"start": 614, "end": 618, "text": "[15]", "ref_id": "BIBREF16"}], "ref_spans": [], "section": "Conclusion"}], "bib_entries": {"BIBREF0": {"ref_id": "b0", "title": "Compact DSOP and partial DSOP forms", "authors": [{"first": "A", "middle": [], "last": "Bernasconi", "suffix": ""}, {"first": "V", "middle": [], "last": "Ciriani", "suffix": ""}, {"first": "F", "middle": [], "last": "Luccio", "suffix": ""}, {"first": "L", "middle": [], "last": "Pagli", "suffix": ""}], "year": 2013, "venue": "Theory Comput. Syst", "volume": "53", "issn": "4", "pages": "583--608", "other_ids": {"DOI": ["10.1007/s00224-013-9447-2"]}}, "BIBREF1": {"ref_id": "b1", "title": "Symbolic model checking without BDDs", "authors": [{"first": "A", "middle": [], "last": "Biere", "suffix": ""}, {"first": "A", "middle": [], "last": "Cimatti", "suffix": ""}, {"first": "E", "middle": [], "last": "Clarke", "suffix": ""}, {"first": "Y", "middle": [], "last": "Zhu", "suffix": ""}], "year": null, "venue": "TACAS 1999", "volume": "1579", "issn": "", "pages": "193--207", "other_ids": {}}, "BIBREF3": {"ref_id": "b3", "title": "An abstract dual propositional model counter", "authors": [{"first": "A", "middle": [], "last": "Biere", "suffix": ""}, {"first": "S", "middle": [], "last": "H\u00f6lldobler", "suffix": ""}, {"first": "S", "middle": [], "last": "M\u00f6hle", "suffix": ""}], "year": 2017, "venue": "YSIP, CEUR Workshop Proceedings", "volume": "1837", "issn": "", "pages": "17--26", "other_ids": {}}, "BIBREF4": {"ref_id": "b4", "title": "Existential quantification as incremental SAT", "authors": [{"first": "J", "middle": [], "last": "Brauer", "suffix": ""}, {"first": "A", "middle": [], "last": "King", "suffix": ""}, {"first": "J", "middle": [], "last": "Kriener", "suffix": ""}], "year": null, "venue": "CAV 2011", "volume": "6806", "issn": "", "pages": "191--207", "other_ids": {}}, "BIBREF6": {"ref_id": "b6", "title": "A machine program for theoremproving", "authors": [{"first": "M", "middle": [], "last": "Davis", "suffix": ""}, {"first": "G", "middle": [], "last": "Logemann", "suffix": ""}, {"first": "D", "middle": ["W"], "last": "Loveland", "suffix": ""}], "year": 1962, "venue": "Commun. ACM", "volume": "5", "issn": "7", "pages": "394--397", "other_ids": {}}, "BIBREF7": {"ref_id": "b7", "title": "A computing procedure for quantification theory", "authors": [{"first": "M", "middle": [], "last": "Davis", "suffix": ""}, {"first": "H", "middle": [], "last": "Putnam", "suffix": ""}], "year": 1960, "venue": "J. ACM", "volume": "7", "issn": "3", "pages": "201--215", "other_ids": {}}, "BIBREF8": {"ref_id": "b8", "title": "Exploiting the enumeration of all feature model configurations: a new perspective with distributed computing", "authors": [{"first": "J", "middle": ["A"], "last": "Galindo", "suffix": ""}, {"first": "M", "middle": [], "last": "Acher", "suffix": ""}, {"first": "J", "middle": ["M"], "last": "Tirado", "suffix": ""}, {"first": "C", "middle": [], "last": "Vidal", "suffix": ""}, {"first": "B", "middle": [], "last": "Baudry", "suffix": ""}, {"first": "D", "middle": [], "last": "Benavides", "suffix": ""}], "year": 2016, "venue": "SPLC", "volume": "", "issn": "", "pages": "74--78", "other_ids": {}}, "BIBREF9": {"ref_id": "b9", "title": "clasp: a conflict-driven answer set solver", "authors": [{"first": "M", "middle": [], "last": "Gebser", "suffix": ""}, {"first": "B", "middle": [], "last": "Kaufmann", "suffix": ""}, {"first": "A", "middle": [], "last": "Neumann", "suffix": ""}, {"first": "T", "middle": [], "last": "Schaub", "suffix": ""}], "year": 2007, "venue": "LPNMR 2007", "volume": "4483", "issn": "", "pages": "260--265", "other_ids": {"DOI": ["10.1007/978-3-540-72200-7_23"]}}, "BIBREF10": {"ref_id": "b10", "title": "Memory efficient all-solutions SAT solver and its application for reachability analysis", "authors": [{"first": "O", "middle": [], "last": "Grumberg", "suffix": ""}, {"first": "A", "middle": [], "last": "Schuster", "suffix": ""}, {"first": "A", "middle": [], "last": "Yadgar", "suffix": ""}], "year": 2004, "venue": "FMCAD 2004", "volume": "3312", "issn": "", "pages": "275--289", "other_ids": {"DOI": ["10.1007/978-3-540-30494-4_20"]}}, "BIBREF11": {"ref_id": "b11", "title": "SAT-based image computation with application in reachability analysis", "authors": [{"first": "A", "middle": [], "last": "Gupta", "suffix": ""}, {"first": "Z", "middle": [], "last": "Yang", "suffix": ""}, {"first": "P", "middle": [], "last": "Ashar", "suffix": ""}, {"first": "A", "middle": [], "last": "Gupta", "suffix": ""}], "year": 2000, "venue": "FMCAD 2000", "volume": "1954", "issn": "", "pages": "391--408", "other_ids": {"DOI": ["10.1007/3-540-40922-X_22"]}}, "BIBREF12": {"ref_id": "b12", "title": "SAT-based analysis and quantification of information flow in programs", "authors": [{"first": "V", "middle": [], "last": "Klebanov", "suffix": ""}, {"first": "N", "middle": [], "last": "Manthey", "suffix": ""}, {"first": "C", "middle": [], "last": "Muise", "suffix": ""}, {"first": "K", "middle": [], "last": "Joshi", "suffix": ""}, {"first": "M", "middle": [], "last": "Siegle", "suffix": ""}, {"first": "M", "middle": [], "last": "Stoelinga", "suffix": ""}, {"first": "", "middle": [], "last": "D&apos; Argenio", "suffix": ""}], "year": 2013, "venue": "QEST 2013", "volume": "8054", "issn": "", "pages": "177--192", "other_ids": {"DOI": ["10.1007/978-3-642-40196-1_16"]}}, "BIBREF13": {"ref_id": "b13", "title": "A recursive algorithm for projected model counting", "authors": [{"first": "J", "middle": [], "last": "Lagniez", "suffix": ""}, {"first": "P", "middle": [], "last": "Marquis", "suffix": ""}], "year": 2019, "venue": "", "volume": "", "issn": "", "pages": "1536--1543", "other_ids": {}}, "BIBREF14": {"ref_id": "b14", "title": "SMT techniques for fast predicate abstraction", "authors": [{"first": "S", "middle": ["K"], "last": "Lahiri", "suffix": ""}, {"first": "R", "middle": [], "last": "Nieuwenhuis", "suffix": ""}, {"first": "A", "middle": [], "last": "Oliveras", "suffix": ""}], "year": 2006, "venue": "CAV 2006", "volume": "4144", "issn": "", "pages": "424--437", "other_ids": {"DOI": ["10.1007/11817963_39"]}}, "BIBREF15": {"ref_id": "b15", "title": "A novel SAT all-solutions solver for efficient preimage computation", "authors": [{"first": "B", "middle": [], "last": "Li", "suffix": ""}, {"first": "M", "middle": ["S"], "last": "Hsiao", "suffix": ""}, {"first": "S", "middle": [], "last": "Sheng", "suffix": ""}], "year": 2004, "venue": "", "volume": "", "issn": "", "pages": "272--279", "other_ids": {}}, "BIBREF16": {"ref_id": "b16", "title": "Incremental QBF solving", "authors": [{"first": "F", "middle": [], "last": "Lonsing", "suffix": ""}, {"first": "U", "middle": [], "last": "Egly", "suffix": ""}], "year": 2014, "venue": "CP 2014", "volume": "8656", "issn": "", "pages": "514--530", "other_ids": {"DOI": ["10.1007/978-3-319-10428-7_38"]}}, "BIBREF17": {"ref_id": "b17", "title": "Computing with SAT oracles: past, present and future", "authors": [{"first": "J", "middle": [], "last": "Marques-Silva", "suffix": ""}], "year": 2018, "venue": "CiE 2018", "volume": "10936", "issn": "", "pages": "264--276", "other_ids": {"DOI": ["10.1007/978-3-319-94418-0_27"]}}, "BIBREF18": {"ref_id": "b18", "title": "GRASP: a search algorithm for propositional satisfiability", "authors": [{"first": "J", "middle": ["P"], "last": "Marques-Silva", "suffix": ""}, {"first": "K", "middle": ["A"], "last": "Sakallah", "suffix": ""}], "year": 1999, "venue": "IEEE Trans. Comput", "volume": "48", "issn": "5", "pages": "506--521", "other_ids": {}}, "BIBREF19": {"ref_id": "b19", "title": "Applying SAT methods in unbounded symbolic model checking", "authors": [{"first": "K", "middle": ["L"], "last": "Mcmillan", "suffix": ""}], "year": null, "venue": "CAV 2002", "volume": "2404", "issn": "", "pages": "250--264", "other_ids": {}}, "BIBREF21": {"ref_id": "b21", "title": "Dualizing projected model counting", "authors": [{"first": "S", "middle": [], "last": "M\u00f6hle", "suffix": ""}, {"first": "A", "middle": [], "last": "Biere", "suffix": ""}], "year": 2018, "venue": "", "volume": "", "issn": "", "pages": "702--709", "other_ids": {}}, "BIBREF22": {"ref_id": "b22", "title": "Backing backtracking", "authors": [{"first": "S", "middle": [], "last": "M\u00f6hle", "suffix": ""}, {"first": "A", "middle": [], "last": "Biere", "suffix": ""}], "year": 2019, "venue": "SAT 2019", "volume": "11628", "issn": "", "pages": "250--266", "other_ids": {"DOI": ["10.1007/978-3-030-24258-9_18"]}}, "BIBREF23": {"ref_id": "b23", "title": "Combining conflict-driven clause learning and chronological backtracking for propositional model counting", "authors": [{"first": "S", "middle": [], "last": "M\u00f6hle", "suffix": ""}, {"first": "A", "middle": [], "last": "Biere", "suffix": ""}], "year": 2019, "venue": "GCAI, EPiC Series in Computing", "volume": "65", "issn": "", "pages": "113--126", "other_ids": {}}, "BIBREF24": {"ref_id": "b24", "title": "Efficient weighted model integration via SMT-based predicate abstraction", "authors": [{"first": "P", "middle": [], "last": "Morettin", "suffix": ""}, {"first": "A", "middle": [], "last": "Passerini", "suffix": ""}, {"first": "R", "middle": [], "last": "Sebastiani", "suffix": ""}], "year": 2017, "venue": "IJCAI", "volume": "", "issn": "", "pages": "720--728", "other_ids": {}}, "BIBREF25": {"ref_id": "b25", "title": "Advanced SMT techniques for weighted model integration", "authors": [{"first": "P", "middle": [], "last": "Morettin", "suffix": ""}, {"first": "A", "middle": [], "last": "Passerini", "suffix": ""}, {"first": "R", "middle": [], "last": "Sebastiani", "suffix": ""}], "year": 2019, "venue": "Artif. Intell", "volume": "275", "issn": "", "pages": "1--27", "other_ids": {}}, "BIBREF26": {"ref_id": "b26", "title": "Chaff: engineering an efficient SAT solver", "authors": [{"first": "M", "middle": ["W"], "last": "Moskewicz", "suffix": ""}, {"first": "C", "middle": ["F"], "last": "Madigan", "suffix": ""}, {"first": "Y", "middle": [], "last": "Zhao", "suffix": ""}, {"first": "L", "middle": [], "last": "Zhang", "suffix": ""}, {"first": "S", "middle": [], "last": "Malik", "suffix": ""}], "year": 2001, "venue": "", "volume": "", "issn": "", "pages": "530--535", "other_ids": {}}, "BIBREF27": {"ref_id": "b27", "title": "Chronological backtracking", "authors": [{"first": "A", "middle": [], "last": "Nadel", "suffix": ""}, {"first": "V", "middle": [], "last": "Ryvchin", "suffix": ""}], "year": 2018, "venue": "SAT 2018", "volume": "10929", "issn": "", "pages": "111--121", "other_ids": {"DOI": ["10.1007/978-3-319-94144-8_7"]}}, "BIBREF28": {"ref_id": "b28", "title": "An exhaustive DPLL algorithm for model counting", "authors": [{"first": "U", "middle": [], "last": "Oztok", "suffix": ""}, {"first": "A", "middle": [], "last": "Darwiche", "suffix": ""}], "year": 2018, "venue": "J. Artif. Intell. Res", "volume": "62", "issn": "", "pages": "1--32", "other_ids": {}}, "BIBREF29": {"ref_id": "b29", "title": "Backdoor sets of quantified Boolean formulas", "authors": [{"first": "M", "middle": [], "last": "Samer", "suffix": ""}, {"first": "S", "middle": [], "last": "Szeider", "suffix": ""}], "year": 2009, "venue": "J. Autom. Reasoning", "volume": "42", "issn": "1", "pages": "77--97", "other_ids": {}}, "BIBREF30": {"ref_id": "b30", "title": "Are you satisfied by this partial assignment?", "authors": [{"first": "R", "middle": [], "last": "Sebastiani", "suffix": ""}], "year": null, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF31": {"ref_id": "b31", "title": "Lazy satisfiability modulo theories", "authors": [{"first": "R", "middle": [], "last": "Sebastiani", "suffix": ""}], "year": 2007, "venue": "JSAT", "volume": "3", "issn": "3-4", "pages": "141--224", "other_ids": {}}, "BIBREF32": {"ref_id": "b32", "title": "Efficient preimage computation using a novel success-driven ATPG", "authors": [{"first": "S", "middle": [], "last": "Sheng", "suffix": ""}, {"first": "M", "middle": ["S"], "last": "Hsiao", "suffix": ""}], "year": 2003, "venue": "", "volume": "", "issn": "", "pages": "10822--10827", "other_ids": {}}, "BIBREF33": {"ref_id": "b33", "title": "Tuning SAT checkers for bounded model checking", "authors": [{"first": "O", "middle": [], "last": "Shtrichman", "suffix": ""}], "year": 2000, "venue": "CAV 2000", "volume": "1855", "issn": "", "pages": "480--494", "other_ids": {"DOI": ["10.1007/10722167_36"]}}, "BIBREF34": {"ref_id": "b34", "title": "Augmenting all solution SAT solving for circuits with structural information", "authors": [{"first": "A", "middle": ["T"], "last": "Tibebu", "suffix": ""}, {"first": "G", "middle": [], "last": "Fey", "suffix": ""}], "year": 2018, "venue": "", "volume": "", "issn": "", "pages": "117--122", "other_ids": {}}, "BIBREF35": {"ref_id": "b35", "title": "Implementing efficient all solutions SAT solvers", "authors": [{"first": "T", "middle": [], "last": "Toda", "suffix": ""}, {"first": "T", "middle": [], "last": "Soh", "suffix": ""}], "year": 2016, "venue": "ACM J. Exp. Algorithmics", "volume": "21", "issn": "1", "pages": "", "other_ids": {}}, "BIBREF36": {"ref_id": "b36", "title": "Boolean quantifier elimination for automotive configuration -a case study", "authors": [{"first": "C", "middle": [], "last": "Zengler", "suffix": ""}, {"first": "W", "middle": [], "last": "K\u00fcchlin", "suffix": ""}], "year": 2013, "venue": "FMICS 2013", "volume": "8187", "issn": "", "pages": "48--62", "other_ids": {"DOI": ["10.1007/978-3-642-41010-9_4"]}}}, "ref_entries": {"FIGREF0": {"text": "decision level function \u03b4 Output: DNF M consisting of models of F projected onto X Enumerate ( F ) 1 I := \u03b5 // empty trail 2 \u03b4 := \u221e // unassign all variables 3 M := 0 // empty DNF 4 forever do 5 C := PropagateUnits ( F , I, \u03b4 ) ( F , I, C, c ) 11 else if all variables in X \u222a Y are assigned then // I is total model 12 if V (decs(I)) \u2229 X = \u2205 then // no relevant decision left 13 return M \u2228 \u03c0(I, X) // record I projected onto X 14 M := M \u2228 \u03c0(I, X) 15 b := \u03b4(decs(\u03c0(I, X))) // highest relevant decision level 16 Backtrack ( I, b \u2212 1 ) // flip last relevant decision 17 else if Entails ( I, F ) then // I is partial model 18 if V (decs(I)) \u2229 X = \u2205 then // no relevant decision left 19 return M \u2228 \u03c0(I, X) // record I projected onto X 20 M := M \u2228 \u03c0(I, X) 21 b := \u03b4(decs(\u03c0(I, X))) // highest relevant decision level 22 Backtrack ( I, b \u2212 1 ) // flip last relevant decision 23 else 24 Decide ( I, \u03b4 ) Early pruning for projected model enumeration. Lines 1-16 and 23-24 list CDCL-based model enumeration with chronological backtracking. If after unit propagation no conflict occurs and not all variables are assigned, an oracle might be called to check whether I entails F (line 17). If Entails returns 1, the relevant decision literal with highest decision level might be flipped. Otherwise, a decision is taken (line 24). Notice that lines 12-16 and lines 18-22 are identical.", "latex": null, "type": "figure"}, "FIGREF1": {"text": "EndTrue: (F, I, M, \u03b4) ;EndTrue M \u2228 m if V (decs(I)) \u2229 X = \u2205 and m def = \u03c0(I, X) and \u2200X\u2203Y [ F |I ] = 1 EndFalse: (F, I, M, \u03b4) ;EndFalse M if exists C \u2208 F and C|I = 0 and \u03b4(C) = 0 Unit: ( F, I, M, \u03b4) ;Unit (F, I , M, \u03b4[ \u2192 a]) if F |I = 0 and exists C \u2208 F with { } = C|I and a def = \u03b4(C \\ { })BackTrue: (F, I, M, \u03b4) ;BackTrue (F, U K , M \u2228 m, \u03b4[L \u221e \u2192 ][ \u2192 b]) ifUV def = I and D def = \u03c0(decs(I), X) and b + 1 def = \u03b4(D) \u03b4(I) and \u2208 D and b = \u03b4(D \\ { }) = \u03b4(U ) and m def = \u03c0(I, X) and K def = V b and L def = V >b and \u2200X\u2203Y [ F |I ] = 1 BackFalse: (F, I, M, \u03b4) ;BackFalse (F, U K , M, \u03b4[L \u221e \u2192 ][ \u2192 j]) if exists C \u2208 F and exists D with UV def = I and C|I = 0 and c def = \u03b4(C) = \u03b4(D) > 0 such that \u2208 D and \u2208 decs(I) and |V = 0 and F \u2227 M |= D and j def = \u03b4(D \\ { }) and b def = \u03b4(U ) = c \u2212 1 and K def = V b and L def = V >b DecideX: (F, I, M, \u03b4) ;DecideX (F, I d , M, \u03b4[ \u2192 d]) if F |I = 0 and units(F |I ) = \u2205 and \u03b4( ) = \u221e and d def = \u03b4(I) + 1 and V ( ) \u2208 X DecideY: (F, I, M, \u03b4) ;DecideY (F, I d , M, \u03b4[ \u2192 d]) if F |I = 0 and units(F |I ) = \u2205 and \u03b4( ) = \u221e and d def = \u03b4(I) + 1 and V ( ) \u2208 Y and X \u2212 I = \u2205 Rules for Enumerate.", "latex": null, "type": "figure"}, "TABREF0": {"text": "). The trail I already might entail F , although F | I = 1. We can check whether I entails F by an incremental call to an \"oracle\"[16] Entails on I and F . If Entails returns 1, then the procedure does not need to test any total extension of I, since all of them are models of F . It can proceed and flip the relevant decision literal", "latex": null, "type": "table"}, "TABREF1": {"text": "Quantified Entailment Condition. We use quantifiers with QBF semantics, and quantified formulae are always closed. A closed QBF formula evaluates to either 1 or 0. Consider \u03d5 = \u2200X\u2200Y [ F | I ], where F is a formula over variables X \u222a Y and the trail I ranges over X \u222a Y . In \u03d5, the remaining variables (X \u222a Y ) \u2212 I are quantified. Accordingly, by \u2200X\u2200Y [ F | I ] = 1, we express that all possible total extensions of I satisfy F , in contrast to F | I = 1, expressing syntactic equality according to Sect. 2. The latter fact implies the former, but not vice versa. Entailment Under Projection. If Entails implements the notion of entailment described in Sect. 2, then by calling it on I and F , we check whether F | J = 1 for all total extensions J of I, i.e., whether \u2200X\u2200Y [ F | I ] = 1. However, since we are interested in the models of F projected onto X, it suffices to check that for each possible assignment J X to the unassigned variables in X, there exists one assignment J Y to the unassigned variables in Y such that F | I = 1 whereI = I \u222a J X \u222a J Y .In essence, we need to determine the truth of the QBF formula \u2200X\u2203Y [ F | I ], which, in general, might be expensive, computationally. In some cases, however, a computationally cheaper (but weaker) test might be sufficient. Entails in line 17 of Enumerate can be seen as a black box pooling four entailment tests of different strengths, which we discuss in the next section.Consider the original entailment condition, \u2200X\u2200Y [ F | I ] = 1. Now we have that \u2200X\u2200Y [ F | I ] = 1 \u21d0\u21d2 \u2203X\u2203Y [ \u00acF | I ] = 0. Therefore, to check whether I entails F , a SAT solver might be called to check whether \u00acF \u2227 I is unsatisfiable. The SAT solver returns \"unsat\", if and only if I entails F . This observation motivates the use of dual reasoning for testing entailment in cases where cheaper tests fail. We present four flavors of the entailment test and provide examples. 1) F | I = 1 (syntactic check ). If F | I = 1, also \u2200X\u2200Y [ F | I ] = 1, and I entails F . 2) F | I \u2248 1 (incomplete check in P). Alternatively, if F | I differs from 1, an incomplete algorithm might be used, to check whether \u00acF \u2227I is unsatisfiable, by for instance executing only unit propagation or aborting after a predefined number of decision levels. 3) F | I \u2261 1 (semantic check in coNP). A SAT oracle runs on \u00acF \u2227 I until termination. Basically, it checks the unsatisfiability of \u00acF \u2227 I, i.e., whether it holds that \u2203X\u2203Y [ \u00acF | I ] = 0. If it answers \"unsat\", then I entails F . 4) \u2200X\u2203Y [F | I ] = 1 (check in \u03a0 P 2 ). A QBF oracle is called to check whether the 2QBF formula \u2200X\u2203Y [F | I ] is 1.", "latex": null, "type": "table"}, "TABREF2": {"text": "Examples of formulae F over relevant variables X and irrelevant variables Y . For a concise representation of formulae, we represent conjunction by juxtaposition and negation by overline. In all examples, I entails F projected onto X. The entailment tests are listed from left to right in ascending order by their strength. Here, \" \" denotes the fact that I passes the test in the column, if applied to the formula in the row.", "latex": null, "type": "table"}}, "back_matter": [{"text": "Acknowledgments. The work was supported by the LIT Secure and Correct Systems Lab funded by the State of Upper Austria, by the QuaSI project funded by D-Wave Systems Inc., and by the Italian Assocation for Artificial Intelligence (AI*IA). We thank the anonymous reviewers and Mathias Fleury for suggesting many textual improvements.", "cite_spans": [], "ref_spans": [], "section": "acknowledgement"}]}