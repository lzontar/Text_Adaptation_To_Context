{"paper_id": "0b4ef6752bb8124be8f8d2ee2f0e8fd62b22319b", "metadata": {"title": "A Resource Usage Efficient Distributed Allocation Algorithm for 5G Service Function Chains", "authors": [{"first": "Guillaume", "middle": [], "last": "Fraysse", "suffix": "", "affiliation": {}, "email": "guillaume.fraysse@orange.com"}, {"first": "Jonathan", "middle": [], "last": "Lejeune", "suffix": "", "affiliation": {"laboratory": "", "institution": "CNRS", "location": {"postCode": "LIP6, 75005", "settlement": "Paris", "region": "Inria", "country": "France"}}, "email": "jonathan.lejeune@lip6.fr"}, {"first": "Julien", "middle": [], "last": "Sopena", "suffix": "", "affiliation": {"laboratory": "", "institution": "CNRS", "location": {"postCode": "LIP6, 75005", "settlement": "Paris", "region": "Inria", "country": "France"}}, "email": "julien.sopena@lip6.fr"}, {"first": "Pierre", "middle": [], "last": "Sens", "suffix": "", "affiliation": {"laboratory": "", "institution": "CNRS", "location": {"postCode": "LIP6, 75005", "settlement": "Paris", "region": "Inria", "country": "France"}}, "email": "pierre.sens@lip6.fr"}]}, "abstract": [{"text": "Recent evolution of networks introduce new challenges for the allocation of resources. Slicing in 5G networks allows multiple users to share a common infrastructure and the chaining of Network Function (NFs) introduces constraints on the order in which NFs are allocated. We first model the allocation of resources for Chains of NFs in 5G Slices. Then we introduce a distributed mutual exclusion algorithm to address the problem of the allocation of resources. We show with selected metrics that choosing an order of allocation of the resources that differs from the order in which resources are used can give better performances. We then show experimental results where we improve the usage rate of resources by more than 20% compared to the baseline algorithm in some cases. The experiments run on our own simulator based on SimGrid.", "cite_spans": [], "ref_spans": [], "section": "Abstract"}], "body_text": [{"text": "The flexibility of 5G networks allows the apparition of new services. Complex services rely on Slices split across multiple Network Service Provider (NSP)s. The allocation of a service is now not only the allocation of a single Network Function (NF) but the chaining of multiple NFs. Chains of NFs introduce a constraint on the order of the allocation.", "cite_spans": [], "ref_spans": [], "section": "Introduction"}, {"text": "We argue that in such use cases the system can be modeled as a distributed system. The various NFs from the different NSPs can be abstracted as resources.", "cite_spans": [], "ref_spans": [], "section": "Introduction"}, {"text": "One or more instances of these resources can be available for each of these resources. We define the allocation of a chain of NFs as a request of a set of resources with an associated request order. The allocation of a request means allocating all the resources in the set while respecting this request order.", "cite_spans": [], "ref_spans": [], "section": "Introduction"}, {"text": "In distributed systems, allocation of resources is seen as a Mutual Exclusion problem. Several variants of the problem have been defined considering a single resource [14, 27] or multiple instances of a single type of resource [25, 26] . Very few solutions have been proposed for the problem of Mutual Exclusion for systems with multiple instances of multiple resources [2, 15] .", "cite_spans": [{"start": 167, "end": 171, "text": "[14,", "ref_id": "BIBREF14"}, {"start": 172, "end": 175, "text": "27]", "ref_id": "BIBREF27"}, {"start": 227, "end": 231, "text": "[25,", "ref_id": "BIBREF25"}, {"start": 232, "end": 235, "text": "26]", "ref_id": "BIBREF26"}, {"start": 370, "end": 373, "text": "[2,", "ref_id": "BIBREF1"}, {"start": 374, "end": 377, "text": "15]", "ref_id": "BIBREF15"}], "ref_spans": [], "section": "Introduction"}, {"text": "We propose here a distributed algorithm to solve the problem of the allocation of resources to create chains of NFs in 5G Slices for Multi-Domain use cases. We address this as a distributed Mutual Exclusion problem. We show that for systems with multiple instances of resources the selection of the instances to allocate has an influence on performances. Our algorithm extends the LASS algorithm [15] for systems with N instances of M resources. We introduce a subroutine to select the instance of the resource based on the orders of the requests as the LASS algorithm does not address this constraint. The algorithm is based on the transmission of a token that contains the permissions to use the resources. In a Network Functions Virtualization (NFV) network the resources are the nodes themselves, and they can't be transferred from one node to another. In such system each node is the manager of its own resource. We propose an extension to manage systems where the decisions to allocate the resources are made locally by each node.", "cite_spans": [{"start": 396, "end": 400, "text": "[15]", "ref_id": "BIBREF15"}], "ref_spans": [], "section": "Introduction"}, {"text": "We introduce a broader description of these use cases as well as some related work and background in Sect. 2. We describe our problem in Sect. 3 . In Sect. 4 we introduce our algorithm, and define the allocation order as distinct from the order in the requests. We then introduce the methodology used to evaluate the algorithm with the SimGrid [3] simulator and show the experimental results in Sect. 5. We finally present our conclusions and future works in Sect. 6.", "cite_spans": [{"start": 143, "end": 144, "text": "3", "ref_id": "BIBREF2"}, {"start": 156, "end": 157, "text": "4", "ref_id": "BIBREF3"}, {"start": 344, "end": 347, "text": "[3]", "ref_id": "BIBREF2"}], "ref_spans": [], "section": "Introduction"}, {"text": "The architecture of Telecom Networks is rapidly evolving. Operators have launched the NFV [10] initiative at the European Telecommunications Standards Institute (ETSI) to move the NFs from dedicated hardware to virtualized infrastructures based on Cloud and Software-Defined Networking (SDN) technologies.", "cite_spans": [{"start": 90, "end": 94, "text": "[10]", "ref_id": "BIBREF9"}], "ref_spans": [], "section": "Related Work"}, {"text": "Allocation of a single NF is rarely sufficient. More complex services require multiple NFs to inter-operate while respecting an order. To this end ETSI defined the VNF Forwarding Graph (VNF FG)s [9] as the analogue to the connection of physical appliances with cables. Following the description of the VNF FG use case in 2013, RFC7665 [22] introduced in 2015 Service Function Chaining (SFC) to allow the allocation of a chain of NFs. In 2017, RFC8402 [23] introduced Segment Routing to allow a node to send a list of instructions to be run by subsequent nodes. problem of resources allocation for multiple NFs in the correct order.", "cite_spans": [{"start": 195, "end": 198, "text": "[9]", "ref_id": "BIBREF8"}, {"start": 335, "end": 339, "text": "[22]", "ref_id": "BIBREF22"}, {"start": 451, "end": 455, "text": "[23]", "ref_id": null}], "ref_spans": [], "section": "Related Work"}, {"text": "5G is the first generation of mobile networks to include NFV as an enabler for new types of services. 3GPP has introduced Network Slices [28, 29] that enables multiple virtual end-to-end networks to share the same NFV infrastructures.", "cite_spans": [{"start": 137, "end": 141, "text": "[28,", "ref_id": "BIBREF28"}, {"start": 142, "end": 145, "text": "29]", "ref_id": null}], "ref_spans": [], "section": "Related Work"}, {"text": "A service offered by a Slice can rely on the infrastructures of multiple NSPs, it is then called Multi-Domain. This can be the case when a large operator has split its network in multiple subdomains (e.g. datacenters) or when a use case may require the infrastructures of multiple operators. The European 5G Public Private Partnership (5G PPP) initiative launched projects that defined several use cases based on Slices and Multi-Domain. The SLICENET project's eHealth use case [29] requires multiple NSPs to provide Slices that are chained together to provide the service.", "cite_spans": [{"start": 478, "end": 482, "text": "[29]", "ref_id": null}], "ref_spans": [], "section": "Related Work"}, {"text": "Multiple centralized solutions exist for the allocation of resources such as Virtual Network Function (VNF) in networks or the placement of Virtual Machines in Cloud infrastructure [11, 20, 24, 31] . These approaches focus on finding an optimal placement depending on a set of constraints. Some papers focus on finding heuristics to respect Service Level Agreement (SLA)s [17] or security rules [12] . These problems are mostly addressed with Integer Linear Programming (ILP) formulations. This centralized method may not be adequate for Multi-Domain use cases when it is not be possible to have a centralized manager or when the cost of building a global view of the system has a high cost. A centralized method also often requires an a priori knowledge of the requests.", "cite_spans": [{"start": 181, "end": 185, "text": "[11,", "ref_id": "BIBREF11"}, {"start": 186, "end": 189, "text": "20,", "ref_id": "BIBREF20"}, {"start": 190, "end": 193, "text": "24,", "ref_id": "BIBREF24"}, {"start": 194, "end": 197, "text": "31]", "ref_id": "BIBREF31"}, {"start": 372, "end": 376, "text": "[17]", "ref_id": "BIBREF17"}, {"start": 395, "end": 399, "text": "[12]", "ref_id": "BIBREF12"}], "ref_spans": [], "section": "Related Work"}, {"text": "We propose to address such systems as distributed systems, and propose a solution where there is no centralized manager. In such systems resources all execute the algorithms locally and get (resp. send) information from (resp. to) other resources by the passing of messages.", "cite_spans": [], "ref_spans": [], "section": "Related Work"}, {"text": "The allocation of resources in distributed systems can be handled as a Mutual Exclusion problem on these resources. The Mutual Exclusion is a fundamental problem in distributed systems and was first described by E. W. Dijkstra in 1965 [7] for systems where multiple processes try to allocate concurrently a single shared resource. Allocating this resource allows them to execute a portion of code known as Critical Section (CS) allowing processes to use the resource exclusively. Multiple solutions [14, 21, 27, 30] have been proposed.", "cite_spans": [{"start": 235, "end": 238, "text": "[7]", "ref_id": "BIBREF6"}, {"start": 499, "end": 503, "text": "[14,", "ref_id": "BIBREF14"}, {"start": 504, "end": 507, "text": "21,", "ref_id": "BIBREF21"}, {"start": 508, "end": 511, "text": "27,", "ref_id": "BIBREF27"}, {"start": 512, "end": 515, "text": "30]", "ref_id": "BIBREF30"}], "ref_spans": [], "section": "Related Work"}, {"text": "The mutual exclusion problem was later generalized in two ways:", "cite_spans": [], "ref_spans": [], "section": "Related Work"}, {"text": "-for systems with one instance of M resources known as the dining philosophers problem, when the requests are static, and drinking philosophers problem, when the requests are dynamic. It was defined by K. M. Chandy and J. Misra in 1984 [4] . -for systems with k instances of a single resource, known as the k-mutex problem [25] . A variant of this problem is known as the k-out of-M resources allocation problem [26] when one process tries to allocate multiple instances of a single type of resource.", "cite_spans": [{"start": 236, "end": 239, "text": "[4]", "ref_id": "BIBREF3"}, {"start": 323, "end": 327, "text": "[25]", "ref_id": "BIBREF25"}, {"start": 412, "end": 416, "text": "[26]", "ref_id": "BIBREF26"}], "ref_spans": [], "section": "Related Work"}, {"text": "Algorithms to solve drinking philosophers problems, need to address potential conflicts between two requests. A conflict occurs when two requests try to allocate a common resource. If two requests don't conflict, they are allowed to enter their CS simultaneously.", "cite_spans": [], "ref_spans": [], "section": "Related Work"}, {"text": "The Dining/Drinking philosophers problem was generalized in 1990 by Awerbuch and Saks [1] as the Dynamic Job Scheduling problem where processes require resources that can be used by a single process at a time. A job can only be executed when all its required resources are available for exclusive use by the process. The problem is also related to the job-shop scheduling optimization problem, in which n jobs have to be scheduled on m machines with the shortest-length schedule. This problem is NP-hard [16] .", "cite_spans": [{"start": 86, "end": 89, "text": "[1]", "ref_id": "BIBREF0"}, {"start": 504, "end": 508, "text": "[16]", "ref_id": "BIBREF16"}], "ref_spans": [], "section": "Related Work"}, {"text": "Algorithms addressing the mutual exclusion for systems with M resources can be divided into two groups: incremental algorithms and simultaneous algorithms. Algorithms in the first group incrementally allocate resources according to a static total order on the resources. They are using consecutive mutexes on each of the M resources. E. W. Dijkstra's algorithm from this group [6] is the baseline algorithm for our comparison and is detailed in Sect. 5.2. Algorithms in the second group do not set a predefined total order on the resources but try to simultaneously allocate resources for multiple requests. To achieve this multiple mechanisms have been proposed. Some require a knowledge of the conflict graph [4, 8] . Others rely on a broadcast mechanism with high messages complexity [18] or a global lock that is not efficient when the concurrency of requests is high [2] . All the simultaneous algorithms have in common to build a total order of the requests to schedule them.", "cite_spans": [{"start": 377, "end": 380, "text": "[6]", "ref_id": "BIBREF5"}, {"start": 711, "end": 714, "text": "[4,", "ref_id": "BIBREF3"}, {"start": 715, "end": 717, "text": "8]", "ref_id": "BIBREF7"}, {"start": 787, "end": 791, "text": "[18]", "ref_id": "BIBREF18"}, {"start": 872, "end": 875, "text": "[2]", "ref_id": "BIBREF1"}], "ref_spans": [], "section": "Related Work"}, {"text": "Finally, it is possible to extend drinking philosopher and k-mutex problems by considering systems with N instances of M types of resources and requests for k instances of 1 or more types, we call it the k \u2212 M \u2212 N problem.", "cite_spans": [], "ref_spans": [], "section": "Related Work"}, {"text": "In a system with N instances of M resources, it is necessary to decide which instance to allocate for a given request. Once an instance has been selected, we have a simplification of the k \u2212 M \u2212 N problem to the drinking philosophers problem, where each instance is uniquely identified by its location. To the best of our knowledge this problem has not been specifically addressed. Some papers address the drinking philosophers problems and mentioned possible extension of their algorithms to systems with N instances [2, 15] but did not consider the selection of the instances as a specific constraint.", "cite_spans": [{"start": 518, "end": 521, "text": "[2,", "ref_id": "BIBREF1"}, {"start": 522, "end": 525, "text": "15]", "ref_id": "BIBREF15"}], "ref_spans": [], "section": "Related Work"}, {"text": "Algorithms from the state of the art don't consider the latency of the network links. They also do not address that the nodes selected for a chain of NFs need to respect a specific request order. In our model we add a weight to the edges of the graph to take this latency into consideration and be able to compute a path that respects the order in which resources are used. They also do not take into consideration that network links are not First In First Out (FIFO) channels. Our algorithm makes no assumption on the order in which messages are received.", "cite_spans": [], "ref_spans": [], "section": "Related Work"}, {"text": "The LASS algorithm [15] is a simultaneous algorithm that addresses systems with a single instance of M resources. It has been shown that its performance are better than those of incremental algorithms. It builds allocation vectors for all requests. These vectors are then used to compute a total order on requests, as detailed in Sect. 3. Our algorithm extends it and includes a preemption mechanism that is used when messages are received in an order that is different from the total order of the requests.", "cite_spans": [{"start": 19, "end": 23, "text": "[15]", "ref_id": "BIBREF15"}], "ref_spans": [], "section": "Related Work"}, {"text": "The allocation of resources for VNF Forwarding Graph (VNF FG) in Multi-Domain 5G slices is addressed as a Mutual Exclusion problem for systems with N instances of M resources. In an example of VNF FG described in [9] , packets need to traverse an Intrusion Detection Systems (IDS), a Firewall (FW) and a Load-Balancer (LB). The left part of Fig. 1 shows this example with three NSPs. The figure shows the cases where there are three instances of each resource distributed across the three NSPs. We model our system as a non-directed connected static graph G = (N , E) where N is the set of nodes and E the set of edges. A node contains at most one resource. Edges have positive weights that allow to model the latency of the links between nodes. A weight of 0 on an edge allows to model a system with multiple resources on a single node. A node with 2 resources can be modeled in the graph as two nodes holding one resource each and connected by a zero-weight edge. We note C the set of types of resources.", "cite_spans": [{"start": 213, "end": 216, "text": "[9]", "ref_id": "BIBREF8"}], "ref_spans": [{"start": 341, "end": 347, "text": "Fig. 1", "ref_id": "FIGREF1"}], "section": "Problem Statement"}, {"text": "Each node in the graph can issue an allocation request. A request is modeled as a couple Req(n, {c 1 , . . ., c s })here:", "cite_spans": [], "ref_spans": [], "section": "Problem Statement"}, {"text": "n is the requesting node, -{c 1 , . . . , c s } where c r \u2208 C, \u2200r is an ordered set of types of resources needed.", "cite_spans": [], "ref_spans": [], "section": "Problem Statement"}, {"text": "The request order gives the order of the resources in the request. The order of resources can be different across requests.", "cite_spans": [], "ref_spans": [], "section": "Problem Statement"}, {"text": "The right side of Fig. 1 shows a model of the use case introduced above. We pose a request Req 1 = Req(n 1 , {c 3 , c 2 , c 1 }) in this system. n 1 is the requesting node, 3 types of resources c 1 , c 2 and c 3 are requested. The request order is c 3 \u2264 c 2 \u2264 c 1 , i.e. first c 3 , then c 2 and finally c 1 .", "cite_spans": [], "ref_spans": [{"start": 18, "end": 24, "text": "Fig. 1", "ref_id": "FIGREF1"}], "section": "Problem Statement"}, {"text": "Our algorithm does not require a knowledge of the conflict graph like [4, 8] . It requires that each node has knowledge of its neighbors and knows where to find each type of resource so that each node can send messages to others.", "cite_spans": [{"start": 70, "end": 73, "text": "[4,", "ref_id": "BIBREF3"}, {"start": 74, "end": 76, "text": "8]", "ref_id": "BIBREF7"}], "ref_spans": [], "section": "Problem Statement"}, {"text": "The first subroutine of the algorithm presented in Sect. 4 computes a path in the graph. A path contains all the nodes from, and including, the requesting node, to the last resource requested, respecting the request order. The path contains the nodes holding the requested resources as well as the nodes connecting those, e.g. a valid path for Req 1 is the ordered set of nodes (n 1 , n 5 , n 7 , n 8 , n 7 , n 5 ). The originating node is n 1 , the first type of resource requested is c 3 and n 8 holds an instance of it. It is necessary to go through n 5 and n 7 to reach n 8 from n 1 . Then n 7 and n 5 hold the two other requested resources.", "cite_spans": [], "ref_spans": [], "section": "Problem Statement"}, {"text": "A request is satisfied when the path contains nodes that hold all the types of resources in the correct request order and all the requested resources are allocated to it, allowing the requesting node to enter its CS.", "cite_spans": [], "ref_spans": [], "section": "Problem Statement"}, {"text": "The algorithm builds an allocation vector for each request. Each entry of an allocation vector is a pair (n, value), called a counter, where n \u2208 N is the node having the requested resource and value is a positive integer incremented by the node upon reception of the request, as detailed in Sect. 4. It is not possible for two requests to get the same counter value for a node n in their allocation vectors. The allocation vector for request Req r is noted V Reqr = ((n r 1 , counter r n1 ), . . . , (n r s , counter r ns )) where r is the identifier of the request and s is the size of request Req r , e.g. a valid allocation vector for Req 1 is V Req1 = ((n 8 , 3), (n 7 , 2), (n 5 , 4)). The allocation vectors allow the algorithm to compute a total order of the requests.", "cite_spans": [], "ref_spans": [], "section": "Problem Statement"}, {"text": "To sort the requests according to the global order we define the precedence of a request Req as its rank in the total order. Req i precedes Req j if the average of the counters of the allocation vector V Reqi is less than the average of the counters of the allocation vector V Reqj . For instance, if we consider Req 2 = Req(n 4 , {c 3 , c 2 , c 1 }) and Req 3 = Req(n 6 , {c 1 , c 2 , c 3 }) with V Req2 = ((n 6 , 3), (n 3 , 3), (n 4 , 1)) and V Req3 = ((n 4 , 2), (n 3 , 2), (n 6 , 1)) their respective allocation vectors, Req 3 will be allocated before", "cite_spans": [], "ref_spans": [], "section": "Problem Statement"}, {"text": "If two allocation vectors have the same average value, it is necessary to add a way to break the tie. No generic method is proposed here since it can be implementation-specific, but the method used in our experimental platform is detailed in Sect. 5.3.", "cite_spans": [], "ref_spans": [], "section": "Problem Statement"}, {"text": "Our algorithm consists of two consecutive subroutines:", "cite_spans": [], "ref_spans": [], "section": "Algorithms"}, {"text": "-the path computation subroutine, in which the algorithm selects the resources instances to be allocated and computes a routing path between them that respects the allocation order present in the request, -the allocation subroutine in which the algorithm allocates the resources selected during the path computation subroutine.", "cite_spans": [], "ref_spans": [], "section": "Algorithms"}, {"text": "This subroutine assumes that each node of the system has some local knowledge on how to reach each type of resource. Each node keeps an up-to-date local routing table containing the name of the neighbor node that is the closest to each type of resource as well as the distance to this node. The entry in the routing table can be the node itself for the type of resource it is holding. How these routing tables are built is out of scope of this paper. The solution used in our simulation is described in Sect. 5. Table 1 gives some routing tables for the system in Fig. 1 . (a) n1", "cite_spans": [], "ref_spans": [{"start": 512, "end": 519, "text": "Table 1", "ref_id": "TABREF0"}, {"start": 564, "end": 570, "text": "Fig. 1", "ref_id": "FIGREF1"}], "section": "Path Computation Subroutine"}, {"text": "In this example, node n 1 's shortest path to the type of resource c 3 is of length 9 and starts at n 5 : (n 1 , n 5 , n 7 , n 8 ), and node n 5 's shortest path to the type of resource c 3 is of length 8 and starts at n 7 : (n 5 , n 7 , n 8 ).", "cite_spans": [], "ref_spans": [], "section": "Path Computation Subroutine"}, {"text": "Path computation relies on the ROUTING message. A first ROUTING message is sent by the requesting node to the node holding the first resource requested, according to its routing table. This node then sends a ROUTING message to the next node on the path to the node holding the next resource. The operation is repeated on each node until a complete path with all the requested resources in the correct order has been found. Figure 2 shows the messages sent during the execution of the algorithm in the sample system.", "cite_spans": [], "ref_spans": [{"start": 423, "end": 431, "text": "Figure 2", "ref_id": null}], "section": "Fig. 2. Algorithm execution for Req1"}, {"text": "This subroutine computes a valid path with the selected instances of all the requested resources in the order given in the request. It does not check that the resources are available nor does it guarantee that the path computed is the shortest path containing all the resources.", "cite_spans": [], "ref_spans": [], "section": "Fig. 2. Algorithm execution for Req1"}, {"text": "Once the algorithm has reached the node holding the last resource requested, the allocation subroutine described below starts from the last node of the path.", "cite_spans": [], "ref_spans": [], "section": "Fig. 2. Algorithm execution for Req1"}, {"text": "Building the Allocation Vector. We compute a total order of the requests to preserve the liveness property, i.e. it guarantees that all requests are satisfied in a finite time. We use the method from the LASS algorithm to compute this order based on vectors build for each request.", "cite_spans": [], "ref_spans": [], "section": "Fig. 2. Algorithm execution for Req1"}, {"text": "The first step is to build the allocation vector for the request. The vector is built by each of the node on the computed path. Each node has a local counter that is initialized to 0. This counter acts as a logical clock, but contrary to Lamport's logical clocks [14] it is local and only incremented by the node when it receives a new request. As such it is then not possible for two requests to get the same counter value for a node in their allocation vector. The first request receives the value 1, the second receives the value 2, and so on. Upon reception of a request a node increments its local counter. It then updates the allocation vector with the value of its counter. The updated allocation vector is inserted in the request message when it is forwarded to the next node in the path. As a simplification this has been merged in our implementation with the ROUTING messages. Thus, the allocation vector is built during the forwarding of the ROUTING messages as shown in Fig. 2. ", "cite_spans": [{"start": 263, "end": 267, "text": "[14]", "ref_id": "BIBREF14"}], "ref_spans": [{"start": 982, "end": 989, "text": "Fig. 2.", "ref_id": null}], "section": "Fig. 2. Algorithm execution for Req1"}, {"text": "The allocation subroutine allocates the instances of resources selected during the path computation subroutine. Nodes receive allocations messages in an arbitrary order, and it can be completely different from the order computed on the requests. To deal with this situation, the subroutine has a preemption mechanism to enforce the total order of the requests. Simulations show that the allocation order within a request has a strong impact on the performance of the algorithm, we compare here two allocation orders. All this is detailed below.", "cite_spans": [], "ref_spans": [], "section": "The Allocation Subroutine"}, {"text": "The Allocation. The core of the allocation subroutine is based on the ALLOC messages. In a system where all the resources are initially in the IDLE state, this message is sent to the first node in the allocation order, detailed below. This node enters the ALLOCATED state and sends an ALLOC message to the next node. The operation is then repeated until the last node in the allocation order is reached. Then the last node send an ALLOC ACK message to the requesting node to inform it that the allocation of all resources has been made. It then enters its CS and starts using the resources. Upon leaving its CS it sends a END CS message that is forwarded along the path to all the nodes holding the requested resources. The messages sent for the allocation of Req 1 are shown on Fig. 2. The Allocation Order. Each request has an associated partial request order for the resources within the request, i.e. the order in which the resources are used, cf. Sect. 3. We define the allocation order as the order used by the algorithm to allocate the resources. There is no relation between the request order and the allocation order and they can be different for a same request. As a mean of comparison, we introduce two different allocation orders that are then evaluated in Sect. 5. The by values allocation order sends the ALLOC messages according to the values of the counters in the allocation vector. The last node of the path sends a ROUTING ACK message to the requesting node. Upon reception of this message the requesting node sends an ALLOC message to the node with the highest counter value in the allocation vector. The allocation then follows the order of the counters in the allocation vector. As an allocation based on this order starts by allocating the node with the highest counter value, it reduces the probability that requests with higher precedence will arrive during the rest of the allocation of the request.", "cite_spans": [], "ref_spans": [{"start": 779, "end": 786, "text": "Fig. 2.", "ref_id": null}], "section": "The Allocation Subroutine"}, {"text": "The reverse order allocation order sends the ALLOC messages in the reverse order of the routing path. The first subroutine follows the path as it selects it. With this reverse order, the allocation follows the path backwards to go back to the requesting node.", "cite_spans": [], "ref_spans": [], "section": "The Allocation Subroutine"}, {"text": "For Req 1 with the computed path (n 1 , n 5 , n 7 , n 8 , n 7 , n 5 ) if the allocation vector is V Req1 = ((n 8 , 3), (n 7 , 2), (n 5 , 4)), the allocation for reverse order follows the order n 5 , n 7 , n 8 . For by values the order is n 5 , n 8 ,n 7 .", "cite_spans": [], "ref_spans": [], "section": "The Allocation Subroutine"}, {"text": "Since the system is distributed a request can arrive on a node already in the ALLOCATED state for a request that has a lower precedence. This can lead to deadlocks. To manage these situations the algorithm preempts the resources to enforce the global order on the requests. This requires an additional state for the nodes, PREEMPTING, and two additional messages: PREEMPT and PREEMPT ACK . The state diagram in Fig. 3a shows how ALLOC messages are handled, Fig. 3b shows how PREEMPT messages are handled. Apart from the case where the node is IDLE described above there are two other cases to consider. If a node is already PREEMPTING, or if it is ALLOCATED and the new request has a lower precedence than the request that currently holds the resource, then the request is stored in a local WAITING queue. Otherwise, i.e., when the node is ALLOCATED and the new request has a higher precedence than the request that currently holds the resource, the algorithm performs a preemption of the resource on the request that currently holds it, named current. To perform a preemption a node sends a PREEMPT message to the node that received its resource, i.e., the node to which it previously sent an ALLOC message for current. If the node that received the PREEMPT is not the last node in the path of current, it continues the preemption to put current on hold. For this it sends a PREEMPT message to the next node in the allocation order of current. current resumes later when it becomes the request with the highest precedence in the WAITING queue. Figure 4 shows how preemption works in the case of Req 2 and Req 3 . When n 3 receives the ALLOC message for Req 3 , it is already ALLOCATED because it has previously received the ALLOC message for Req 2 . It then sends a PRE-EMPT message along the path of Req 2 to n 6 . n 6 accepts the preemption, stores Req 2 in its local WAITING queue and sends back a PREEMPT ACK message. Req 3 then sends an ALLOC message for its last required resource to n 4 . Req 3 is now satisfied and enters its CS. When it leaves its CS, n 6 resumes Req 2 .", "cite_spans": [], "ref_spans": [{"start": 411, "end": 418, "text": "Fig. 3a", "ref_id": "FIGREF2"}, {"start": 457, "end": 464, "text": "Fig. 3b", "ref_id": "FIGREF2"}, {"start": 1545, "end": 1553, "text": "Figure 4", "ref_id": "FIGREF3"}], "section": "Preemption of Resources."}, {"text": "Further Considerations on Preemptions. When a preemption occurs, the algorithm ensures that the resource is always released. Either the node that receives the PREEMPT message decides to release it immediately, either it waits for the current request to leave its CS. As CS have finite durations the algorithm ensures that the resource is released in finite time.", "cite_spans": [], "ref_spans": [], "section": "Preemption of Resources."}, {"text": "If multiple requests have a higher precedence than the one currently holding its resource, a node can receive a PREEMPT message when it is already PREEMPTING. In this case, priority is given to the request with the highest precedence.", "cite_spans": [], "ref_spans": [], "section": "Preemption of Resources."}, {"text": "As the communications channels are not FIFO, even if PREEMPT messages are sent along the same path than the ALLOC messages, a node may receive a PREEMPT before it has received the corresponding ALLOC . To deal with such situations, each node maintains an IGNORE list. When it receives a PRE-EMPT for a request and it has not yet received the corresponding ALLOC , it stores the request in the IGNORE list. When it finally receives the ALLOC for a request that is present in the IGNORE list, it ignores the ALLOC and removes the request from the list.", "cite_spans": [], "ref_spans": [], "section": "Preemption of Resources."}, {"text": "We present an evaluation of the two allocation orders reverse path and by values of the algorithm detailed above. We compare their performance through metrics that are introduced below to Dijkstra's Incremental algorithm detailed in Sect. 5.2 as the baseline.", "cite_spans": [], "ref_spans": [], "section": "Experimental Results"}, {"text": "Several metrics are used to compare the results of the algorithms:", "cite_spans": [], "ref_spans": [], "section": "Metrics and Evaluation"}, {"text": "-the average usage rate is the average time during which resources are used.", "cite_spans": [], "ref_spans": [], "section": "Metrics and Evaluation"}, {"text": "It is the sum of the times during which each resource is used divided by the overall duration of the experiment for all resources. 100% means that all resources are used all the time. 50% means that 50% of the resources are used on average. The objective is to maximize this metric, -the average waiting time is the average time spent by requests between the moment at which they are emitted and the moment they are satisfied. The objective is to minimize this metric, -The average number of messages per request is the ratio between the total number of messages sent in the system for the duration of the test and the number of requests. The objective is to minimize this metric.", "cite_spans": [], "ref_spans": [], "section": "Metrics and Evaluation"}, {"text": "The baseline algorithm for our experiments is Dijkstra's Incremental algorithm [6] . It does not require any additional assumption on the system which allows to evaluate it against the same systems as our algorithm described above. This algorithm is selected because it gives the best average usage rate among all the state of the art algorithms evaluated. Other algorithms are not included here for the sake of space. Our implementation of the algorithm relies on the same first subroutine described above for the selection of the path, but does not require the building of the allocation vectors. The second subroutine of the Incremental algorithm relies on a static global order of the nodes. For the test system in Fig. 1 , our implementation considers that the global order of nodes is n 1 < n 2 < . . . < n 9 according to the subscript value. This algorithm has a drawback we call the domino effect. It is possible when the number of conflicts is high that nodes wait for each other's requests to be finished. Until these resources become available all the resources from nodes that come after in the order are unavailable. The probability of occurrence of the domino effect increases with the size of the requests.", "cite_spans": [{"start": 79, "end": 82, "text": "[6]", "ref_id": "BIBREF5"}], "ref_spans": [{"start": 719, "end": 725, "text": "Fig. 1", "ref_id": "FIGREF1"}], "section": "Dijkstra's Incremental Algorithm"}, {"text": "The algorithms have been tested on topologies from the Internet Topology Zoo [13] , a dataset of topologies provided by Operators. The topologies are enriched with resources distributed across their nodes. Weights are attributed to the network links between the nodes to simulate the latency. To limit the number of parameters, all experiments in this paper use the same constant weight for all the links.", "cite_spans": [{"start": 77, "end": 81, "text": "[13]", "ref_id": "BIBREF13"}], "ref_spans": [], "section": "Simulating the System with SimGrid"}, {"text": "The results presented here are based on the Cesnet200706 topology which consists of N = 44 nodes. This topology was selected because it has a sufficient enough size to avoid the possible bias in the results from topologies that have few nodes. Larger topologies lead to longer simulation times to get similar results. In this topology, the degrees of the nodes vary from 1 to 18, with an average degree of 2.", "cite_spans": [], "ref_spans": [], "section": "Simulating the System with SimGrid"}, {"text": "The simulator is based on SimGrid 3.23 [3] . SimGrid provides multiple Routing Models for the routing of packets between nodes. The experiments use only the Full routing model. This model requires all routes to be explicitly described in the configuration file. It ensures that no routing algorithm is used to connect two nodes that are not explicitly connected by a Link to each other. It allows the routing of the packets to be made at the application level and thus allows to simulate the first subroutine of the algorithm.", "cite_spans": [{"start": 39, "end": 42, "text": "[3]", "ref_id": "BIBREF2"}], "ref_spans": [], "section": "Simulating the System with SimGrid"}, {"text": "The routing tables necessary for the first subroutine are built statically by the simulator during the initialization using Dijkstra's Shortest Path algorithm [5] . Routing tables are based on the Link and Hosts of the configuration.", "cite_spans": [{"start": 159, "end": 162, "text": "[5]", "ref_id": "BIBREF4"}], "ref_spans": [], "section": "Simulating the System with SimGrid"}, {"text": "The system is under maximum load during the tests. To achieve this, the simulation starts as many requests as there are nodes in the system, and a new request is sent as soon as a request ends. The contents of the requests are generated by the node following a linear random function. The size of the requests in a single experiment is constant. As shown by other experimental results not included here for sake of space, using a constant size does not affect the results significantly.", "cite_spans": [], "ref_spans": [], "section": "Simulating the System with SimGrid"}, {"text": "The duration of all experiments is the same. The time spent in CS by the requests is also constant. Empirically we settled for a duration of CS of 300, 000 and a duration of experiment of 500, 000, 000 so that time spent in CS is orders of magnitude longer than the time spent to send a message between nodes. These durations are in simulator time unit. This approximately simulates CS of 30 s and a total simulation duration of 14 h. Experiments show that this duration is long enough to make the impact of randomness negligible and the results representative.", "cite_spans": [], "ref_spans": [], "section": "Simulating the System with SimGrid"}, {"text": "In this experimental platform, if two allocation vectors have the same average value, the id of the nodes are used to break the tie. Since requests all have the same size, we first compare the id of the first nodes in each allocation vector. If it is the same node for both requests, we compare the id of second nodes and so on. It this comparison also results in a tie, when both requests are for the same nodes, then the internal identifiers of the requests are compared. Figure 5 shows the results of the evaluation of the metrics defined in Sect. 3 for the Incremental and the algorithm detailed in Sect. 4 using two allocation orders : reverse path and by values in two different system configurations detailed below. The x-axis show the size of requests for a given simulation. Both axes of all the figures use a logarithmic scale. For requests of size 2 to 7, we can observe that Average Usage Rate decreases for all the algorithms. We reach a minimum between 7 and 9 depending on the algorithms. This can be deduced from Maekawa's proof of his quorum algorithm [19] , based on Finite Projective Planes properties, that \u221a N \u2248 6.63 is the minimum size so that all requests have at least one intersection. Usage rate rises up again after this lowest point because requests become larger and even if there are more conflicts between requests, each request leads to the allocation of a larger number of resources.", "cite_spans": [{"start": 1069, "end": 1073, "text": "[19]", "ref_id": "BIBREF19"}], "ref_spans": [{"start": 474, "end": 482, "text": "Figure 5", "ref_id": "FIGREF4"}], "section": "Simulating the System with SimGrid"}, {"text": "If the size of requests is greater than half the size of the system, then it is not possible to allocate concurrently two requests. In such situations the only possibility is to allocate the requests sequentially. The Average Usage Rate of the system then grows linearly with the size of the requests. The figure has been truncated at size 30 for the sake of readability. It is almost 100% for requests of size N as each consecutive request allocates all the resources. It is not exactly 100% due to the cost of the algorithm.", "cite_spans": [], "ref_spans": [], "section": "System with 1 Instance of M Resources"}, {"text": "Our algorithms show an improvement on the Incremental of the Average Usage Rate with both allocation orders. The by values allocation order gives the best results for all metrics. For the Average Usage Rate we can see improvement of up to 20% from the Incremental. As shown in Fig. 5b , by values does not generate more messages than the Incremental whereas reverse path shows a larger number of messages for requests of size 4 and more. This is due to the high number of preemptions taking place. The by values order limits the number of preemptions by starting with the node that has the highest counter value. This node is the most likely to receive requests with a higher precedence. Once its resource is allocated, the probability that the other nodes are preempted by requests with higher precedence gets lower. Experimental results show in Fig. 5c that the by values order does not impact negatively the Average Waiting Time. The Average Waiting Time for the Incremental algorithm is significantly worse than for any of the variants. This is due to the domino effect. For the sake of space a full comparison with a near-optimal allocation is not included here, but results show that even the best results included here are 10 to 20 points lower than a near-optimal solution until requests of size 11, after which the difference starts to decrease. Figure 6 shows the Average Usage Rate of the same algorithms on the same topology but with a different placement of the resources. Instead of a single instance of each resource, the system holds 4 instances for each of C = 11 different types. The figure includes three additional algorithms. Each of this additional algorithm is a variant of one of the three presented above: it uses the same allocation subroutine but a different path computation subroutine. As the path computation subroutine detailed in Sect. 4.1 uses a static routing table, a node always selects the same node for a type of resource. The result is that the load is not well balanced across all the instances, which leads to lower Average Usage Rate. For requests of size 4, the lowest Average Usage Rate observed, the algorithm with the best result, the by values, reaches around 17%. This is lower than the worst result for the configuration with a single instance of M resources in Fig. 5a where the Incremental reaches 27%.", "cite_spans": [], "ref_spans": [{"start": 277, "end": 284, "text": "Fig. 5b", "ref_id": "FIGREF4"}, {"start": 847, "end": 854, "text": "Fig. 5c", "ref_id": "FIGREF4"}, {"start": 1355, "end": 1363, "text": "Figure 6", "ref_id": "FIGREF5"}, {"start": 2311, "end": 2318, "text": "Fig. 5a", "ref_id": "FIGREF4"}], "section": "System with 1 Instance of M Resources"}, {"text": "As shown in the three additional algorithms, the load balancing improves with a simple round-robin on the different instances of each type of resource during the path computation subroutine. For example with 4 instances of c 1 , the first request selects the first instance, the second request the second one, and so on. It starts over with the fifth request that selects the first one. The selection of the route has a significant impact when there are more than one instance of the resources and improves the Average Usage Rate. ", "cite_spans": [], "ref_spans": [], "section": "System with N Instances of M Resources"}, {"text": "We introduced in this paper a new algorithm for distributed Mutual Exclusion for systems with N instances of M resources, known as the k \u2212 M \u2212 N problem. This is applicable to the allocation of Multi-Domain Chains of NFs in 5G Slices. We show an improvement of up to 20% of the Average Usage Rate of resources from the baseline Incremental algorithm, with an Average Waiting Time that can be several orders of magnitude lower and no degradation of the number of messages. The results show the impact of the allocation order in which allocation is performed. The presented results focus on a few key parameters.", "cite_spans": [], "ref_spans": [], "section": "Conclusion and Future Works"}, {"text": "For the path allocation subroutine of the algorithm, the results showed the importance of the selection of the instance when N > 1. We plan to study how the performance can be further improved.", "cite_spans": [], "ref_spans": [], "section": "Conclusion and Future Works"}, {"text": "Our approach to the allocation of resources in the allocation subroutine is pessimistic, i.e., it considers that deadlocks are going to happen. But their probability of occurrence can be low in some situations. We plan to study an optimistic approach that let deadlocks occur and fix them a posteriori.", "cite_spans": [], "ref_spans": [], "section": "Conclusion and Future Works"}, {"text": "We also plan to implement the algorithm in the scheduler of a NFV platform, if possible in the live network of an Operator.", "cite_spans": [], "ref_spans": [], "section": "Conclusion and Future Works"}], "bib_entries": {"BIBREF0": {"ref_id": "b0", "title": "A dining philosophers algorithm with polynomial response time", "authors": [{"first": "B", "middle": [], "last": "Awerbuch", "suffix": ""}, {"first": "M", "middle": [], "last": "Saks", "suffix": ""}], "year": 1990, "venue": "Proceedings [1990] 31st Annual Symposium on Foundations of Computer Science", "volume": "1", "issn": "", "pages": "65--74", "other_ids": {}}, "BIBREF1": {"ref_id": "b1", "title": "A Distributed Token-Based Algorithm for the Dynamic Resource Allocation Problem", "authors": [{"first": "A", "middle": [], "last": "Bouabdallah", "suffix": ""}, {"first": "C", "middle": [], "last": "Laforest", "suffix": ""}], "year": 2000, "venue": "SIGOPS Oper. Syst. Rev", "volume": "34", "issn": "3", "pages": "60--68", "other_ids": {}}, "BIBREF2": {"ref_id": "b2", "title": "Versatile, scalable, and accurate simulation of distributed applications and platforms", "authors": [{"first": "H", "middle": [], "last": "Casanova", "suffix": ""}], "year": 2014, "venue": "J. Parallel Distrib. Comput", "volume": "74", "issn": "10", "pages": "2899--2917", "other_ids": {}}, "BIBREF3": {"ref_id": "b3", "title": "The drinking philosophers problem", "authors": [{"first": "K", "middle": ["M"], "last": "Chandy", "suffix": ""}, {"first": "J", "middle": [], "last": "Misra", "suffix": ""}], "year": 1984, "venue": "ACM Trans. Program. Lang. Syst", "volume": "6", "issn": "4", "pages": "632--646", "other_ids": {}}, "BIBREF4": {"ref_id": "b4", "title": "A note on two problems in connexion with graphs", "authors": [{"first": "E", "middle": ["W"], "last": "Dijkstra", "suffix": ""}], "year": 1959, "venue": "Numer. Math", "volume": "1", "issn": "1", "pages": "269--271", "other_ids": {}}, "BIBREF5": {"ref_id": "b5", "title": "Hierarchical ordering of sequential processes", "authors": [{"first": "E", "middle": ["W"], "last": "Dijkstra", "suffix": ""}], "year": 1971, "venue": "Acta Informatica", "volume": "1", "issn": "2", "pages": "115--138", "other_ids": {}}, "BIBREF6": {"ref_id": "b6", "title": "Solution of a problem in concurrent programming control", "authors": [{"first": "E", "middle": ["W"], "last": "Dijkstra", "suffix": ""}], "year": 1965, "venue": "Commun. ACM", "volume": "8", "issn": "9", "pages": "", "other_ids": {}}, "BIBREF7": {"ref_id": "b7", "title": "An efficient solution to the drinking philosophers problem and its extensions", "authors": [{"first": "D", "middle": [], "last": "Ginat", "suffix": ""}, {"first": "A", "middle": ["U"], "last": "Shankar", "suffix": ""}, {"first": "A", "middle": ["K"], "last": "Agrawala", "suffix": ""}], "year": 1989, "venue": "WDAG 1989", "volume": "392", "issn": "", "pages": "83--93", "other_ids": {"DOI": ["10.1007/3-540-51687-5_34"]}}, "BIBREF8": {"ref_id": "b8", "title": "Network Functions Virtualisation (NFV) Use Cases", "authors": [{"first": "", "middle": [], "last": "Etsi Nfv Isg", "suffix": ""}, {"first": "", "middle": [], "last": "Etsi", "suffix": ""}, {"first": "", "middle": [], "last": "Nfv", "suffix": ""}], "year": 2013, "venue": "", "volume": "001", "issn": "", "pages": "", "other_ids": {}}, "BIBREF9": {"ref_id": "b9", "title": "ETSI GS NFV-MAN 001 V1.1.1 Network Functions Virtualisation (NFV)", "authors": [{"first": "", "middle": [], "last": "Etsi", "suffix": ""}, {"first": "", "middle": [], "last": "Isg", "suffix": ""}], "year": null, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF11": {"ref_id": "b11", "title": "Resource management in clouds: survey and research challenges", "authors": [{"first": "B", "middle": [], "last": "Jennings", "suffix": ""}, {"first": "R", "middle": [], "last": "Stadler", "suffix": ""}], "year": 2014, "venue": "J. Netw. Syst. Manage", "volume": "23", "issn": "3", "pages": "567--619", "other_ids": {"DOI": ["10.1007/s10922-014-9307-7"]}}, "BIBREF12": {"ref_id": "b12", "title": "Supporting security requirements for resource management in cloud computing", "authors": [{"first": "R", "middle": [], "last": "Jhawar", "suffix": ""}], "year": 2012, "venue": "2012 IEEE 15th International Conference on Computational Science and Engineering", "volume": "", "issn": "", "pages": "170--177", "other_ids": {}}, "BIBREF13": {"ref_id": "b13", "title": "The internet topology zoo", "authors": [{"first": "S", "middle": [], "last": "Knight", "suffix": ""}], "year": 2011, "venue": "IEEE J. Sel. Areas Commun", "volume": "29", "issn": "9", "pages": "1765--1775", "other_ids": {}}, "BIBREF14": {"ref_id": "b14", "title": "Time, clocks, and the ordering of events in a distributed system", "authors": [{"first": "L", "middle": [], "last": "Lamport", "suffix": ""}], "year": 1978, "venue": "Commun. ACM", "volume": "21", "issn": "7", "pages": "558--565", "other_ids": {}}, "BIBREF15": {"ref_id": "b15", "title": "Reducing synchronization cost in distributed multi-resource allocation problem", "authors": [{"first": "J", "middle": [], "last": "Lejeune", "suffix": ""}], "year": 2015, "venue": "44th International Conference on Parallel Processing", "volume": "", "issn": "", "pages": "540--549", "other_ids": {}}, "BIBREF16": {"ref_id": "b16", "title": "The complexity of flowshop and jobshop scheduling -mathematics of operations research", "authors": [{"first": "M", "middle": ["R"], "last": "Garey", "suffix": ""}], "year": 1976, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {"DOI": ["https:/pubsonline.informs.org/doi/abs/10.1287/moor.1.2.117"]}}, "BIBREF17": {"ref_id": "b17", "title": "Redundant virtual machine placement for fault-tolerant consolidated server clusters", "authors": [{"first": "F", "middle": [], "last": "Machida", "suffix": ""}], "year": 2010, "venue": "2010 IEEE Network Operations and Management Symposium -NOMS 2010", "volume": "", "issn": "", "pages": "32--39", "other_ids": {}}, "BIBREF18": {"ref_id": "b18", "title": "Token based solutions to m resources allocation problem", "authors": [{"first": "A", "middle": [], "last": "Maddi", "suffix": ""}], "year": 1997, "venue": "Proceedings of the 1997 ACM Symposium on Applied Computing. SAC 1997", "volume": "", "issn": "", "pages": "340--344", "other_ids": {}}, "BIBREF19": {"ref_id": "b19", "title": "A N algorithm for mutual exclusion in decentralized systems", "authors": [{"first": "M", "middle": [], "last": "Maekawa", "suffix": ""}], "year": 1985, "venue": "ACM Trans. Comput. Syst", "volume": "3", "issn": "2", "pages": "145--159", "other_ids": {}}, "BIBREF20": {"ref_id": "b20", "title": "Comparing VM-placement algorithms for on-demand clouds", "authors": [{"first": "K", "middle": [], "last": "Mills", "suffix": ""}], "year": 2011, "venue": "2011 IEEE Third International Conference on Cloud Computing Technology and Science", "volume": "", "issn": "", "pages": "91--98", "other_ids": {}}, "BIBREF21": {"ref_id": "b21", "title": "A log (N) distributed mutual exclusion algorithm based on path reversal", "authors": [{"first": "M", "middle": [], "last": "Naimi", "suffix": ""}], "year": 1996, "venue": "J. Parallel Distrib. Comput", "volume": "34", "issn": "1", "pages": "1--13", "other_ids": {}}, "BIBREF22": {"ref_id": "b22", "title": "Service Function Chaining (SFC) Architecture", "authors": [{"first": "C", "middle": [], "last": "Pignataro", "suffix": ""}, {"first": "J", "middle": [], "last": "Halpern", "suffix": ""}], "year": 2015, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF24": {"ref_id": "b24", "title": "Generalized resource allocation for the cloud", "authors": [{"first": "A", "middle": [], "last": "Rai", "suffix": ""}], "year": 2012, "venue": "Proceedings of the Third ACM Symposium on Cloud Computing", "volume": "15", "issn": "", "pages": "1--15", "other_ids": {}}, "BIBREF25": {"ref_id": "b25", "title": "A tree-based algorithm for distributed mutual exclusion", "authors": [{"first": "K", "middle": [], "last": "Raymond", "suffix": ""}], "year": 1989, "venue": "ACM Trans. Comput. Syst", "volume": "7", "issn": "1", "pages": "61--77", "other_ids": {}}, "BIBREF26": {"ref_id": "b26", "title": "A distributed solution to the k -out of-M resources allocation problem", "authors": [{"first": "M", "middle": [], "last": "Raynal", "suffix": ""}], "year": 1991, "venue": "ICCI 1991", "volume": "497", "issn": "", "pages": "599--609", "other_ids": {"DOI": ["10.1007/3-540-54029-6_209"]}}, "BIBREF27": {"ref_id": "b27", "title": "An optimal algorithm for mutual exclusion in computer networks", "authors": [{"first": "G", "middle": [], "last": "Ricart", "suffix": ""}, {"first": "A", "middle": ["K"], "last": "Agrawala", "suffix": ""}], "year": 1981, "venue": "Commun. ACM", "volume": "24", "issn": "1", "pages": "9--17", "other_ids": {}}, "BIBREF28": {"ref_id": "b28", "title": "Network slicing to enable scalability and flexibility in 5G mobile networks", "authors": [{"first": "P", "middle": [], "last": "Rost", "suffix": ""}], "year": 2017, "venue": "IEEE Commun. Mag", "volume": "55", "issn": "5", "pages": "72--79", "other_ids": {}}, "BIBREF30": {"ref_id": "b30", "title": "A distributed mutual exclusion algorithm", "authors": [{"first": "I", "middle": [], "last": "Suzuki", "suffix": ""}, {"first": "T", "middle": [], "last": "Kasami", "suffix": ""}], "year": 1985, "venue": "ACM Trans. Comput. Syst", "volume": "3", "issn": "4", "pages": "344--349", "other_ids": {}}, "BIBREF31": {"ref_id": "b31", "title": "Cloud computing reference model: the modelling of service availability based on application profile and resource allocation", "authors": [{"first": "A", "middle": [], "last": "Widjajarto", "suffix": ""}], "year": 2012, "venue": "2012 International Conference on Cloud Computing and Social Networking (ICCCSN)", "volume": "", "issn": "", "pages": "1--4", "other_ids": {}}}, "ref_entries": {"FIGREF1": {"text": "A system with 3 types of resources: c1 (IDS), c2 (FW), and c3 (LB)", "latex": null, "type": "figure"}, "FIGREF2": {"text": "a) ALLOC messages (b) PREEMPT messages State diagrams for ALLOC and PREEMPT messages", "latex": null, "type": "figure"}, "FIGREF3": {"text": "Allocations for Req2 and Req3, preemption of n6 by Req2", "latex": null, "type": "figure"}, "FIGREF4": {"text": "a) average usage rates (b) average nb of messages (c) average waiting times Evaluation for one instance of 44 types of resources", "latex": null, "type": "figure"}, "FIGREF5": {"text": "Evaluation for 4 instances of 11 types of resources", "latex": null, "type": "figure"}, "TABREF0": {"text": "Routing tables for n1, n5 and n7. D is for Distance.", "latex": null, "type": "table"}, "TABREF1": {"text": "This section shows the evaluation on a system with one instance of C = 44 types of resources.For requests of size 1, Figs. 5a and 5b show that the algorithm itself has no influence on the Average Usage Rate or the Average Waiting Time. In such configuration, no preemption is performed.", "latex": null, "type": "table"}}, "back_matter": []}