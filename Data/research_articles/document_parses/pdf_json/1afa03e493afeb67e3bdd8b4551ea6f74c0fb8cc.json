{"paper_id": "1afa03e493afeb67e3bdd8b4551ea6f74c0fb8cc", "metadata": {"title": "An SMT Theory of Fixed-Point Arithmetic", "authors": [{"first": "Marek", "middle": [], "last": "Baranowski", "suffix": "", "affiliation": {"laboratory": "", "institution": "University of Utah", "location": {"settlement": "Salt Lake City", "region": "UT", "country": "USA"}}, "email": "baranows@cs.utah.edu"}, {"first": "Shaobo", "middle": [], "last": "He", "suffix": "", "affiliation": {"laboratory": "", "institution": "University of Utah", "location": {"settlement": "Salt Lake City", "region": "UT", "country": "USA"}}, "email": "shaobo@cs.utah.edu"}, {"first": "Mathias", "middle": [], "last": "Lechner", "suffix": "", "affiliation": {"laboratory": "", "institution": "IST Austria", "location": {"settlement": "Klosterneuburg", "country": "Austria"}}, "email": "mathias.lechner@ist.ac.at"}, {"first": "Thanh", "middle": ["Son"], "last": "Nguyen", "suffix": "", "affiliation": {"laboratory": "", "institution": "University of Utah", "location": {"settlement": "Salt Lake City", "region": "UT", "country": "USA"}}, "email": "thanhson@cs.utah.edu"}, {"first": "Zvonimir", "middle": [], "last": "Rakamari\u0107", "suffix": "", "affiliation": {"laboratory": "", "institution": "University of Utah", "location": {"settlement": "Salt Lake City", "region": "UT", "country": "USA"}}, "email": "zvonimir@cs.utah.edu"}]}, "abstract": [{"text": "Fixed-point arithmetic is a popular alternative to floatingpoint arithmetic on embedded systems. Existing work on the verification of fixed-point programs relies on custom formalizations of fixed-point arithmetic, which makes it hard to compare the described techniques or reuse the implementations. In this paper, we address this issue by proposing and formalizing an SMT theory of fixed-point arithmetic. We present an intuitive yet comprehensive syntax of the fixed-point theory, and provide formal semantics for it based on rational arithmetic. We also describe two decision procedures for this theory: one based on the theory of bit-vectors and the other on the theory of reals. We implement the two decision procedures, and evaluate our implementations using existing mature SMT solvers on a benchmark suite we created. Finally, we perform a case study of using the theory we propose to verify properties of quantized neural networks.", "cite_spans": [], "ref_spans": [], "section": "Abstract"}], "body_text": [{"text": "Algorithms based on real arithmetic have become prevalent. For example, the mathematical models in machine learning algorithms operate on real numbers. Similarly, signal processing algorithms often implemented on embedded systems (e.g., fast Fourier transform) are almost always defined over real numbers. However, real arithmetic is not implementable on computer systems due to its unlimited precision. Consequently, we use implementable approximations of real arithmetic, such as floating-point and fixed-point arithmetic, to realize these algorithms in practice.", "cite_spans": [], "ref_spans": [], "section": "Introduction"}, {"text": "Floating-point arithmetic is the dominant approximation of real arithmetic that has mature hardware support. Although it enjoys the benefits of being able to represent a large spectrum of real numbers and high precision of arithmetic operations over small numbers, floating-point arithmetic, due to its complexity, can be too expensive in terms of speed and power consumption on certain platforms. These platforms are often deployed in embedded systems such as mobile phones, video game consoles, and digital controllers. Recently, the machine learning community revived the interest in fixed-point arithmetic since popular machine learning algorithms and models can be implemented using (even very low bit-width) fixed-points with little accuracy loss [11, 27, 37] . Therefore, fixed-point arithmetic has been a popular alternative to floating-point arithmetic on such platforms since it can be efficiently realized using integer arithmetic. There are several software implementations of fixed-point arithmetic in different programming languages [22, 28, 34] ; moreover, some programming languages, such as Ada and GNU C, have built-in fixed-point types.", "cite_spans": [{"start": 753, "end": 757, "text": "[11,", "ref_id": "BIBREF10"}, {"start": 758, "end": 761, "text": "27,", "ref_id": "BIBREF24"}, {"start": 762, "end": 765, "text": "37]", "ref_id": "BIBREF34"}, {"start": 1052, "end": 1055, "text": "28,", "ref_id": "BIBREF25"}, {"start": 1056, "end": 1059, "text": "34]", "ref_id": "BIBREF31"}], "ref_spans": [], "section": "Introduction"}, {"text": "While fixed-point arithmetic is less popular in mainstream applications than floating-point arithmetic, the systems employing the former are often safetycritical. For example, fixed-point arithmetic is often used in medical devices, cars, and robots. Therefore, there is a need for formal methods that can rigorously ensure the correctness of these systems. Although techniques that perform automated verification of fixed-point programs already exist [1, 3, 15] , all of them implement a custom dedicated decision procedure without formalizing the details of fixed-point arithmetic. As a result, it is hard to compare these techniques, or reuse the implemented decision procedures.", "cite_spans": [{"start": 452, "end": 455, "text": "[1,", "ref_id": "BIBREF0"}, {"start": 456, "end": 458, "text": "3,", "ref_id": "BIBREF2"}, {"start": 459, "end": 462, "text": "15]", "ref_id": "BIBREF14"}], "ref_spans": [], "section": "Introduction"}, {"text": "On the other hand, ever since the SMT theory of floating-point numbers was formalized [8, 44] in SMT-LIB [46] , there has been a flurry of research in developing novel and faster decision procedures for the theory [6, 7, 14, 29, 35, 50] . Meanwhile, the floating-point theory has also been used by a number of approaches that require rigorous reasoning about floating-point arithmetic [2, 36, 39, 41] . The published formalization of the theory enables fair comparison between the decision procedures, sharing of benchmarks, and easy integration of decision procedures within tools that need this functionality. In this paper, we propose and formalize an SMT theory of fixed-point arithmetic, in the spirit of the SMT theory of floating-point arithmetic, with the hope that it will lead to similar outcomes and advances.", "cite_spans": [{"start": 86, "end": 89, "text": "[8,", "ref_id": "BIBREF7"}, {"start": 90, "end": 93, "text": "44]", "ref_id": "BIBREF41"}, {"start": 105, "end": 109, "text": "[46]", "ref_id": "BIBREF43"}, {"start": 214, "end": 217, "text": "[6,", "ref_id": "BIBREF5"}, {"start": 218, "end": 220, "text": "7,", "ref_id": "BIBREF6"}, {"start": 221, "end": 224, "text": "14,", "ref_id": "BIBREF13"}, {"start": 225, "end": 228, "text": "29,", "ref_id": "BIBREF26"}, {"start": 229, "end": 232, "text": "35,", "ref_id": "BIBREF32"}, {"start": 233, "end": 236, "text": "50]", "ref_id": "BIBREF47"}, {"start": 385, "end": 388, "text": "[2,", "ref_id": "BIBREF1"}, {"start": 389, "end": 392, "text": "36,", "ref_id": "BIBREF33"}, {"start": 393, "end": 396, "text": "39,", "ref_id": "BIBREF36"}, {"start": 397, "end": 400, "text": "41]", "ref_id": "BIBREF38"}], "ref_spans": [], "section": "Introduction"}, {"text": "Contributions. We summarize our main contributions as follows:", "cite_spans": [], "ref_spans": [], "section": "Introduction"}, {"text": "-We present an intuitive and comprehensive syntax of fixed-point arithmetic (Sect. 3) that captures common use cases of fixed-point operations. -We provide formal semantics of the fixed-point theory based on rational arithmetic (Sect. 4). -We propose and implement two decision procedures for the fixed-point theory:", "cite_spans": [], "ref_spans": [], "section": "Introduction"}, {"text": "one that leverages the theory of fixed-size bit-vectors and the other the theory of real numbers (Sect. 5). -We evaluate the two decision procedures on a set of benchmarks using mature SMT solvers (Sect. 6), and perform a case study of verifying quantized neural networks that uses our theory of fixed-point arithmetic (Sect. 7).", "cite_spans": [], "ref_spans": [], "section": "Introduction"}, {"text": "Fixed-point arithmetic, like floating-point arithmetic, is used as an approximation for computations over the reals. Both fixed-point and floating-point numbers (excluding the special values) can be represented using rational numbers. However, unlike floating-point numbers, fixed-point numbers in a certain format maintain a fixed divisor, hence the name fixed-point. Consequently, fixed-point numbers have a reduced range of values. However, this format allows for custom precision systems to be implemented efficiently in software-fixed-point arithmetic operations can be implemented in a much smaller amount of integer arithmetic operations compared to their floating-point counterparts. For example, a fixed-point addition operation simply amounts to an integer addition instruction provided that wrap-around is the intended behavior when overflows occur. This feature gives rise to the popularity of fixed-point arithmetic on embedded systems where computing resources are fairly constrained. A fixed-point number is typically interpreted as a fraction whose numerator is an integer with fixed bit-width in its two's complement representation and denominator is a power of 2. Therefore, a fixed-point format is parameterized by two natural numbers-tb that defines the bit-width of the numerator and fb that defines the power of the denominator. A fixed-point number in this format can be treated as a bit-vector of length tb that is the two's complement representation of the numerator integer and has an implicit binary point between the fb + 1 th and fb th least significant bits. We focus on the binary format (as opposed to decimal, etc.) of fixed-point arithmetic since it is widely adopted in hardware and software implementations in practice. Moreover, depending on the intended usage, developers leverage both signed and unsigned fixed-point formats. The signed or unsigned format determines whether the bit pattern representing the fixed-point number should be interpreted as a signed or unsigned integer, respectively. Therefore, signed and unsigned fixed-point formats having the same tb and fb have different ranges (", "cite_spans": [], "ref_spans": [], "section": "Background"}, {"text": "] and [0, 2 tb \u22121 2 fb ]), respectively. Fixed-point addition (resp. subtraction) is typically implemented by adding (resp. subtracting) the two bit-vector operands (i.e., two's complements), amounting to a single operation. Because the denominators are the same between the two operands, we do not need to perform rounding. However, we still have to take care of potential overflows that occur when the result exceeds the allowed range of the chosen fixed-point format. Fixed-point libraries typically implement two methods to handle overflows: saturation and wrap-around. Saturation entails fixing overflowed results to either the minimal or maximal representable value. The advantage of this method is that it ensures that the final fixed-point result is the closest to the actual result not limited by finite precision. Wrap-around allows for the overflowing result to wrap according to two's complement arithmetic. The advantage of this method is that it is efficient and can be used to ensure the sum of a set of (signed) numbers has a correct final value despite potential overflows (if it falls within the supported range). Note that addition is commutative under both methods, but only addition using the wrap-around method is associative. The multiplication and division operations are more involved since they have to include the rounding step as well.", "cite_spans": [], "ref_spans": [], "section": "Background"}, {"text": "In this section, we describe the syntax of our proposed theory of fixed-point arithmetic. It is inspired by the syntax of the SMT theory of floating-points [8, 44] and the ISO/IEC TR 18037 standard [23].", "cite_spans": [{"start": 156, "end": 159, "text": "[8,", "ref_id": "BIBREF7"}, {"start": 160, "end": 163, "text": "44]", "ref_id": "BIBREF41"}], "ref_spans": [], "section": "Syntax"}, {"text": "Fixed-Points. We introduce the indexed SMT nullary sorts (_ SFXP tb fb) to represent signed fixed-point sorts, where tb is a natural number specifying the total bit-width of the scaled integer in its two's complement form and fb is a natural number specifying the number of fractional bits; tb is greater than or equal to fb. Similarly, we represent unsigned fixed-point sorts with (_ UFXP tb fb). Following the SMT-LIB notation, we define the following two functions for constructing fixed-points literals:", "cite_spans": [], "ref_spans": [], "section": "Syntax"}, {"text": "where (_ sfxp fb) (resp. (_ ufxp fb)) produces a function that takes a bit-vector (_ BitVec tb) and constructs a fixed-point (_ SFXP tb fb) (resp. (_ UFXP tb fb)).", "cite_spans": [], "ref_spans": [], "section": "Syntax"}, {"text": "Similarly to the theory of floating-point arithmetic, we also introduce the RoundingMode sort (abbreviated as RM) to represent the rounding mode, which controls the direction of rounding when an arithmetic result cannot be precisely represented by the specified fixed-point format. However, unlike the floating-point theory that specifies five different rounding modes, we only adopt two rounding mode constants, namely roundUp and roundDown, as they are common in practice.", "cite_spans": [], "ref_spans": [], "section": "Rounding Modes."}, {"text": "Overflow Modes. We introduce the nullary sort OverflowMode (abbreviated as OM) to capture the behaviors of fixed-point arithmetic when the result of an operation is beyond the representable range of the used fixed-point format. We adopt two constants, saturation and wrapAround, to represent the two common behaviors. The saturation mode rounds any out-of-bound results to the maximum or minimum values of the representable range, while the wrapAround mode wraps the results around similar to bit-vector addition.", "cite_spans": [], "ref_spans": [], "section": "Rounding Modes."}, {"text": "Comparisons. The following operators return a Boolean by comparing two fixedpoint numbers:", "cite_spans": [], "ref_spans": [], "section": "Rounding Modes."}, {"text": "Arithmetic. We support the following binary arithmetic operators over fixedpoint sorts parameterized by tb and fb:", "cite_spans": [], "ref_spans": [], "section": "Rounding Modes."}, {"text": "Note that we force the sorts of operands and return values to be the same. The addition and subtraction operations never introduce error into computation according to our semantics in Sect. 4. Hence, these operators do not take a rounding mode as input like multiplication and division.", "cite_spans": [], "ref_spans": [], "section": "Rounding Modes."}, {"text": "Conversions. We introduce two types of conversions between sorts. First, the conversions between different fixed-point sorts:", "cite_spans": [], "ref_spans": [], "section": "Rounding Modes."}, {"text": "Second, the conversions between the real and fixed-point sorts:", "cite_spans": [], "ref_spans": [], "section": "Rounding Modes."}, {"text": "In this section, we formalize the semantics of the fixed-point theory by treating fixed-points as rational numbers. We first define fixed-points as indexed subsets of rationals. Then, we introduce two functions, rounding and overflow, that are crucial for the formalization of the fixed-point arithmetic operations. Finally, we present the formal semantics of the arithmetic operations based on rational arithmetic and the two aforementioned functions.", "cite_spans": [], "ref_spans": [], "section": "Semantics"}, {"text": "Let F fb = { n 2 fb | n \u2208 Z} be the infinite set of rationals that can be represented as fixed-points using fb fractional bits. We interpret a signed fixed-point sort (_ SFXP tb fb) as the finite subset", "cite_spans": [], "ref_spans": [], "section": "Semantics"}, {"text": ", where function bv2nat converts a bit-vector to its unsigned integer value. The rational value of its signed counterpart constructed using (sfxp bv fb) is bv2int(bv ) 2 fb , where function bv2int converts a bit-vector to its signed value. Since we treat fixed-point numbers as subsets of rational numbers, we interpret fixed-point comparison operators, such as =, fxp.le, fxp.leq, as simply their corresponding rational comparison relations, such as =, <, \u2264, respectively. To be able to formalize the semantics of arithmetic operations, we first introduce the round and overflow helper functions.", "cite_spans": [], "ref_spans": [], "section": "Semantics"}, {"text": "We interpret the rounding mode sort RoundingMode as the set rmode = {ru, rd }, where roundUp = ru and roundDown = rd . Let rnd F fb : rmode\u00d7R \u2192 F fb be a family of round functions parameterized by fb that map a rounding mode and real number to an element of F fb . Then, we define rnd F fb as", "cite_spans": [], "ref_spans": [], "section": "Semantics"}, {"text": "We interpret the overflow mode sort OverflowMode as the set omode = {sat, wrap}, where saturation = sat and wrapAround = wrap. Let ovf F : omode \u00d7 F fb \u2192 F be a family of overflow functions parameterized by F that map a rounding mode and element of F fb to an element of F; here, F is either S tb,fb or U tb,fb depending on whether we are using signed or unsigned fixed-point numbers, respectively. Then, we define ovf F as", "cite_spans": [], "ref_spans": [], "section": "Semantics"}, {"text": "Note that x \u00b7 2 fb , y \u00b7 2 fb \u2208 Z according to the definition of F, and also there is always exactly one y satisfying the constraint. Now that we introduced our helper round and overflow functions, it is easy to define the interpretation of fixed-point arithmetic operations:", "cite_spans": [], "ref_spans": [], "section": "Semantics"}, {"text": "Therefore, we do not need to round the results of the addition and subtraction operations. In the case of division by zero, we adopt the semantics of other SMT theories such as reals: (= x (sfxp.div om rm y 0)) and (= x (ufxp.div om rm y 0)) are satisfiable for every x, y \u2208 F, om \u2208 omode, rm \u2208 rmode. Furthermore, for every x, y \u2208 F, om \u2208 omode, rm \u2208 rmode, if (= x y) then (= (sfxp.div om rm x 0) (sfxp.div om rm y 0)) and (= (ufxp.div om rm x 0) (ufxp.div om rm y 0)).", "cite_spans": [], "ref_spans": [], "section": "Semantics"}, {"text": "Note that the order of applying the rnd and ovf functions to the results in real arithmetic matters. We choose rnd followed by ovf since it matches the typical real-world fixed-point semantics. Conversely, reversing the order can lead to out-of-bound results. For example, assume that we extend the signature of the ovf function to omode \u00d7 R \u2192 R while preserving its semantics as a modulo operation over 2 tb\u2212fb . Then, ovf U3,2 (wrap, 7.5) evaluates to 7.5 4 , and applying rnd F2 to it when the rounding mode is ru evaluates to 8 4 ; this is greater than the maximum number in U 3,2 , namely 7 4 . On the other hand, evaluating ovf U3,2 (wrap, rnd F2 (ru, 7.5)) produces 0, which is the expected result. We could apply the ovf function again to the out-of-bound results, but the current semantics achieves the same without this additional operation.", "cite_spans": [{"start": 530, "end": 533, "text": "8 4", "ref_id": null}, {"start": 594, "end": 597, "text": "7 4", "ref_id": null}], "ref_spans": [], "section": "Semantics"}, {"text": "Let cast F,F fb : omode \u00d7 rmode \u00d7 R \u2192 F be a family of cast functions parameterized by F and F fb that map an overflow mode, rounding mode, and real number to an element of F; as before, F is either S tb,fb or U tb,fb depending on whether we are using signed or unsigned fixed-point numbers, respectively. Then, we define cast F,F fb (om, rm, r) = ovf F (om, rnd F fb (rm, r)), and the interpretation of the conversions between reals and fixed-points as (_ to_sfxp tb fb) (om, rm, r) = cast S tb,fb ,F fb (om, rm, r) (_ to_ufxp tb fb) (om, rm, r) = cast U tb,fb ,F fb (om, rm, r) sfxp.to_real (r) = r ufxp.to_real (r) = r", "cite_spans": [], "ref_spans": [], "section": "Semantics"}, {"text": "In this section, we propose two decision procedures for the fixed-point theory by leveraging the theory of fixed-size bit-vectors in one and the theory of reals in the other.", "cite_spans": [], "ref_spans": [], "section": "Decision Procedures"}, {"text": "Bit-Vector Encoding. The decision procedure based on the theory of fixed-size bit-vectors is akin to the existing software implementations of fixed-point arithmetic that use machine integers. More specifically, a fixed-point sort parameterized by tb is encoded as a bit-vector sort of length tb. Therefore, the encoding of the constructors of fixed-point values simply amounts to identity functions. Similarly, the encoding of the comparison operators uses the corresponding bit-vector relations. For example, the comparison operator sfxp.lt is encoded as bvslt.", "cite_spans": [], "ref_spans": [], "section": "Decision Procedures"}, {"text": "The essence of the encoding of the arithmetic operations is expressing the numerator of the result, after rounding and overflow handling, using bit-vector arithmetic. We leverage the following two observations in our encoding. First, rounding a real value v to the value in the set F fb amounts to rounding v \u00b72 fb to an integer following the same rounding mode. This observation explains why rounding is not necessary for the linear arithmetic operations. Second, we can encode the wrap-around of the rounded result as simply extracting tb bits from the encoded result thanks to the wrap-around nature of the two's complement SMT representation. We model the behavior of division-by-zero using uninterpreted functions of the form (RoundingMode OverflowMode (_ BitVec tb) (_ BitVec tb)), with one such function for each fixed-point sort appearing in the query. The result of division-by-zero is then the result of applying this function to the numerator, conditioned on the denominator being equal to zero. This ensures that all divisions-by-zero with equal numerators produce equal results when the overflow and rounding modes are also equal.", "cite_spans": [], "ref_spans": [], "section": "Decision Procedures"}, {"text": "Real Encoding. The decision procedure based on the theory of reals closely mimics the semantics defined in Sect. 4. We encode all fixed-point sorts as the real sort, while we represent fixed-point values as rational numbers. Therefore, we can simply encode fixed-point comparisons as real relations. For example, both sfxp.lt and ufxp.lt are translated into < relation. We rely on the first observation above to implement the rounding function rnd fb using an SMT real-tointeger conversion. We implement the overflow function ovf tb,f b using the SMT remainder function. Note that the encodings of both functions involve non-linear real functions, such as the real-to-int conversion. Finally, we model division as the rounded, overflow-corrected result of the real theory's division operation. Since the real theory's semantics ensures that equivalent division operations produce equivalent results, this suffices to capture the fixed-point division-by-zero semantics.", "cite_spans": [], "ref_spans": [], "section": "Decision Procedures"}, {"text": "Implementation. We implemented the two decision procedures within the pySMT framework [25] : the two encodings are rewriting classes of pySMT. We made our implementations publicly available. 1 We also implemented a random generator of queries in our fixed-point theory, and used it to perform thorough differential testing of our decision procedures.", "cite_spans": [{"start": 86, "end": 90, "text": "[25]", "ref_id": "BIBREF22"}, {"start": 191, "end": 192, "text": "1", "ref_id": "BIBREF0"}], "ref_spans": [], "section": "Decision Procedures"}, {"text": "We generated the benchmarks we use to evaluate the two encodings described in Sect. 5 by translating the SMT-COMP non-incremental QF_FP benchmarks [45] . The translation accepts benchmarks that contain only basic arithmetic operations defined in both theories. Moreover, we exclude all the benchmarks in the wintersteiger folder because they are mostly simple regressions to test the correctness of an implementation of the floating-point theory. In the end, we manage to translate 218 QF_FP benchmarks in total.", "cite_spans": [{"start": 147, "end": 151, "text": "[45]", "ref_id": "BIBREF42"}], "ref_spans": [], "section": "Experiments"}, {"text": "We translate each QF_FP benchmark into 4 benchmarks in the fixed-point theory, which differ in the configurations of rounding and overflow modes. We denote a configuration as a (rounding mode, overflow mode) tuple. Note that changing a benchmark configuration alters the semantics of its arithmetic operations, which might affect its satisfiability. Our translation replaces floating-point sorts with fixed-point sorts that have the same total bit-widths; the number of fractional bits is half of the bit-width. This establishes a mapping from singleprecision floats to Q16.16 fixed-points implemented by popular software libraries such as libfixmath [34] . It translates arithmetic operations into their corresponding fixed-point counterparts using the chosen configuration uniformly across a benchmark. The translation also replaces floating-point comparison operations with their fixed-point counterparts. Finally, we convert floating-point constants by treating them as reals and performing real-to-fixed-point casts. We made our fixed-point benchmarks publicly available. 2 The SMT solvers that we use in the evaluation are Boolector [9] (version 3.1.0), CVC4 [4] (version 1.7), MathSAT [13] (version 5.5.1), Yices2 [19] (version 2.6.1), and Z3 [17] (version 4.8.4) for the decision procedure based on the theory of bit-vectors. For the evaluation of the decision procedure based on the theory of reals, we use CVC4, MathSAT, Yices2, and Z3. We ran the experiments on a machine with four Intel E7-4830 sockets, for a total of 32 physical cores, and 512GB of RAM, running Ubuntu 18.04. Each benchmark was limited to 1200 s of wall time and 8GB of memory, and no run of any benchmark exceeded the memory limit. We set processor affinity for each solver instance in order to reduce variability due to cache effects. Table 1 shows the results of running the SMT solvers on each configuration with both encodings (bit-vector and real). We do not observe any inconsistencies in terms of satisfiability reported among all the solvers and between both encodings. The performance of the solvers on the bit-vector encoding is typically better than on the real encoding since it leads to fewer timeouts and crashes. Moreover, all the solvers demonstrate similar performance for the bit-vector encoding Table 1 . The results of running SMT solvers on the four different configurations of the benchmarks using both encodings. Boolector and MathSAT are denoted by Btor and MSAT, respectively. Column \"All\" indicates the number of benchmarks for which any solver answered sat or unsat; benchmarks for which no solver gave an answer are counted as unknown. Table 2 . Comparison of the number of benchmarks (considering all configurations) solved by a solver but not solved by another solver. Each row shows the number of benchmarks solved by the row's solver but not solved by the column's solver. We mark the bit-vector (resp. real) encoding with B (resp. R). across all the configurations, whereas they generally produce more timeouts for the real encoding when the overflow mode is wrap-around. We believe that this can be attributed to the usage of nonlinear operations (e.g., real to int casts) in the handling of wrap-around behaviors. This hypothesis could also explain the observation that the bit-vector encoding generally outperform the real encoding when the overflow mode is wrap-around since wrap-around comes at almost no cost for the bit-vector encoding (see Sect. 5).", "cite_spans": [{"start": 651, "end": 655, "text": "[34]", "ref_id": "BIBREF31"}, {"start": 1077, "end": 1078, "text": "2", "ref_id": "BIBREF1"}, {"start": 1139, "end": 1142, "text": "[9]", "ref_id": "BIBREF8"}, {"start": 1165, "end": 1168, "text": "[4]", "ref_id": "BIBREF3"}, {"start": 1192, "end": 1196, "text": "[13]", "ref_id": "BIBREF12"}, {"start": 1221, "end": 1225, "text": "[19]", "ref_id": "BIBREF18"}, {"start": 1250, "end": 1254, "text": "[17]", "ref_id": "BIBREF16"}], "ref_spans": [{"start": 1818, "end": 1825, "text": "Table 1", "ref_id": null}, {"start": 2296, "end": 2303, "text": "Table 1", "ref_id": null}, {"start": 2646, "end": 2653, "text": "Table 2", "ref_id": null}], "section": "Experiments"}, {"text": "Column \"All\" captures the performance of the solvers when treated as one portfolio solver. This improves the overall performance since the number of solved benchmarks increases, indicating that each solver has different strengths and weaknesses. Table 2 further analyzes this behavior, and we identify two reasons for it when we consider unique instances solved by each individual solver. First, when the overflow mode is saturation, Yices2 is the only solver to solve unique instances for both encodings. Second, when the overflow mode is wrap-around, the uniquely solved instances come from solvers used on the bit-vector encoding, except one that comes from Yices2 on the real encoding. These results provide further evidence that the saturation configurations are somewhat easier to solve with reals, and that wrap-around is easier with bit-vectors. Figure 1 uses quantile plots [5] to visualize our experimental results in terms of runtimes. A quantile plot shows the minimum runtime on y-axis within which each of the x-axis benchmarks is solved. Some characteristics of a quantile plot are helpful in analyzing the runtimes. First, the rightmost x coordinate is the number of benchmarks that a solver returns meaningful results for (i.e., sat or unsat). Second, the uppermost y coordinate is the maximum runtime of all the benchmarks. Third, the area under a line approximates the total runtime.", "cite_spans": [{"start": 883, "end": 886, "text": "[5]", "ref_id": "BIBREF4"}], "ref_spans": [{"start": 246, "end": 253, "text": "Table 2", "ref_id": null}, {"start": 854, "end": 862, "text": "Figure 1", "ref_id": "FIGREF0"}], "section": "Experiments"}, {"text": "Although the semantics of the benchmarks vary for each configuration, we can observe that the shapes of the bit-vector encoding curves are similar, while those of the real encoding differ based on the chosen overflow mode. More precisely, solvers tend to solve benchmarks faster when their overflow mode is saturation as opposed to wrap-around. We observe the same behavior in Table 1 , and it is likely due to the fact that we introduce nonlinear operations to handle wraparound behaviors when using the real encoding.", "cite_spans": [], "ref_spans": [{"start": 377, "end": 384, "text": "Table 1", "ref_id": null}], "section": "Experiments"}, {"text": "Neural networks have experienced a significant increase in popularity in the past decade. Such networks that are realized by a composition of non-linear layers are able to efficiently solve a large variety of previously unsolved learning tasks. However, neural networks are often viewed as black-boxes, whose causal structure cannot be interpreted easily by humans [40] . This property makes them unfit for applications where guaranteed correctness has a high priority. Advances in formal methods, in particular SMT solvers, leveraging the piece-wise linear structure of neural networks [20, 31, 47] , have made it possible to verify certain formal properties of neural networks of reasonable size. While these successes provide an essential step towards applying neural networks to safety-critical tasks, these methods leave out one crucial aspect-neural networks are usually quantized before being deployed to production systems [30] .", "cite_spans": [{"start": 365, "end": 369, "text": "[40]", "ref_id": "BIBREF37"}, {"start": 587, "end": 591, "text": "[20,", "ref_id": "BIBREF19"}, {"start": 592, "end": 595, "text": "31,", "ref_id": "BIBREF28"}, {"start": 596, "end": 599, "text": "47]", "ref_id": "BIBREF44"}, {"start": 931, "end": 935, "text": "[30]", "ref_id": "BIBREF27"}], "ref_spans": [], "section": "Case Study: Verification of Quantized Neural Networks"}, {"text": "Quantization converts a network that operates over 32-bit floating-point semantics into a fewer-bit fixed-point representation. This process serves two goals: compressing the memory requirement and increasing the computational efficiency of running the network. Quantization introduces additional non-linear rounding operations to the semantics of a neural network. Recently, Giacobbe et al. [26] have shown that, in practice, this can lead to situations where a network that satisfies formal specifications might violate them after the quantization step. Therefore, when checking formal properties of quantized neural networks, we need to take their fixed-point semantics into account.", "cite_spans": [{"start": 392, "end": 396, "text": "[26]", "ref_id": "BIBREF23"}], "ref_spans": [], "section": "Case Study: Verification of Quantized Neural Networks"}, {"text": "We derive a set of example fixed-point problem instances based on two machine learning tasks to demonstrate the capabilities of our fixed-point SMT theory on realistic problems. For all tasks, we train multi-layer perceptron modules [43] with ReLU-7 activation function [32] using quantization-aware training [30] . This way we avoid that quantization results in a considerable loss of accuracy. To encode a neural network into an SMT formula, we rely on the Giacobbe et al.'s [26] approach for encoding the summations and activation functions. We quantize all neural networks using the signed fixed-point format with 8 bits total and 4 fractional bits. We are using the bit-vector encoding decision procedure in combination with the Boolector SMT solver.", "cite_spans": [{"start": 233, "end": 237, "text": "[43]", "ref_id": "BIBREF40"}, {"start": 270, "end": 274, "text": "[32]", "ref_id": "BIBREF29"}, {"start": 309, "end": 313, "text": "[30]", "ref_id": "BIBREF27"}, {"start": 477, "end": 481, "text": "[26]", "ref_id": "BIBREF23"}], "ref_spans": [], "section": "Case Study: Verification of Quantized Neural Networks"}, {"text": "In our first task, we train a neural network controller using the cart-pole environment of OpenAI's \"gym\" reinforcement learning suite. In this task, an agent has to balance a pole mounted on a movable cart in an upright position. The cart provides four observation variables x,\u1e8b,\u03d5,\u03c6 to the controller, where x is the position of the cart and \u03d5 the angle of the pole. The controller then steers the cart by discrete actions (move left or right). Our neural network agent, composed of three layers (4, 8, 1) , solves the task by achieving an average score of the maximal 500 points. We analyze what our black-box agent has learned by using our decision procedure. In particular, we are interested in how much our agent relies on the input variable x compared to \u03d5 for making a decision. Moreover, we are interested in which parts of the input space the agent's decision is constant. We assume the dynamics of the cart is bounded, i.e., \u22120.3 \u2264\u1e8b \u2264 0.3, \u22120.02 \u2264\u03c6 \u2264 0.2, and partition the input space of the remaining two input variables into a grid of 64 tiles. We then check for each tile whether there exists a situation when the network would output a certain action (left, right) by invoking our decision procedure. Figure 2 shows that the agent primarily relies on the input variable \u03d5 for making a decision. If the angle of the pole exceeds a certain threshold, the network is guaranteed to make the vehicle move left; on the other hand, if the angle of the pole is below a different threshold, the network moves the vehicle right. Interestingly, this pattern is non-symmetric, despite the task being entirely symmetric. For our second task, we checked the fairness specification proposed by Giacobbe et al. [26] to evaluate the maximum influence of a single input variable on the decision of a network. We train a neural network on student data to predict the score on a math exam. Among other personal features, the gender of a person is fed into the network for making a decision. As the training data contains a bias in the form of a higher average math score for male participants, the network might learn to underestimate the math score of female students. We employ our decision procedure to compute the maximum influence of the gender of a person to its predicted math score. First, we create encodings of the same network (3 layers of size 6, 16, and 1) that share all input variables except the gender as a single fixed-point theory formula. We then constrain the predicted scores such that the one network outputs a score that is c higher than the score predicted by the other network. Finally, we perform binary search by iteratively invoking our decision procedure to find out at what bias c the formula changes from satisfiable to unsatisfiable. Table 3 shows that there exists a hypothetical person whose predicted math score would drop by 11.5 points out of 100 if the person is female instead of male. Moreover, our results also show that for no person the math score would change by 11.75 points if the gender would be changed.", "cite_spans": [{"start": 497, "end": 500, "text": "(4,", "ref_id": "BIBREF3"}, {"start": 501, "end": 503, "text": "8,", "ref_id": "BIBREF7"}, {"start": 504, "end": 506, "text": "1)", "ref_id": "BIBREF0"}, {"start": 1710, "end": 1714, "text": "[26]", "ref_id": "BIBREF23"}], "ref_spans": [{"start": 1216, "end": 1224, "text": "Figure 2", "ref_id": "FIGREF1"}, {"start": 2762, "end": 2769, "text": "Table 3", "ref_id": "TABREF1"}], "section": "Cart-Pole Controller"}, {"text": "Ruemmer and Wahl [44] and Brain et al. [8] propose and formalize the SMT theory of the IEEE-754 floating-point arithmetic. We were inspired by these papers both in terms of the syntax and the formalization of the semantics of our theory. There are several decision procedures for the floating-point theory. In particular, Brain et al. [7] present an efficient and verified reduction from the theory of floating-points to the theory of bit-vectors, while Leeser et al. [33] solve the floating-point theory by reducing it to the theory of reals. These two decision procedures are much more complicated than the ones we describe in Sect. 5 due to the more complex nature of floating-point arithmetic.", "cite_spans": [{"start": 17, "end": 21, "text": "[44]", "ref_id": "BIBREF41"}, {"start": 39, "end": 42, "text": "[8]", "ref_id": "BIBREF7"}, {"start": 335, "end": 338, "text": "[7]", "ref_id": "BIBREF6"}, {"start": 468, "end": 472, "text": "[33]", "ref_id": "BIBREF30"}], "ref_spans": [], "section": "Related Work"}, {"text": "In the rest of this section, we introduce related approaches that perform verification or synthesis of programs that use fixed-point arithmetic. Many of these approaches, and in particular the SMT-based ones, could benefit from our unified formalization of the theory of fixed-point arithmetic. For example, they could leverage our decision procedures instead of developing their own from scratch. Moreover, having the same format allows for easier sharing of benchmarks and comparison of results among different decision procedures.", "cite_spans": [], "ref_spans": [], "section": "Related Work"}, {"text": "Eldib et al. [21] present an SMT-based method for synthesizing optimized fixed-point computations that satisfy certain acceptance criteria, which they rigorously verify using an SMT solver. Similarly to our paper, their approach encodes fixed-point arithmetic operations using the theory of bit-vectors. Anta et al. [3] tackle the verification problem of the stability of fixed-point controller implementations. They provide a formalization of fixed-point arithmetic semantics using bit-vectors, but unlike our paper they do not formalize rounding and overflows. Furthermore, they encode the fixed-point arithmetic using unbounded integer arithmetic, arguing that unbounded integer arithmetic is a better fit for their symbolic analysis. We could also reduce our bit-vector encoding to unbounded integers following a similar scheme as Anta et al.", "cite_spans": [{"start": 13, "end": 17, "text": "[21]", "ref_id": "BIBREF20"}, {"start": 316, "end": 319, "text": "[3]", "ref_id": "BIBREF2"}], "ref_spans": [], "section": "Related Work"}, {"text": "Bounded model checker ESMBC [15, 24] supports fixed-point arithmetic and has been used to verify safety properties of fixed-point digital controllers [1] . Like us, it also employs a bit-vector encoding. However, it is unclear exactly which fixed-point operations are supported. UppSAT [50] is an approximating SMT solver that leverages fixed-point arithmetic as an approximation theory to floating-point arithmetic. Like the aforementioned work, UppSAT also encodes fixed-point arithmetic using the theory of bit-vectors. Its encoding ignores rounding modes, but adds special values such as infinities.", "cite_spans": [{"start": 28, "end": 32, "text": "[15,", "ref_id": "BIBREF14"}, {"start": 33, "end": 36, "text": "24]", "ref_id": "BIBREF21"}, {"start": 150, "end": 153, "text": "[1]", "ref_id": "BIBREF0"}, {"start": 286, "end": 290, "text": "[50]", "ref_id": "BIBREF47"}], "ref_spans": [], "section": "Related Work"}, {"text": "In addition to SMT-based verification, another important aspect of reasoning about fixed-point computations is error bound analysis, which is often used for the synthesis of fixed-point implementations. Majumdar et al. [38] synthesize Pareto optimal fixed-point implementations of control software in regard to performance criteria and error bounds. They reduce error bound computation to an optimization problem solved by mixed-integer linear programming. Darulova et al. [16] compile real-valued expressions to fixed-point expressions, and rigorously show that the generated expressions satisfy given error bounds. The error bound analysis is static and based on affine arithmetic. Volkova et al. [48, 49] propose an approach to determine the fixed-point format that ensures the absence of overflows and minimizes errors; their error analysis is based on Worst-Case Peak Gain measure. TAFFO [12] is an LLVM plugin that performs precision tuning by replacing floating-point computations with their fixed-point counterparts. The quality of precision tuning is determined by a static error propagation analysis.", "cite_spans": [{"start": 219, "end": 223, "text": "[38]", "ref_id": "BIBREF35"}, {"start": 473, "end": 477, "text": "[16]", "ref_id": "BIBREF15"}, {"start": 699, "end": 703, "text": "[48,", "ref_id": "BIBREF45"}, {"start": 704, "end": 707, "text": "49]", "ref_id": "BIBREF46"}, {"start": 893, "end": 897, "text": "[12]", "ref_id": "BIBREF11"}], "ref_spans": [], "section": "Related Work"}, {"text": "In this paper, we propose an SMT theory of fixed-point arithmetic to facilitate SMT-based software verification of fixed-point programs and systems by promoting the development of decision procedures for the proposed theory. We introduce the syntax of fixed-point sorts and operations in the SMT-LIB format similar to that of the SMT floating-point theory. Then, we formalize the semantics of the fixed-point theory, including rounding and overflow, based on the exact rational arithmetic. We develop two decision procedures for the fixedpoint theory that encode it into the theory of bit-vectors and reals. Finally, we study the performance of our prototype decision procedures on a set of benchmarks, and perform a realistic case study by proving properties of quantized neural networks.", "cite_spans": [], "ref_spans": [], "section": "Conclusions and Future Work"}, {"text": "As future work, we plan to add more complex operations to the fixed-point theory, such as conversions to/from floating-points and the remainder operation. Moreover, we would like to apply the fixed-point theory to verify existing software implementations of fixed-point arithmetic in different programming languages. We plan to do this by integrating it into the Boogie intermediate verification language [18] and the SMACK verification toolchain [10, 42] .", "cite_spans": [{"start": 405, "end": 409, "text": "[18]", "ref_id": "BIBREF17"}, {"start": 447, "end": 451, "text": "[10,", "ref_id": "BIBREF9"}, {"start": 452, "end": 455, "text": "42]", "ref_id": "BIBREF39"}], "ref_spans": [], "section": "Conclusions and Future Work"}], "bib_entries": {"BIBREF0": {"ref_id": "b0", "title": "Bounded model checking for fixed-point digital filters", "authors": [{"first": "R", "middle": ["B"], "last": "Abreu", "suffix": ""}, {"first": "M", "middle": ["Y R"], "last": "Gadelha", "suffix": ""}, {"first": "L", "middle": ["C"], "last": "Cordeiro", "suffix": ""}, {"first": "E", "middle": ["B"], "last": "De Lima Filho", "suffix": ""}, {"first": "W", "middle": ["S"], "last": "Da Silva", "suffix": ""}], "year": 2016, "venue": "J. Braz. Comput. Soc", "volume": "22", "issn": "1", "pages": "", "other_ids": {"DOI": ["10.1186/s13173-016-0041-8"]}}, "BIBREF1": {"ref_id": "b1", "title": "Towards verified, constant-time floating point operations", "authors": [{"first": "M", "middle": [], "last": "Andrysco", "suffix": ""}, {"first": "A", "middle": [], "last": "N\u00f6tzli", "suffix": ""}, {"first": "F", "middle": [], "last": "Brown", "suffix": ""}, {"first": "R", "middle": [], "last": "Jhala", "suffix": ""}, {"first": "D", "middle": [], "last": "Stefan", "suffix": ""}], "year": 2018, "venue": "Proceedings of the ACM Conference on Computer and Communications Security (CCS)", "volume": "", "issn": "", "pages": "1369--1382", "other_ids": {"DOI": ["10.1145/3243734.3243766"]}}, "BIBREF2": {"ref_id": "b2", "title": "Automatic verification of control system implementations", "authors": [{"first": "A", "middle": [], "last": "Anta", "suffix": ""}, {"first": "R", "middle": [], "last": "Majumdar", "suffix": ""}, {"first": "I", "middle": [], "last": "Saha", "suffix": ""}, {"first": "P", "middle": [], "last": "Tabuada", "suffix": ""}], "year": 2010, "venue": "Proceedings of the International Conference on Embedded Software (EMSOFT)", "volume": "", "issn": "", "pages": "9--18", "other_ids": {"DOI": ["10.1145/1879021.1879024"]}}, "BIBREF3": {"ref_id": "b3", "title": "CAV 2011", "authors": [{"first": "C", "middle": [], "last": "Barrett", "suffix": ""}], "year": 2011, "venue": "", "volume": "6806", "issn": "", "pages": "171--177", "other_ids": {"DOI": ["10.1007/978-3-642-22110-1_14"]}}, "BIBREF4": {"ref_id": "b4", "title": "Software verification and verifiable witnesses", "authors": [{"first": "D", "middle": [], "last": "Beyer", "suffix": ""}], "year": 2015, "venue": "TACAS 2015", "volume": "9035", "issn": "", "pages": "401--416", "other_ids": {"DOI": ["10.1007/978-3-662-46681-0_31"]}}, "BIBREF5": {"ref_id": "b5", "title": "Deciding floatingpoint logic with abstract conflict driven clause learning", "authors": [{"first": "M", "middle": [], "last": "Brain", "suffix": ""}, {"first": "V", "middle": [], "last": "Silva", "suffix": ""}, {"first": "A", "middle": [], "last": "Griggio", "suffix": ""}, {"first": "L", "middle": [], "last": "Haller", "suffix": ""}, {"first": "D", "middle": [], "last": "Kroening", "suffix": ""}], "year": 2013, "venue": "Formal Methods Syst. Des", "volume": "45", "issn": "2", "pages": "213--245", "other_ids": {"DOI": ["10.1007/s10703-013-0203-7"]}}, "BIBREF6": {"ref_id": "b6", "title": "Building better bit-blasting for floating-point problems", "authors": [{"first": "M", "middle": [], "last": "Brain", "suffix": ""}, {"first": "F", "middle": [], "last": "Schanda", "suffix": ""}, {"first": "Y", "middle": [], "last": "Sun", "suffix": ""}], "year": 2019, "venue": "TACAS 2019", "volume": "11427", "issn": "", "pages": "79--98", "other_ids": {"DOI": ["10.1007/978-3-030-17462-0_5"]}}, "BIBREF7": {"ref_id": "b7", "title": "An automatable formal semantics for IEEE-754 floating-point arithmetic", "authors": [{"first": "M", "middle": [], "last": "Brain", "suffix": ""}, {"first": "C", "middle": [], "last": "Tinelli", "suffix": ""}, {"first": "P", "middle": [], "last": "R\u00fcmmer", "suffix": ""}, {"first": "T", "middle": [], "last": "Wahl", "suffix": ""}], "year": 2015, "venue": "Proceedings of the IEEE International Symposium on Computer Arithmetic (ARITH)", "volume": "", "issn": "", "pages": "160--167", "other_ids": {"DOI": ["10.1109/ARITH.2015.26"]}}, "BIBREF8": {"ref_id": "b8", "title": "Boolector: an efficient SMT solver for bit-vectors and arrays", "authors": [{"first": "R", "middle": [], "last": "Brummayer", "suffix": ""}, {"first": "A", "middle": [], "last": "Biere", "suffix": ""}], "year": 2009, "venue": "TACAS 2009", "volume": "5505", "issn": "", "pages": "174--177", "other_ids": {"DOI": ["10.1007/978-3-642-00768-2_16"]}}, "BIBREF9": {"ref_id": "b9", "title": "SMACK software verification toolchain", "authors": [{"first": "M", "middle": [], "last": "Carter", "suffix": ""}, {"first": "S", "middle": [], "last": "He", "suffix": ""}, {"first": "J", "middle": [], "last": "Whitaker", "suffix": ""}, {"first": "Z", "middle": [], "last": "Rakamari\u0107", "suffix": ""}, {"first": "M", "middle": [], "last": "Emmi", "suffix": ""}], "year": 2016, "venue": "Proceedings of the International Conference on Software Engineering (ICSE)", "volume": "", "issn": "", "pages": "589--592", "other_ids": {"DOI": ["10.1145/2889160.2889163"]}}, "BIBREF10": {"ref_id": "b10", "title": "Learning in practice: reasoning about quantization", "authors": [{"first": "A", "middle": [], "last": "Cherkaev", "suffix": ""}, {"first": "W", "middle": [], "last": "Tai", "suffix": ""}, {"first": "J", "middle": ["M"], "last": "Phillips", "suffix": ""}, {"first": "V", "middle": [], "last": "Srikumar", "suffix": ""}], "year": 2019, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF11": {"ref_id": "b11", "title": "TAFFO: tuning assistant for floating to fixed point optimization", "authors": [{"first": "S", "middle": [], "last": "Cherubin", "suffix": ""}, {"first": "D", "middle": [], "last": "Cattaneo", "suffix": ""}, {"first": "M", "middle": [], "last": "Chiari", "suffix": ""}, {"first": "A", "middle": ["D"], "last": "Bello", "suffix": ""}, {"first": "G", "middle": [], "last": "Agosta", "suffix": ""}], "year": 2020, "venue": "Embed. Syst. Lett", "volume": "12", "issn": "1", "pages": "5--8", "other_ids": {"DOI": ["10.1109/LES.2019.2913774"]}}, "BIBREF12": {"ref_id": "b12", "title": "The MathSAT5 SMT solver", "authors": [{"first": "A", "middle": [], "last": "Cimatti", "suffix": ""}, {"first": "A", "middle": [], "last": "Griggio", "suffix": ""}, {"first": "B", "middle": ["J"], "last": "Schaafsma", "suffix": ""}, {"first": "R", "middle": [], "last": "Sebastiani", "suffix": ""}], "year": 2013, "venue": "TACAS 2013", "volume": "7795", "issn": "", "pages": "93--107", "other_ids": {"DOI": ["10.1007/978-3-642-36742-7_7"]}}, "BIBREF13": {"ref_id": "b13", "title": "A three-tier strategy for reasoning about floating-point numbers in SMT", "authors": [{"first": "S", "middle": [], "last": "Conchon", "suffix": ""}, {"first": "M", "middle": [], "last": "Iguernlala", "suffix": ""}, {"first": "K", "middle": [], "last": "Ji", "suffix": ""}, {"first": "G", "middle": [], "last": "Melquiond", "suffix": ""}, {"first": "C", "middle": [], "last": "Fumex", "suffix": ""}], "year": 2017, "venue": "CAV 2017", "volume": "10427", "issn": "", "pages": "419--435", "other_ids": {"DOI": ["10.1007/978-3-319-63390-9_22"]}}, "BIBREF14": {"ref_id": "b14", "title": "SMT-based bounded model checking for embedded ANSI-C software", "authors": [{"first": "L", "middle": [], "last": "Cordeiro", "suffix": ""}, {"first": "B", "middle": [], "last": "Fischer", "suffix": ""}, {"first": "J", "middle": [], "last": "Marques-Silva", "suffix": ""}], "year": 2009, "venue": "Proceedings of the International Conference on Automated Software Engineering (ASE)", "volume": "", "issn": "", "pages": "137--148", "other_ids": {"DOI": ["10.1109/ASE.2009.63"]}}, "BIBREF15": {"ref_id": "b15", "title": "Synthesis of fixed-point programs", "authors": [{"first": "E", "middle": [], "last": "Darulova", "suffix": ""}, {"first": "V", "middle": [], "last": "Kuncak", "suffix": ""}, {"first": "R", "middle": [], "last": "Majumdar", "suffix": ""}, {"first": "I", "middle": [], "last": "Saha", "suffix": ""}], "year": 2013, "venue": "Proceedings of the International Conference on Embedded Software (EMSOFT)", "volume": "", "issn": "", "pages": "", "other_ids": {"DOI": ["10.1109/EMSOFT.2013.6658600"]}}, "BIBREF16": {"ref_id": "b16", "title": "Z3: an efficient SMT solver", "authors": [{"first": "L", "middle": [], "last": "De Moura", "suffix": ""}, {"first": "N", "middle": [], "last": "Bj\u00f8rner", "suffix": ""}], "year": 2008, "venue": "TACAS 2008", "volume": "4963", "issn": "", "pages": "337--340", "other_ids": {"DOI": ["10.1007/978-3-540-78800-3_24"]}}, "BIBREF17": {"ref_id": "b17", "title": "BoogiePL: a typed procedural language for checking object-oriented programs", "authors": [{"first": "R", "middle": [], "last": "Deline", "suffix": ""}, {"first": "K", "middle": ["R M"], "last": "Leino", "suffix": ""}], "year": 2005, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF18": {"ref_id": "b18", "title": "Yices 2.2", "authors": [{"first": "B", "middle": [], "last": "Dutertre", "suffix": ""}], "year": 2014, "venue": "CAV 2014", "volume": "8559", "issn": "", "pages": "737--744", "other_ids": {"DOI": ["10.1007/978-3-319-08867-9_49"]}}, "BIBREF19": {"ref_id": "b19", "title": "Formal verification of piece-wise linear feed-forward neural networks", "authors": [{"first": "R", "middle": [], "last": "Ehlers", "suffix": ""}], "year": 2017, "venue": "ATVA 2017", "volume": "10482", "issn": "", "pages": "269--286", "other_ids": {"DOI": ["10.1007/978-3-319-68167-2_19"]}}, "BIBREF20": {"ref_id": "b20", "title": "An SMT based method for optimizing arithmetic computations in embedded software code", "authors": [{"first": "H", "middle": [], "last": "Eldib", "suffix": ""}, {"first": "C", "middle": [], "last": "Wang", "suffix": ""}], "year": 2008, "venue": "IEEE Trans. Comput. Aided Des. Integr. Circ. Syst", "volume": "33", "issn": "11", "pages": "1611--1622", "other_ids": {"DOI": ["10.1109/TCAD.2014.2341931"]}}, "BIBREF21": {"ref_id": "b21", "title": "ESBMC 5.0: an industrial-strength C model checker", "authors": [{"first": "M", "middle": ["R"], "last": "Gadelha", "suffix": ""}, {"first": "F", "middle": ["R"], "last": "Monteiro", "suffix": ""}, {"first": "J", "middle": [], "last": "Morse", "suffix": ""}, {"first": "L", "middle": ["C"], "last": "Cordeiro", "suffix": ""}, {"first": "B", "middle": [], "last": "Fischer", "suffix": ""}, {"first": "D", "middle": ["A"], "last": "Nicole", "suffix": ""}], "year": null, "venue": "Proceedings of the International Conference on Automated Software Engineering (ASE)", "volume": "", "issn": "", "pages": "888--891", "other_ids": {"DOI": ["10.1145/3238147.3240481"]}}, "BIBREF22": {"ref_id": "b22", "title": "PySMT: a solver-agnostic library for fast prototyping of SMT-based algorithms", "authors": [{"first": "M", "middle": [], "last": "Gario", "suffix": ""}, {"first": "A", "middle": [], "last": "Micheli", "suffix": ""}], "year": 2015, "venue": "International Workshop on Satisfiability Modulo Theories (SMT)", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF23": {"ref_id": "b23", "title": "How many bits does it take to quantize your neural network?", "authors": [{"first": "M", "middle": [], "last": "Giacobbe", "suffix": ""}, {"first": "T", "middle": ["A"], "last": "Henzinger", "suffix": ""}, {"first": "M", "middle": [], "last": "Lechner", "suffix": ""}], "year": 2020, "venue": "TACAS 2020", "volume": "12079", "issn": "", "pages": "79--97", "other_ids": {"DOI": ["10.1007/978-3-030-45237-7_5"]}}, "BIBREF24": {"ref_id": "b24", "title": "Deep learning with limited numerical precision", "authors": [{"first": "S", "middle": [], "last": "Gupta", "suffix": ""}, {"first": "A", "middle": [], "last": "Agrawal", "suffix": ""}, {"first": "K", "middle": [], "last": "Gopalakrishnan", "suffix": ""}, {"first": "P", "middle": [], "last": "Narayanan", "suffix": ""}], "year": 2015, "venue": "Proceedings of the International Conference on Machine Learning (ICML)", "volume": "", "issn": "", "pages": "1737--1746", "other_ids": {}}, "BIBREF25": {"ref_id": "b25", "title": "Signed 15.16 precision fixed-point arithmetic", "authors": [], "year": null, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF26": {"ref_id": "b26", "title": "Stochastic local search for solving floatingpoint constraints", "authors": [{"first": "S", "middle": [], "last": "He", "suffix": ""}, {"first": "M", "middle": [], "last": "Baranowski", "suffix": ""}, {"first": "Z", "middle": [], "last": "Rakamari\u0107", "suffix": ""}], "year": 2019, "venue": "NSV 2019", "volume": "11652", "issn": "", "pages": "76--84", "other_ids": {"DOI": ["10.1007/978-3-030-28423-7_5"]}}, "BIBREF27": {"ref_id": "b27", "title": "Quantization and training of neural networks for efficient integerarithmetic-only inference", "authors": [{"first": "B", "middle": [], "last": "Jacob", "suffix": ""}], "year": 2018, "venue": "Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR)", "volume": "", "issn": "", "pages": "2704--2713", "other_ids": {"DOI": ["10.1109/CVPR.2018.00286"]}}, "BIBREF28": {"ref_id": "b28", "title": "Reluplex: an efficient SMT solver for verifying deep neural networks", "authors": [{"first": "G", "middle": [], "last": "Katz", "suffix": ""}, {"first": "C", "middle": [], "last": "Barrett", "suffix": ""}, {"first": "D", "middle": ["L"], "last": "Dill", "suffix": ""}, {"first": "K", "middle": [], "last": "Julian", "suffix": ""}, {"first": "M", "middle": ["J"], "last": "Kochenderfer", "suffix": ""}], "year": 2017, "venue": "CAV 2017", "volume": "10426", "issn": "", "pages": "97--117", "other_ids": {"DOI": ["10.1007/978-3-319-63387-9_5"]}}, "BIBREF29": {"ref_id": "b29", "title": "Convolutional deep belief networks on CIFAR-10", "authors": [{"first": "A", "middle": [], "last": "Krizhevsky", "suffix": ""}], "year": 2010, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF30": {"ref_id": "b30", "title": "Make it real: effective floating-point reasoning via exact arithmetic", "authors": [{"first": "M", "middle": [], "last": "Leeser", "suffix": ""}, {"first": "S", "middle": [], "last": "Mukherjee", "suffix": ""}, {"first": "J", "middle": [], "last": "Ramachandran", "suffix": ""}, {"first": "T", "middle": [], "last": "Wahl", "suffix": ""}], "year": 2014, "venue": "Proceedings of the Design, Automation and Test in Europe Conference and Exhibition (DATE)", "volume": "", "issn": "", "pages": "1--4", "other_ids": {"DOI": ["10.7873/DATE.2014.130"]}}, "BIBREF31": {"ref_id": "b31", "title": "Cross platform fixed point maths library", "authors": [], "year": null, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF32": {"ref_id": "b32", "title": "Just fuzz it: solving floatingpoint constraints using coverage-guided fuzzing", "authors": [{"first": "D", "middle": [], "last": "Liew", "suffix": ""}, {"first": "C", "middle": [], "last": "Cadar", "suffix": ""}, {"first": "A", "middle": ["F"], "last": "Donaldson", "suffix": ""}, {"first": "J", "middle": ["R"], "last": "Stinnett", "suffix": ""}], "year": 2019, "venue": "Proceedings of the ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering (ESEC/FSE)", "volume": "", "issn": "", "pages": "521--532", "other_ids": {"DOI": ["10.1145/3338906.3338921"]}}, "BIBREF33": {"ref_id": "b33", "title": "Floating-point symbolic execution: a case study in n-version programming", "authors": [{"first": "D", "middle": [], "last": "Liew", "suffix": ""}, {"first": "D", "middle": [], "last": "Schemmel", "suffix": ""}, {"first": "C", "middle": [], "last": "Cadar", "suffix": ""}, {"first": "A", "middle": ["F"], "last": "Donaldson", "suffix": ""}, {"first": "R", "middle": [], "last": "Z\u00e4hl", "suffix": ""}, {"first": "K", "middle": [], "last": "Wehrle", "suffix": ""}], "year": 2017, "venue": "Proceedings of the International Conference on Automated Software Engineering (ASE)", "volume": "", "issn": "", "pages": "601--612", "other_ids": {"DOI": ["10.1109/ASE.2017.8115670"]}}, "BIBREF34": {"ref_id": "b34", "title": "Fixed point quantization of deep convolutional networks", "authors": [{"first": "D", "middle": ["D"], "last": "Lin", "suffix": ""}, {"first": "S", "middle": ["S"], "last": "Talathi", "suffix": ""}, {"first": "V", "middle": ["S"], "last": "Annapureddy", "suffix": ""}], "year": 2016, "venue": "Proceedings of the International Conference on Machine Learning (ICML)", "volume": "", "issn": "", "pages": "2849--2858", "other_ids": {}}, "BIBREF35": {"ref_id": "b35", "title": "Synthesis of minimal-error control software", "authors": [{"first": "R", "middle": [], "last": "Majumdar", "suffix": ""}, {"first": "I", "middle": [], "last": "Saha", "suffix": ""}, {"first": "M", "middle": [], "last": "Zamani", "suffix": ""}], "year": 2012, "venue": "Proceedings of the International Conference on Embedded Software (EMSOFT)", "volume": "", "issn": "", "pages": "123--132", "other_ids": {"DOI": ["10.1145/2380356.2380380"]}}, "BIBREF36": {"ref_id": "b36", "title": "Alive-FP: automated verification of floating point based peephole optimizations in LLVM", "authors": [{"first": "D", "middle": [], "last": "Menendez", "suffix": ""}, {"first": "S", "middle": [], "last": "Nagarakatte", "suffix": ""}, {"first": "A", "middle": [], "last": "Gupta", "suffix": ""}], "year": 2016, "venue": "SAS 2016", "volume": "9837", "issn": "", "pages": "317--337", "other_ids": {"DOI": ["10.1007/978-3-662-53413-7_16"]}}, "BIBREF37": {"ref_id": "b37", "title": "The building blocks of interpretability. Distill", "authors": [{"first": "C", "middle": [], "last": "Olah", "suffix": ""}], "year": 2018, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {"DOI": ["10.23915/distill.00010"]}}, "BIBREF38": {"ref_id": "b38", "title": "Verifying (in-)stability in floating-point programs by increasing precision, using SMT solving", "authors": [{"first": "G", "middle": [], "last": "Paganelli", "suffix": ""}, {"first": "W", "middle": [], "last": "Ahrendt", "suffix": ""}], "year": 2013, "venue": "Proceedings of the International Symposium on Symbolic and Numeric Algorithms for Scientific Computing (SYNASC)", "volume": "", "issn": "", "pages": "209--216", "other_ids": {"DOI": ["10.1109/SYNASC.2013.35"]}}, "BIBREF39": {"ref_id": "b39", "title": "SMACK: decoupling source language details from verifier implementations", "authors": [{"first": "Z", "middle": [], "last": "Rakamari\u0107", "suffix": ""}, {"first": "M", "middle": [], "last": "Emmi", "suffix": ""}], "year": 2014, "venue": "CAV 2014", "volume": "8559", "issn": "", "pages": "106--113", "other_ids": {"DOI": ["10.1007/978-3-319-08867-9_7"]}}, "BIBREF40": {"ref_id": "b40", "title": "Learning representations by backpropagating errors", "authors": [{"first": "D", "middle": ["E"], "last": "Rumelhart", "suffix": ""}, {"first": "G", "middle": ["E"], "last": "Hinton", "suffix": ""}, {"first": "R", "middle": ["J"], "last": "Williams", "suffix": ""}], "year": 1986, "venue": "Nature", "volume": "323", "issn": "6088", "pages": "533--536", "other_ids": {"DOI": ["10.1038/323533a0"]}}, "BIBREF41": {"ref_id": "b41", "title": "An SMT-LIB theory of binary floating-point arithmetic", "authors": [{"first": "P", "middle": [], "last": "R\u00fcmmer", "suffix": ""}, {"first": "T", "middle": [], "last": "Wahl", "suffix": ""}], "year": 2010, "venue": "Informal Proceedings of the International Workshop on Satisfiability Modulo Theories (SMT)", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF42": {"ref_id": "b42", "title": "SMT-LIB benchmarks in the QF_FP theory", "authors": [], "year": null, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF43": {"ref_id": "b43", "title": "SMT-LIB: the satisfiability modulo theories library", "authors": [], "year": null, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF44": {"ref_id": "b44", "title": "Evaluating robustness of neural networks with mixed integer programming", "authors": [{"first": "V", "middle": [], "last": "Tjeng", "suffix": ""}, {"first": "K", "middle": ["Y"], "last": "Xiao", "suffix": ""}, {"first": "R", "middle": [], "last": "Tedrake", "suffix": ""}], "year": 2019, "venue": "International Conference on Learning Representations (ICLR)", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF45": {"ref_id": "b45", "title": "Determining fixed-point formats for a digital filter implementation using the worst-case peak gain measure", "authors": [{"first": "A", "middle": [], "last": "Volkova", "suffix": ""}, {"first": "T", "middle": [], "last": "Hilaire", "suffix": ""}, {"first": "C", "middle": [], "last": "Lauter", "suffix": ""}], "year": 2015, "venue": "Proceedings of the Asilomar Conference on Signals, Systems and Computers", "volume": "", "issn": "", "pages": "737--741", "other_ids": {"DOI": ["10.1109/ACSSC.2015.7421231"]}}, "BIBREF46": {"ref_id": "b46", "title": "Arithmetic approaches for rigorous design of reliable fixed-point LTI filters", "authors": [{"first": "A", "middle": [], "last": "Volkova", "suffix": ""}, {"first": "T", "middle": [], "last": "Hilaire", "suffix": ""}, {"first": "C", "middle": ["Q"], "last": "Lauter", "suffix": ""}], "year": 2020, "venue": "IEEE Trans. Comput", "volume": "69", "issn": "4", "pages": "489--504", "other_ids": {"DOI": ["10.1109/TC.2019.2950658"]}}, "BIBREF47": {"ref_id": "b47", "title": "Exploring approximations for floating-point arithmetic using UppSAT", "authors": [{"first": "A", "middle": [], "last": "Zelji\u0107", "suffix": ""}, {"first": "P", "middle": [], "last": "Backeman", "suffix": ""}, {"first": "C", "middle": ["M"], "last": "Wintersteiger", "suffix": ""}, {"first": "P", "middle": [], "last": "R\u00fcmmer", "suffix": ""}], "year": 2018, "venue": "IJCAR 2018", "volume": "10900", "issn": "", "pages": "246--262", "other_ids": {"DOI": ["10.1007/978-3-319-94205-6_17"]}}}, "ref_entries": {"FIGREF0": {"text": "Quantile plots of our experimental results.", "latex": null, "type": "figure"}, "FIGREF1": {"text": "Satisfiability of specifications of our cart-pole controller.", "latex": null, "type": "figure"}, "TABREF1": {"text": "Satisfiability of specifications of our fairness example.", "latex": null, "type": "table"}}, "back_matter": []}