{"paper_id": "1a4a35c37c0ff3fd4ab673fe753e3a8780b0451f", "metadata": {"title": "Group Testing-Based Robust Algorithm for Diagnosis of COVID-19", "authors": [{"first": "Jin-Taek", "middle": [], "last": "Seong", "suffix": "", "affiliation": {"laboratory": "", "institution": "Mokpo National University", "location": {"postCode": "58554", "settlement": "Muan", "country": "Korea"}}, "email": "jtseong@mokpo.ac.kr"}]}, "abstract": [{"text": "At the time of writing, the COVID-19 infection is spreading rapidly. Currently, there is no vaccine or treatment, and researchers around the world are attempting to fight the infection. In this paper, we consider a diagnosis method for COVID-19, which is characterized by a very rapid rate of infection and is widespread. A possible method for avoiding severe infections is to stop the spread of the infection in advance by the prompt and accurate diagnosis of COVID-19. To this end, we exploit a group testing (GT) scheme, which is used to find a small set of confirmed cases out of a large population. For the accurate detection of false positives and negatives, we propose a robust algorithm (RA) based on the maximum a posteriori probability (MAP). The key idea of the proposed RA is to exploit iterative detection to propagate beliefs to neighbor nodes by exchanging marginal probabilities between input and output nodes. As a result, we show that our proposed RA provides the benefit of being robust against noise in the GT schemes. In addition, we demonstrate the performance of our proposal with a number of tests and successfully find a set of infected samples in both noiseless and noisy GT schemes with different COVID-19 incidence rates.", "cite_spans": [], "ref_spans": [], "section": "Abstract"}], "body_text": [{"text": "The ability to test for COVID- 19 , which has been characterized as a rapid contagion, is still insufficient to meet global health needs. COVID-19 transmission occurs between individuals, becoming a greater threat when using public facilities such as hospitals, religious facilities, schools, military units, and cruise ships. COVID-19 causes diseases such as pneumonia and acute respiratory distress syndrome (ARDS), which have low mortality rates but can lead to death. Clinical and physical symptoms may include shortness of breath, fever, cough, anosmia and gastrointestinal symptoms. COVID-19 is characterized by a low mortality rate but a very contagious nature. By April 20 in 2020, the number of confirmed COVID-19 cases was over 2.8 million and more than 148,000 people have died, as shown in Figure 1 . In the future, the number of infected people is expected to continue to increase across developing countries.", "cite_spans": [{"start": 31, "end": 33, "text": "19", "ref_id": "BIBREF17"}], "ref_spans": [{"start": 802, "end": 810, "text": "Figure 1", "ref_id": "FIGREF0"}], "section": "Introduction"}, {"text": "In the most recent papers published online [1] [2] [3] , group testing (GT) has been used to provide a quick and efficient solution to test the methods used to screen for COVID-19 infected people. The number of infected people is currently increasing by hundreds of thousands of people per day; thus, instead of individual testing, GT has shown to be economical and efficient, as it can reduce the number of required tests for COVID-19. GT is not a recently proposed approach; it was first proposed by Dorfman in 1943. [4] . To date, GT has been exploited in a wide range of applications in biology [5] , communication theory [6] , computer science [7] , and mathematics [8] . The use of fundamental GTs extends to error correction codes [9] , identifying available multiple access channels [10] , detecting malicious attacks in security networks [11] , testing the quality of products [12] , and many others. Next, a brief introduction to GT and an important testing method are discussed. GT began with a project to find all soldiers infected with syphilis by the U.S. health service during World War II [4] . Syphilis testing took blood cases from individual soldiers to test for syphilis infection. However, as the number of soldiers tested for syphilis was very large, the cost of the testing was high and a great deal of time was required to find a new test method [5] . Consequently, this motivated the development of the GT framework [4] .", "cite_spans": [{"start": 43, "end": 46, "text": "[1]", "ref_id": "BIBREF0"}, {"start": 47, "end": 50, "text": "[2]", "ref_id": "BIBREF1"}, {"start": 51, "end": 54, "text": "[3]", "ref_id": "BIBREF2"}, {"start": 519, "end": 522, "text": "[4]", "ref_id": "BIBREF3"}, {"start": 599, "end": 602, "text": "[5]", "ref_id": "BIBREF4"}, {"start": 626, "end": 629, "text": "[6]", "ref_id": "BIBREF5"}, {"start": 649, "end": 652, "text": "[7]", "ref_id": "BIBREF6"}, {"start": 671, "end": 674, "text": "[8]", "ref_id": "BIBREF7"}, {"start": 738, "end": 741, "text": "[9]", "ref_id": "BIBREF8"}, {"start": 791, "end": 795, "text": "[10]", "ref_id": "BIBREF9"}, {"start": 847, "end": 851, "text": "[11]", "ref_id": "BIBREF10"}, {"start": 886, "end": 890, "text": "[12]", "ref_id": "BIBREF11"}, {"start": 1105, "end": 1108, "text": "[4]", "ref_id": "BIBREF3"}, {"start": 1370, "end": 1373, "text": "[5]", "ref_id": "BIBREF4"}, {"start": 1441, "end": 1444, "text": "[4]", "ref_id": "BIBREF3"}], "ref_spans": [], "section": "Introduction"}, {"text": "In conventional GT, syphilis testing was performed using the following method. First, blood cases from several soldiers were mixed into a single pool to see whether they react to the syphilis test. When the result was positive, it meant that at least one soldier was infected with syphilis. On the other hand, in the case of a negative, it could be confirmed that all blood cases used for the syphilis testing were not infected with syphilis. Thus, it can be stated that most soldiers were not infected with syphilis, and only a handful of soldiers had syphilis. The main challenges of GT are as follows: first, determining the samples to be included in a pool; second, a detection algorithm must be used to find a set of infected people out of the large number of samples.", "cite_spans": [], "ref_spans": [], "section": "Introduction"}, {"text": "Briefly, the GT problem is clearly defined as follows: Let T be the number of tests required to find a set of confirmed cases when D people of the total population N are infected, and Let A be the group matrix with T rows and N columns. The role of the group matrix is to map the samples to be grouped in the test. For i \u2208 {1, 2, \u00b7 \u00b7 \u00b7 , T} and j \u2208 {1, 2, \u00b7 \u00b7 \u00b7 , N}, if the ith group includes the jth sample, the corresponding entry A ij of the group matrix A is represented as A ij = 1; otherwise, we express this as A ij = 0. In other words, when the entry of the group matrix is 1, GT is performed including the jth sample indicating the corresponding column. And we define the following terminologies and notations: bold upper and lower case letters denote matrices and column vectors, calligraphic letters denote sets, and Pr() is a probability.", "cite_spans": [], "ref_spans": [], "section": "Introduction"}, {"text": "Some recent works [1] [2] [3] have proposed GT methods or the rapid diagnosis of COVID-19. However, these works had the disadvantage of not being able to accurately pinpoint the outcomes of tests when there are false negatives and false positives. To overcome this inaccuracy, in this paper, we propose a robust algorithm (RA) (this term does not refer to a class of GT algorithms, it refers the meaning of robust decoding for GT problems with false negative and false positives) and demonstrate its performance against noise, even if errors occur in the output results. In order to detect the small number of confirmed cases of COVID-19, we exploit the detection algorithm using the maximum a posteriori probability (MAP), and we see that the proposed RA provides the benefit of being robust against noise. In addition, we show how many tests are needed, depending on the incidence rate of COVID-19. Furthermore, we demonstrate the robustness of our proposed algorithm to noise, as compared to other algorithms. This paper is organized as follows. In Section 2, we investigate the related works in detection algorithms used for GT. The challenges of GT are defined, in detail, in Section 3. The description of the detection algorithm proposed in this paper is provided in Section 4, and we show the simulation results and compare them with other results. Finally, in Section 5, we conclude by showing that we have obtained meaningful results and findings.", "cite_spans": [{"start": 18, "end": 21, "text": "[1]", "ref_id": "BIBREF0"}, {"start": 22, "end": 25, "text": "[2]", "ref_id": "BIBREF1"}, {"start": 26, "end": 29, "text": "[3]", "ref_id": "BIBREF2"}], "ref_spans": [], "section": "Introduction"}, {"text": "A number of detection algorithms for GT problems have been proposed since the detection algorithm was first introduced by Dorfman. This section aims to review some detection algorithms related to GT.", "cite_spans": [], "ref_spans": [], "section": "Related Works"}, {"text": "The detection algorithm to be reviewed first is the binary splitting algorithm [5] . This algorithm is generally called the optimal adaptive algorithm in GT. The binary splitting algorithm is used to find less than or equal to D infected cases in N cases, and is summarized, as follows, according to the size of N and D: In the initial step, in the case where N \u2264 2D \u2212 2, finding D confirmed cases is performed by individual testing. This means that individual testing is better than GT when there are many confirmed cases. Otherwise, set L = N \u2212 D + 1 and \u03b1 := log 2 L/D , respectively. In the next step, GT is performed by a set of cases with a size of 2 \u03b1 for every testing. Here, when the result of this GT is negative, all cases in this pool are determined to be normal. Then, the cases are reset with a size of N = N \u2212 2 \u03b1 and GT is performed in the same manner as in the first step. On the other hand, using a binary search, one infected sample and the other normal cases S are again set as follows:", "cite_spans": [{"start": 79, "end": 82, "text": "[5]", "ref_id": "BIBREF4"}], "ref_spans": [], "section": "Related Works"}, {"text": "The number of tests T for the generalized binary splitting (GBS) algorithm with respect to p > 0, N, and D is required to be T = D (\u03b1 + 2) + p \u2212 1 where, in the case of high N/D, T converges to D log 2 (N/D) [5] . In a recent paper [1] , the authors analyzed the performance of the binary splitting algorithm for COVID-19. Their results showed very close optimal results for the lower bounds obtained from information-theoretic bounds [1] .", "cite_spans": [{"start": 208, "end": 211, "text": "[5]", "ref_id": "BIBREF4"}, {"start": 232, "end": 235, "text": "[1]", "ref_id": "BIBREF0"}, {"start": 435, "end": 438, "text": "[1]", "ref_id": "BIBREF0"}], "ref_spans": [], "section": "Related Works"}, {"text": "Next, we review the COMP (Combinatorial Orthogonal Matching Pursuit) algorithm [14] . This algorithm is a class of non-adaptive GT algorithms. The COMP algorithm works as follows: first, each entry of the group matrix is assumed to follow an i.i.d. (independent and identically distributed) Bernoulli probability distribution with the probability 1/D for 1, and 1 \u2212 1/D for 0. The key idea of the COMP algorithm is to combine the columns of the group matrix corresponding to the individual cases participating in a pool. As with the conventional GT problems, the results are determined to be positive or negative depending on the existence of confirmed cases. The number of tests T for the COMP algorithm with any constant \u03b2 > 0 and where the average error probability is less than or equal to N \u2212\u03b2 is as follows:", "cite_spans": [{"start": 79, "end": 83, "text": "[14]", "ref_id": "BIBREF12"}], "ref_spans": [], "section": "Related Works"}, {"text": "Another algorithm, which is an extended version of the COMP algorithm, is called Definite Defectives (DD), which is used to remove false positive errors [15] . The performance of the DD algorithm improves on that of the COMP algorithm, where the detection method of the DD algorithm exploits useful attributes of the COMP algorithm. Note that the normal cases obtained from the COMP algorithm are surely detected without false negative error. Therefore, the DD algorithm only generates false negatives compared to the COMP algorithm.", "cite_spans": [{"start": 153, "end": 157, "text": "[15]", "ref_id": "BIBREF13"}], "ref_spans": [], "section": "Related Works"}, {"text": "The SCOMP (Sequential COMP) algorithm takes advantage of the fact that the DD algorithm does not cause errors until the last step [15] . All remaining cases are assumed to be normal. Let K be the set of cases detected to be infected; if the test contains at least one infected sample from the set K, a positive result is obtained. Note that it cannot be said that the set of confirmed cases detected by the DD algorithm includes all positive results. This means that test results that cannot be clearly identified have to contain one hidden defect sample. Simulation results using the SCOMP algorithm have shown results close to the optimal ones [15] . The other results of adaptive and noisy GT problems are presented in [16] [17] [18] .", "cite_spans": [{"start": 130, "end": 134, "text": "[15]", "ref_id": "BIBREF13"}, {"start": 646, "end": 650, "text": "[15]", "ref_id": "BIBREF13"}, {"start": 722, "end": 726, "text": "[16]", "ref_id": "BIBREF14"}, {"start": 727, "end": 731, "text": "[17]", "ref_id": "BIBREF15"}, {"start": 732, "end": 736, "text": "[18]", "ref_id": "BIBREF16"}], "ref_spans": [], "section": "Related Works"}, {"text": "In this section, we define the GT framework in detail. Let x = (x 1 , x 2 , \u00b7 \u00b7 \u00b7 , x N ) T be a binary input vector with size N. If the jth entry of x is infected, then we write x j = 1. Otherwise, x j = 0. Thus, all the entries of the input vector x are represented in binary form. In this paper, we assume that all the entries of x are independent and identically distributed (i.i.d.) following the Bernoulli distribution with the incidence rate for COVID-19,", "cite_spans": [], "ref_spans": [], "section": "Group Testing for Diagnosis of COVID-19"}, {"text": "where = D N denotes the incidence rate for COVID-19. Indeed, the incidence rate of COVID-19 is assumed to be a very small value.", "cite_spans": [], "ref_spans": [], "section": "Group Testing for Diagnosis of COVID-19"}, {"text": "The following describes the mathematical expression of GT in more detail. Each entry y i of the output result vector y is expressed as follows by using the input vector x and the group matrix A:", "cite_spans": [], "ref_spans": [], "section": "Group Testing for Diagnosis of COVID-19"}, {"text": "where y i is the output of the GT scheme, assuming that the ith additive noise z i is used. In the case where there is no noise, the output z i of the ith group is positive if there is at least one infected person in this group, which is indicated by y i = 1; otherwise, it is 0. We express the output of the GT, as a vector, as follows: y = (y 1 , y 2 , \u00b7 \u00b7 \u00b7 , y T ) T . The symbols \u2228, \u2227, and \u2295 denote the logical AND, OR, and XOR operations, respectively. Let z i be the additive noise in the ith group leading to false positives and negatives for the pure output result. It is assumed that the noise z i has the following probability distribution:", "cite_spans": [], "ref_spans": [], "section": "Group Testing for Diagnosis of COVID-19"}, {"text": "In fact, the probabilities of false positive and negative errors are not the same. For example, Knill et al. in [19] showed that the false positive and negative rates were up to 13% and 5% through actual experiments, respectively. In addition, the Z-channel model with only one error (e.g., false positive or negative) was considered in [18] . In this paper, we consider the symmetric noise model as shown in Equation (3). Then, we obtain all the entries of the output vector y of the GT scheme. This mathematical expression of the GT scheme takes advantage of the easy handling of the states of x, A, and y in our proposed algorithm. Figure 2 shows an example of the GT scheme with a 7 \u00d7 10 group matrix A, 10 samples x, additive noise z with one error, and 7 output results y. The white and black cells represent 0 and 1, respectively. The blue box represents the groups in which the infected samples participate, and the red box shows the results of the GT. In this example, the third and eighth samples participate in the third group test, and its output is 1. In addition, the outputs of the sixth and seventh tests are 1. The first pure output is 0; however, the additive noise is included and the corresponding output is flipped. One example of the simple group testing (GT) scheme with a 7 \u00d7 10 group matrix A, 10 samples x, additive noise z with one error, and seven output results y. The black and white boxes indicate 1 and 0, respectively. The third and eighth samples are included in the third group test, and its output is 1. The outputs of the sixth and seventh tests are 1. The first pure output is 0; however, the additive noise is included, and the corresponding output is flipped.", "cite_spans": [{"start": 112, "end": 116, "text": "[19]", "ref_id": "BIBREF17"}, {"start": 337, "end": 341, "text": "[18]", "ref_id": "BIBREF16"}], "ref_spans": [{"start": 635, "end": 643, "text": "Figure 2", "ref_id": "FIGREF1"}], "section": "Group Testing for Diagnosis of COVID-19"}, {"text": "In this section, we propose a robust algorithm (RA) for GT. This RA is based on the use of MAP. Note that the problem of finding the optimal MAP solution in GT is NP-hard. Although it is difficult to find the optimal solution for this argument, many researchers have tried to find sub-optimal approaches, which are close to the optimal one. Among them, the performance of the belief propagation algorithm, introduced by Mackey in [20] , showed results close to the Shannon limits in channel coding theory.", "cite_spans": [{"start": 430, "end": 434, "text": "[20]", "ref_id": "BIBREF18"}], "ref_spans": [], "section": "Proposed Robust Algorithm"}, {"text": "To handle our proposed RA, we assume the following: each person x j has a prior probability of having an infected and normal state (given by Equation (1)) under the GT scheme, assuming that the input vector, group matrix, and output result are mutually independent. The challenge for GT is finding the MAP combination of the estimatedx cases, given the observed output y. This is formulated asx = arg max Pr (x|y) = arg max", "cite_spans": [], "ref_spans": [], "section": "Proposed Robust Algorithm"}, {"text": "where the second equality comes from the independence assumption of the prior cases. Using Bayes' rule, the conditional probability Pr x j |y can be rewritten as", "cite_spans": [], "ref_spans": [], "section": "Proposed Robust Algorithm"}, {"text": "where the notation \u2211 x\\x j denotes a summation over all entries of x except the entry x j , the second proportional relation holds due to Bayes' rule and the last equality comes from the independent assumption. The aim of the proposed algorithm is to find the maximized marginal probability for each sample in Equation (5).", "cite_spans": [], "ref_spans": [], "section": "Proposed Robust Algorithm"}, {"text": "Next, we describe the key idea of the RA proposed in this paper. Before describing our algorithm, the graphical representation of one example of the GT scheme is represented in Figure 3 . There are 10 samples-x 1 through x 10 -and seven output results-y 1 through y 7 . As the first row of A, as shown in Figure 2 , is [0 1 0 0 0 1 0 0 0 1], there are three edges between the first output y 1 and three samples, x 2 , x 6 and x 10 , in Figure 3 . In the same way, other edges between the samples and the outputs can be drawn as shown in Figure 3 .", "cite_spans": [], "ref_spans": [{"start": 177, "end": 185, "text": "Figure 3", "ref_id": "FIGREF2"}, {"start": 305, "end": 313, "text": "Figure 2", "ref_id": "FIGREF1"}, {"start": 436, "end": 444, "text": "Figure 3", "ref_id": "FIGREF2"}, {"start": 537, "end": 545, "text": "Figure 3", "ref_id": "FIGREF2"}], "section": "Proposed Robust Algorithm"}, {"text": "x 9 x 10 y 7 Let L(i) = {x j : A ij = 1} be the set of samples participating in the ith group, and V (j) = {y i : A ij = 1} be the set of groups participating in the jth sample. We also use L(i) \\ {j} to denote the set L(i) excluded the jth sample, and V (j) \\ {i} to denote the set V (j) excluding the ith group. The RA proposed in this paper is mainly described as a process in which two marginal probabilities exchange information in each iteration. Note that we aim to find the maximum posterior probability for each sample, as in the last line of Equation (5) . In other words, the two conditional probabilities Pr(x j |y) and Pr(y i |x) are exchanged with each other to maximize the posterior probability. Let \u03be ji \u221d Pr(x j |y) be the downward message from sample x j to output y i , and \u03b4 ij \u221d Pr(y i |x) be the upward message from output y i to sample x j . Both messages are expressed as conditional probabilities. As mentioned in Equation (5), the two messages exchange their information with each other. The downward message \u03be ji is a function of the upward message \u03b4 ij , and vice versa. In the example of Figure 3 , the downward message \u03be x 10 y 1 is obtained from the two upward messages \u03b4 y 4 x 10 and \u03b4 y 7 x 10 . Conversely, the upward message \u03b4 y 1 x 10 is obtained from the two downward messages \u03be x 2 y 1 and \u03be x 6 y 1 . Now, the RA updates the messages \u03be ji and \u03b4 ij associated with each edge between the sample x j and the output y i . There are three steps to estimate each input sample: initialization, updating the messages \u03be ji and \u03b4 ij , and tentative decoding to check the constraint condition in Equation (2) . In the initialization step, we define the probability distribution of x in Equation (1), generate the group matrix A with a random design (i.e., low-density parity check (LDPC) codes, as in [20] ), and obtain the output result y from the given A and x. We aim to find an (unknown) input vector x by using (known) A and y. In addition, the initial downward message \u03be ji can be obtained from the prior probability distribution of Equation (1), assuming that the upward messages for 0 and 1 are equally distributed.", "cite_spans": [{"start": 561, "end": 564, "text": "(5)", "ref_id": "BIBREF4"}, {"start": 1634, "end": 1637, "text": "(2)", "ref_id": "BIBREF1"}, {"start": 1830, "end": 1834, "text": "[20]", "ref_id": "BIBREF18"}], "ref_spans": [{"start": 1118, "end": 1126, "text": "Figure 3", "ref_id": "FIGREF2"}], "section": "Proposed Robust Algorithm"}, {"text": "Next, we consider the upward message \u03b4 ij from output y i to sample x j . This message \u03b4 ij is obtained as follows:", "cite_spans": [], "ref_spans": [], "section": "Proposed Robust Algorithm"}, {"text": "where the constraint condition in Equation (2) is satisfied as N j=1 A ij \u2227 x j in the noiseless GT scheme. The summation of Equation (6) is used to collect all the associated downward probabilities that satisfy the constraint condition of Equation (2) . To update the upward message, the noisy probability Pr(z i ) is multiplied.", "cite_spans": [{"start": 249, "end": 252, "text": "(2)", "ref_id": "BIBREF1"}], "ref_spans": [], "section": "Proposed Robust Algorithm"}, {"text": "The downward message \u03be ji can be written as", "cite_spans": [], "ref_spans": [], "section": "Proposed Robust Algorithm"}, {"text": "where the variable \u03bb is used for normalization of the total probability. Let Pr(x j ) := Pr(x j |y) be the posterior probability for the sample x j . Finally, we determine a maximum probability for 0 or 1, as defined in Equation (5)", "cite_spans": [], "ref_spans": [], "section": "Proposed Robust Algorithm"}, {"text": "Using Equations (6) and (7), the proposed RA iteratively updates the messages \u03be ji and \u03b4 ij ; that is, while the algorithm is running, the posterior probability of each sample moves to converge in general. Even when the algorithm has been operated for the maximum number of iterations, the posterior probability may not converge. In this case, we assume that the sample is unreliable and perform individual testing instead of GT. In the final step, we perform individual testing by picking only unstable samples. Algorithm 1 describes our proposed RA for the detection of infected people in COVID-19.", "cite_spans": [], "ref_spans": [], "section": "Proposed Robust Algorithm"}, {"text": "Noisy probability: Pr(z i ) Group matrix A with T rows and N columns Output: The number of total tests: T (1) Initialization:", "cite_spans": [], "ref_spans": [], "section": "Input: Prior probability: Pr(x j )"}, {"text": "Set the incidence rate and the noisy probability \u03c3 Initial downward message \u03be ji \u2190 Pr(x j ) Set the maximum number of iterations for Maximum Iterations do", "cite_spans": [], "ref_spans": [], "section": "Input: Prior probability: Pr(x j )"}, {"text": "(2) Update the upward message \u03b4 ij :", "cite_spans": [], "ref_spans": [], "section": "Input: Prior probability: Pr(x j )"}, {"text": "x j \u2190 arg max x j \u2208{0,1} Pr(x j ) \u220f i\u2208V (j) \u03b4 ij end for j = 1 : N for x j do ifx j does not converge then Individual testing: T add \u2190 T add + 1 end end return T \u2190 T + T add Let T add be the number of samples that requires individual testing when the posterior probability does not converge. The total number of tests T for successfully finding infected people in COVID-19 is obtained as follows:", "cite_spans": [], "ref_spans": [], "section": "Input: Prior probability: Pr(x j )"}, {"text": "COVID-19 has a different incidence rate in each country. Figure 4 shows the number of infected people and number of tests in each country. The statistics shown in Figure 4 list the countries with the largest number of confirmed cases as of 12 April 2020. China, the first affected country, was excluded from Figure 4 , due to a lack of information on the number of tests. In addition, the average incidence rate for the most-affected countries, as shown in Figure 4 , is 12.89%, where the total number of confirmed cases is 1,743,883 and the total number of tests is 13,531,095. However, this incidence rate is reported to be lower than the actual case, as it is not recommended to actively test suspected patients. We consider South Korea as our simulation environment for the diagnosis of COVID-19; the reason for this is that it adopted the world's most objective and aggressive countermeasures to COVID-19. According to these results, the incidence rate of COVID-19 in South Korea is very low, at about 2%. We implemented a decoding algorithm for the GT scheme to find people with infected COVID-19 in noiseless (\u03c3 = 0) and both false positive and negative settings (\u03c3 = 0). Our proposed algorithm is based on the belief propagation algorithm of LDPC codes [20] in channel coding theory, which has shown performance close to the Shannon limit in information theory. The difference between Mackey's method [20] and the proposed RA is revealed in the operations. In the case of channel coding, the operation is performed over Finite Fields; however, GT uses Boolean operations such as AND, OR, and XOR. We evaluate the performance on RAs for the GT schemes. To this end, we set the simulation environment as follows: the defective samples are generated from the probability distribution in Equation (1) with different incidence rates , and the group matrix comes from LDPC codes with five constant weights in each column. Additionally, we set the number of maximum iterations as 20 for the RA. Throughout this paper, we consider N = 1000, assuming that the diagnosis of COVID-19 is carried out 1000 times simultaneously on one site. All the results for the number of tests are averaged from 100 experiments. The computational complexity of the RA based on the belief propagation algorithm in LDPC codes is O(N log N) in [20] . In addition, the relationship between the number of iterations and the performance on the belief propagation algorithm by using the analysis of density evolution under binary erasure and symmetry channels was presented in [21] . Intuitively, the greater the number of iterations of belief propagation decoding, the better the performance, but in order to achieve such a conclusion, it is necessary to have characteristics regarding the generation of a group matrix (e.g., stopping set) in [21] .", "cite_spans": [{"start": 1261, "end": 1265, "text": "[20]", "ref_id": "BIBREF18"}, {"start": 1409, "end": 1413, "text": "[20]", "ref_id": "BIBREF18"}, {"start": 2322, "end": 2326, "text": "[20]", "ref_id": "BIBREF18"}, {"start": 2551, "end": 2555, "text": "[21]", "ref_id": "BIBREF19"}, {"start": 2818, "end": 2822, "text": "[21]", "ref_id": "BIBREF19"}], "ref_spans": [{"start": 57, "end": 65, "text": "Figure 4", "ref_id": "FIGREF3"}, {"start": 163, "end": 171, "text": "Figure 4", "ref_id": "FIGREF3"}, {"start": 308, "end": 316, "text": "Figure 4", "ref_id": "FIGREF3"}, {"start": 457, "end": 465, "text": "Figure 4", "ref_id": "FIGREF3"}], "section": "Simulation Results"}, {"text": "Next, we evaluate the total number of tests T to successfully find infected people with different incidence rates in the noiseless GT scheme, as shown in Table 1 . First, the information-theoretic bound was obtained from [22] , which is exploited (by Fano's inequality [23] ) as a lower bound on the number of tests. Dorfman's method [4] , the DT method [1] , and the GBS method [5] were evaluated at N = 1000 and different incidence rates of (0.01, 0.02, 0.03, 0.04, 0.05, and 0.1), whose values were based on the statistics of the infected people for COVID-19 as of 12 April 2020, as shown in Figure 4 . All the statistical results for the number of tests T are shown in Table 1 . In the noiseless schemes, the best method for the detection of COVID-19 was the GBS algorithm [5] , the results of which were close to the information-theoretic bound. This method showed the best performance but has the inconvenience of not being able to test all samples simultaneously. In contrast, our proposed RA offers the advantage of GT all the samples at once using a predefined group matrix. In other words, in the GBS method, the current test is determined based on the results of the previous test, whereas the RA processes all tests at the same time, so it can be inspected in large quantities. Table 1 . Comparisons of the total number of tests T expressed as mean to successfully find infected people with different incidence rates in the noiseless GT scheme, where N = 1000 and \u03c3 = 0. The main advantage of our algorithm, compared to other algorithms, is that it is noise-resistant. Other detection methods shown in Table 1 have better performance in the noiseless GT. However, there exists noise in the GT framework, so it is limited when using these methods. We need a way to find infected samples even when the GT is noisy. To this end, we consider the noisy GT scheme with different noise values \u03c3, which is formulated by Equation (3) as the false positive and the false negative of the GT. Figure 5 shows how many total tests on the theoretical bounds [22] are required to successfully find different incidence rates in the noisy GT schemes with N = 1000, where \u03c3 = 0.01, 0.03, 0.05, and 0.1. As shown in Figure 5 , if the incidence rate is greater than 0.2 and the noise probability \u03c3 is greater than 0.05, individual testing is better that the GT scheme. In other words, the GT scheme in COVID-19 is suitable for the reduction of the number of tests when the incidence rate is less than 0.2, when assuming \u03c3 = 0.05. Table 2 shows the performance for the number of tests T of our proposed RA method for the noisy GT scheme, in which there are different incidence rates and noise probabilities \u03c3. Note that the interpretation of the false negative is more complicated because there may be contaminated input samples. In addition, test results including a large number of defective samples are unlikely to lead to false negatives, even with noise. In [24] , authors showed that it is easier to find false negatives than positive ones. It also led to improved results on the number of tests in the case of false negatives.", "cite_spans": [{"start": 221, "end": 225, "text": "[22]", "ref_id": "BIBREF20"}, {"start": 269, "end": 273, "text": "[23]", "ref_id": "BIBREF21"}, {"start": 334, "end": 337, "text": "[4]", "ref_id": "BIBREF3"}, {"start": 354, "end": 357, "text": "[1]", "ref_id": "BIBREF0"}, {"start": 379, "end": 382, "text": "[5]", "ref_id": "BIBREF4"}, {"start": 777, "end": 780, "text": "[5]", "ref_id": "BIBREF4"}, {"start": 2055, "end": 2059, "text": "[22]", "ref_id": "BIBREF20"}, {"start": 2953, "end": 2957, "text": "[24]", "ref_id": "BIBREF22"}], "ref_spans": [{"start": 154, "end": 161, "text": "Table 1", "ref_id": null}, {"start": 595, "end": 603, "text": "Figure 4", "ref_id": "FIGREF3"}, {"start": 673, "end": 680, "text": "Table 1", "ref_id": null}, {"start": 1290, "end": 1297, "text": "Table 1", "ref_id": null}, {"start": 1614, "end": 1621, "text": "Table 1", "ref_id": null}, {"start": 1993, "end": 2001, "text": "Figure 5", "ref_id": "FIGREF4"}, {"start": 2208, "end": 2216, "text": "Figure 5", "ref_id": "FIGREF4"}, {"start": 2521, "end": 2528, "text": "Table 2", "ref_id": "TABREF1"}], "section": "Simulation Results"}, {"text": "The reason for this robustness against noise is as follows: first, the RA updates all the posterior probabilities of the unknown binary input vector at every iteration, where it comes from exchanging upward and downward messages with each other. It is used to find the uncorrupted value using the beliefs of neighboring nodes even if the test result changes due to false negative or positive errors. As the number of iterations of the algorithm increases, the posterior probability gradually converges once there is cycle-free in the bipartite graph of the GT scheme with the low noise. Note that generating a group matrix with cycle-free is difficult in the large length. In our proposed RA, as the noise increases, the belief propagation does not work, so it falls into a region where errors cannot be corrected. For more details of effect of noise for belief propagation algorithms that are robust to noise, please refer to Lav's paper in [25] . ", "cite_spans": [{"start": 942, "end": 946, "text": "[25]", "ref_id": "BIBREF23"}], "ref_spans": [], "section": "Incidence"}, {"text": "In this paper, we considered a diagnosis method for COVID-19, which has been characterized by a very rapid rate of infection and is widespread. A possible method for avoiding severe infections is to stop the spread of the infection in advance by the prompt and accurate diagnosis of COVID-19.", "cite_spans": [], "ref_spans": [], "section": "Conclusions"}, {"text": "To this end, we exploit a group testing (GT) scheme, which is used to find a small set of confirmed cases out of a large population. To this end, results using GT as a diagnostic method for COVID-19 were presented. For the detection of false positives and negatives, we proposed an RA based on the MAP. The core idea of RA is that it exploits iterative detection to propagate beliefs to neighbor nodes by exchanging marginal probabilities between input and output nodes. As a result, we demonstrated that the our proposed RA provides the benefit of being robust in the GT schemes against noise when false positive and false negative outputs occur. In addition, through a number of tests, we showed the ability of our proposed method to successfully find a set of infected people in noiseless and noisy GT schemes with different incidence rates of COVID-19.", "cite_spans": [], "ref_spans": [], "section": "Conclusions"}], "bib_entries": {"BIBREF0": {"ref_id": "b0", "title": "Analysis and Applications of Non-Adaptive and Adaptive Group Testing Methods for COVID-19", "authors": [{"first": "C", "middle": [], "last": "Mentus", "suffix": ""}, {"first": "M", "middle": [], "last": "Romeo", "suffix": ""}, {"first": "C", "middle": [], "last": "Dipaola", "suffix": ""}], "year": null, "venue": "", "volume": "2020", "issn": "", "pages": "", "other_ids": {"DOI": ["10.1101/2020.04.05.20050245"]}}, "BIBREF1": {"ref_id": "b1", "title": "Evaluation of Group Testing for SARS-CoV-2 RNA. medRxiv 2020", "authors": [{"first": "N", "middle": [], "last": "Sinnott-Armstrong", "suffix": ""}, {"first": "D", "middle": ["L"], "last": "Klein", "suffix": ""}, {"first": "B", "middle": [], "last": "Hickey", "suffix": ""}], "year": null, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {"DOI": ["10.1101/2020.03.27.20043968"]}}, "BIBREF2": {"ref_id": "b2", "title": "Group testing against Covid-19", "authors": [{"first": "C", "middle": [], "last": "Gollier", "suffix": ""}, {"first": "O", "middle": [], "last": "Gossner", "suffix": ""}], "year": 2020, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF3": {"ref_id": "b3", "title": "The Detection of Defective Members of Large Populations", "authors": [{"first": "R", "middle": [], "last": "Dorfman", "suffix": ""}], "year": 1943, "venue": "Ann. Math. Stat", "volume": "14", "issn": "", "pages": "436--440", "other_ids": {"DOI": ["10.1214/aoms/1177731363"]}}, "BIBREF4": {"ref_id": "b4", "title": "Pooling Designs and Nonadaptive Group Testing: Important Tools for DNA Sequencing", "authors": [{"first": "D.-Z", "middle": [], "last": "Du", "suffix": ""}, {"first": "F.-K", "middle": [], "last": "Hwang", "suffix": ""}], "year": 2006, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF5": {"ref_id": "b5", "title": "Superimposed codes for the multiaccess binary adder channel", "authors": [{"first": "P", "middle": ["Z"], "last": "Fan", "suffix": ""}, {"first": "M", "middle": [], "last": "Darnell", "suffix": ""}, {"first": "B", "middle": [], "last": "Honary", "suffix": ""}], "year": 1995, "venue": "IEEE Trans. Inf. Theory", "volume": "41", "issn": "", "pages": "1178--1182", "other_ids": {"DOI": ["10.1109/18.391266"]}}, "BIBREF6": {"ref_id": "b6", "title": "Robust uncertainty principles: exact signal reconstruction from highly incomplete frequency information", "authors": [{"first": "E", "middle": [], "last": "Candes", "suffix": ""}, {"first": "J", "middle": [], "last": "Romberg", "suffix": ""}, {"first": "T", "middle": [], "last": "Tao", "suffix": ""}], "year": 2006, "venue": "IEEE Trans. Inf. Theory", "volume": "52", "issn": "", "pages": "489--509", "other_ids": {"DOI": ["10.1109/TIT.2005.862083"]}}, "BIBREF7": {"ref_id": "b7", "title": "Bounds and constructions for key distribution schemes", "authors": [{"first": "Y", "middle": [], "last": "Desmedt", "suffix": ""}, {"first": "N", "middle": [], "last": "Duif", "suffix": ""}, {"first": "V", "middle": ["H"], "last": "Tilborg", "suffix": ""}, {"first": "H", "middle": [], "last": "Wang", "suffix": ""}], "year": 2009, "venue": "Adv. Math. Commun", "volume": "3", "issn": "", "pages": "273--293", "other_ids": {"DOI": ["10.3934/amc.2009.3.273"]}}, "BIBREF8": {"ref_id": "b8", "title": "Designs and Their Codes", "authors": [{"first": "E", "middle": ["F"], "last": "Assmus", "suffix": ""}, {"first": "", "middle": [], "last": "Jr", "suffix": ""}, {"first": "J", "middle": ["D"], "last": "Key", "suffix": ""}], "year": 1992, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF9": {"ref_id": "b9", "title": "Forward collision resolution-A technique for random multiple-access to the adder channel", "authors": [{"first": "I", "middle": [], "last": "Bar-David", "suffix": ""}, {"first": "E", "middle": [], "last": "Plotnik", "suffix": ""}, {"first": "R", "middle": [], "last": "Rom", "suffix": ""}], "year": 1993, "venue": "IEEE Trans. Inf. Theory", "volume": "39", "issn": "", "pages": "1671--1675", "other_ids": {"DOI": ["10.1109/18.259654"]}}, "BIBREF10": {"ref_id": "b10", "title": "Efficient probabilistic group testing based on traitor tracing", "authors": [{"first": "T", "middle": [], "last": "Laarhoven", "suffix": ""}], "year": 2013, "venue": "Proceedings of the 51st Annual Allerton Conference on Communication, Control, and Computing", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF11": {"ref_id": "b11", "title": "Incomplete identification models for group-testable items", "authors": [{"first": "S", "middle": ["K"], "last": "Bar-Lev", "suffix": ""}, {"first": "A", "middle": [], "last": "Boneh", "suffix": ""}, {"first": "D", "middle": [], "last": "Perry", "suffix": ""}], "year": 1990, "venue": "Nav. Res. Logist", "volume": "37", "issn": "", "pages": "647--659", "other_ids": {"DOI": ["10.1002/1520-6750(199010)37:5<647::AID-NAV3220370505>3.0.CO;2-6"]}}, "BIBREF12": {"ref_id": "b12", "title": "Non-adaptive probabilistic group testing with noisy measurements: Near-optimal bounds with efficient algorithms", "authors": [{"first": "C", "middle": ["L"], "last": "Chan", "suffix": ""}, {"first": "P", "middle": ["H"], "last": "Che", "suffix": ""}, {"first": "S", "middle": [], "last": "Jaggi", "suffix": ""}, {"first": "V", "middle": [], "last": "Saligrama", "suffix": ""}], "year": 2011, "venue": "Proceedings of the 49th Annual Allerton Conference on Communication, Control, and Computing", "volume": "", "issn": "", "pages": "24--27", "other_ids": {}}, "BIBREF13": {"ref_id": "b13", "title": "Group Testing Algorithms: Bounds and Simulations", "authors": [{"first": "M", "middle": [], "last": "Aldridge", "suffix": ""}, {"first": "L", "middle": [], "last": "Baldassini", "suffix": ""}, {"first": "O", "middle": [], "last": "Johnson", "suffix": ""}], "year": 2014, "venue": "IEEE Trans. Inf. Theory", "volume": "60", "issn": "", "pages": "3671--3687", "other_ids": {"DOI": ["10.1109/TIT.2014.2314472"]}}, "BIBREF14": {"ref_id": "b14", "title": "The capacity of adaptive group testing", "authors": [{"first": "L", "middle": [], "last": "Baldassini", "suffix": ""}, {"first": "O", "middle": [], "last": "Johnson", "suffix": ""}, {"first": "M", "middle": [], "last": "Aldridge", "suffix": ""}], "year": 2013, "venue": "Proceedings of the 2013 IEEE International Symposium on Information Theory", "volume": "", "issn": "", "pages": "7--12", "other_ids": {}}, "BIBREF15": {"ref_id": "b15", "title": "Boolean Compressed Sensing and Noisy Group Testing", "authors": [{"first": "G", "middle": ["K"], "last": "Atia", "suffix": ""}, {"first": "V", "middle": [], "last": "Saligrama", "suffix": ""}], "year": 2012, "venue": "IEEE Trans. Inf. Theory", "volume": "58", "issn": "", "pages": "1880--1901", "other_ids": {"DOI": ["10.1109/TIT.2011.2178156"]}}, "BIBREF16": {"ref_id": "b16", "title": "Noisy Adaptive Group Testing: Bounds and Algorithms", "authors": [{"first": "J", "middle": [], "last": "Scarlett", "suffix": ""}], "year": 2019, "venue": "IEEE Trans. Inf. Theory", "volume": "65", "issn": "", "pages": "3646--3661", "other_ids": {"DOI": ["10.1109/TIT.2018.2883604"]}}, "BIBREF17": {"ref_id": "b17", "title": "Interpretation of Pooling Experiments Using the Markov Chain Monte Carlo Method", "authors": [{"first": "E", "middle": [], "last": "Knill", "suffix": ""}, {"first": "A", "middle": [], "last": "Schliep", "suffix": ""}, {"first": "D", "middle": ["C"], "last": "Torney", "suffix": ""}], "year": 1996, "venue": "J. Comput. Biol", "volume": "3", "issn": "", "pages": "395--406", "other_ids": {"DOI": ["10.1089/cmb.1996.3.395"]}}, "BIBREF18": {"ref_id": "b18", "title": "Good Error-Correcting Codes based on Very Sparse Matrices", "authors": [{"first": "D", "middle": ["J"], "last": "Mackey", "suffix": ""}], "year": 1999, "venue": "IEEE Trans. Inf. Theory", "volume": "45", "issn": "", "pages": "399--431", "other_ids": {"DOI": ["10.1109/18.748992"]}}, "BIBREF19": {"ref_id": "b19", "title": "Modern Coding Theory", "authors": [{"first": "T", "middle": [], "last": "Tom Richardson", "suffix": ""}, {"first": "R", "middle": [], "last": "Urbanke", "suffix": ""}], "year": 2008, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF20": {"ref_id": "b20", "title": "Density of Pooling Matrices vs. Sparsity of Signal of Group Testing Frameworks", "authors": [{"first": "J.-T", "middle": [], "last": "Seong", "suffix": ""}], "year": 2019, "venue": "IEICE Trans. Inf. Syst", "volume": "", "issn": "", "pages": "1081--1084", "other_ids": {"DOI": ["10.1587/transinf.2018EDL8200"]}}, "BIBREF21": {"ref_id": "b21", "title": "Elements of Information Theory", "authors": [{"first": "T", "middle": ["M"], "last": "Cover", "suffix": ""}, {"first": "J", "middle": ["A"], "last": "Thomas", "suffix": ""}], "year": 2009, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF22": {"ref_id": "b22", "title": "Note on Noisy Group Testing: Asymptotic Bounds and Belief Propagation Reconstruction", "authors": [{"first": "D", "middle": [], "last": "Sejdinovic", "suffix": ""}, {"first": "O", "middle": [], "last": "Johnson", "suffix": ""}], "year": 2010, "venue": "Proceedings of the Forty-Eighth Annual Allerton Conference", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF23": {"ref_id": "b23", "title": "Performance of LDPC Codes Under Noisy Message-Passing Decoding", "authors": [{"first": "L", "middle": ["R"], "last": "Varshney", "suffix": ""}], "year": 2007, "venue": "Proceedings of the 2007 IEEE Information Theory Workshop", "volume": "", "issn": "", "pages": "2--6", "other_ids": {}}}, "ref_entries": {"FIGREF0": {"text": "The cumulative number of confirmed cases and the cumulative number of deaths by COVID-19 by 20 April [13].", "latex": null, "type": "figure"}, "FIGREF1": {"text": "Figure 2. One example of the simple group testing (GT) scheme with a 7 \u00d7 10 group matrix A, 10 samples x, additive noise z with one error, and seven output results y. The black and white boxes indicate 1 and 0, respectively. The third and eighth samples are included in the third group test, and its output is 1. The outputs of the sixth and seventh tests are 1. The first pure output is 0; however, the additive noise is included, and the corresponding output is flipped.", "latex": null, "type": "figure"}, "FIGREF2": {"text": "Graphical representation with 10 samples and seven output results for the example of the group testing (GT) scheme shown inFigure 2.", "latex": null, "type": "figure"}, "FIGREF3": {"text": "The total number of confirmed cases and tests for COVID-19 in each country as of 12 April 2020 [13]. The average incidence rate is 12.89%, with a total number of confirmed cases of 1,743,883 and a total number of tests of 13,531,095.", "latex": null, "type": "figure"}, "FIGREF4": {"text": "Comparisons of the number of tests T on information-theoretic bounds in the noisy GT schemes with a size of N = 1000, different incidence rates (0.001-0.25), and noise levels \u03c3 (0.01, 0.03, 0.05, and 0.1).", "latex": null, "type": "figure"}, "TABREF1": {"text": "Comparisons of the total number of tests T expressed as (mean, standard deviation) to successfully find infected people with different incidence rates in the noisy GT scheme, where N = 1000 and \u03c3 = 0.01, 0.03, 0.05.", "latex": null, "type": "table"}}, "back_matter": []}