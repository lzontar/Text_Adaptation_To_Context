{"paper_id": "2a51e24962816c67a4a0afa390999095d4612da4", "metadata": {"title": "APE: A Command-Line Tool and API for Automated Workflow Composition", "authors": [{"first": "Vedran", "middle": [], "last": "Kasalica", "suffix": "", "affiliation": {"laboratory": "", "institution": "Utrecht University", "location": {"postCode": "3584 CC", "settlement": "Utrecht", "country": "The Netherlands"}}, "email": "v.kasalica@uu.nl"}, {"first": "B", "middle": [], "last": "", "suffix": "", "affiliation": {"laboratory": "", "institution": "Utrecht University", "location": {"postCode": "3584 CC", "settlement": "Utrecht", "country": "The Netherlands"}}, "email": ""}, {"first": "Anna-Lena", "middle": [], "last": "Lamprecht", "suffix": "", "affiliation": {"laboratory": "", "institution": "Utrecht University", "location": {"postCode": "3584 CC", "settlement": "Utrecht", "country": "The Netherlands"}}, "email": "a.l.lamprecht@uu.nl"}]}, "abstract": [{"text": "Automated workflow composition is bound to take the work with scientific workflows to the next level. On top of today's comprehensive eScience infrastructure, it enables the automated generation of possible workflows for a given specification. However, functionality for automated workflow composition tends to be integrated with one of the many available workflow management systems, and is thus difficult or impossible to apply in other environments. Therefore we have developed APE (the Automated Pipeline Explorer) as a command-line tool and API for automated composition of scientific workflows. APE is easily configured to a new application domain by providing it with a domain ontology and semantically annotated tools. It can then be used to synthesize purpose-specific workflows based on a specification of the available workflow inputs, desired outputs and possibly additional constraints. The workflows can further be transformed into executable implementations and/or exported into standard workflow formats. In this paper we describe APE v1.0 and discuss lessons learned from applications in bioinformatics and geosciences.", "cite_spans": [], "ref_spans": [], "section": "Abstract"}], "body_text": [{"text": "Computational pipelines, or workflows, are central to contemporary computational science [5] . The international eScience community has created a comprehensive infrastructure of tools, services and platforms that support the work with scientific workflows. Numerous scientific workflow management systems exist [1, 29] , some of the currently most popular being Galaxy [10] , KNIME [6] and Nextflow [7] . While these systems free their users from many technicalities that they would have to deal with when conventionally programming workflows, the identification of suitable computational components and their composition into executable workflows remains a manual task.", "cite_spans": [{"start": 89, "end": 92, "text": "[5]", "ref_id": "BIBREF3"}, {"start": 311, "end": 314, "text": "[1,", "ref_id": "BIBREF0"}, {"start": 315, "end": 318, "text": "29]", "ref_id": "BIBREF27"}, {"start": 369, "end": 373, "text": "[10]", "ref_id": "BIBREF8"}, {"start": 382, "end": 385, "text": "[6]", "ref_id": "BIBREF4"}, {"start": 399, "end": 402, "text": "[7]", "ref_id": "BIBREF5"}], "ref_spans": [], "section": "Introduction"}, {"text": "The idea of automated workflow composition is to let an algorithm perform this process. Based on a loose specification of the intended workflow (for example in terms of available workflow inputs and desired outputs, or principal steps to take), it would automatically generate suitable, executable workflows. It has been shown that program synthesis [11] and AI planning techniques [8] can be used to implement such functionality [20, 22, 23] . Some workflow management systems, such as jORCA/Magallanes [15] , jABC/PROPHETS [21, 24] and WINGS [9] , provide automated workflow composition functionality based on such techniques. However, the tight integration with the respective workflow systems makes it difficult or even impossible to use this functionality in other environments.", "cite_spans": [{"start": 350, "end": 354, "text": "[11]", "ref_id": "BIBREF9"}, {"start": 382, "end": 385, "text": "[8]", "ref_id": "BIBREF6"}, {"start": 430, "end": 434, "text": "[20,", "ref_id": "BIBREF18"}, {"start": 435, "end": 438, "text": "22,", "ref_id": "BIBREF20"}, {"start": 439, "end": 442, "text": "23]", "ref_id": "BIBREF21"}, {"start": 504, "end": 508, "text": "[15]", "ref_id": "BIBREF13"}, {"start": 525, "end": 529, "text": "[21,", "ref_id": "BIBREF19"}, {"start": 530, "end": 533, "text": "24]", "ref_id": "BIBREF22"}, {"start": 544, "end": 547, "text": "[9]", "ref_id": "BIBREF7"}], "ref_spans": [], "section": "Introduction"}, {"text": "Therefore we have developed APE 1 (the Automated Pipeline Explorer) as a command-line tool and API for automated workflow composition. It is designed to be independent from any concrete workflow system, and thus ready to be used in other workflow management systems, tool repositories or workflow sharing platforms as needed. Internally, APE uses a SAT-based implementation of a temporal-logic process synthesis method, inspired by the approach behind the PROPHETS framework [21, 27] and described in detail [17] . In a nutshell, the framework uses an extension of the well known Linear Temporal Logic (LTL) to encode the workflow specification. This specification is translated into a propositional logic formula that can be processed by an off-the-shelf SAT solver, with the resulting solutions representing possible workflows for the specification.", "cite_spans": [{"start": 475, "end": 479, "text": "[21,", "ref_id": "BIBREF19"}, {"start": 480, "end": 483, "text": "27]", "ref_id": "BIBREF25"}, {"start": 508, "end": 512, "text": "[17]", "ref_id": "BIBREF15"}], "ref_spans": [], "section": "Introduction"}, {"text": "In this paper, we introduce APE v1.0 from an application point of view. Section 2 describes how to set it up for use by providing a semantic domain model. Section 3 focuses on the automated composition of workflows based on the domain model and custom workflow specifications. Section 4 describes how APE-composed workflows can further be transformed into executable implementations and/or exported into standard workflow formats. Section 5 discusses lessons learned from applications of APE in bioinformatics and geosciences. Section 6 concludes the paper.", "cite_spans": [], "ref_spans": [], "section": "Introduction"}, {"text": "The semantic domain model constitutes the knowledge base on which APE relies for the automated composition of workflows. It comprises a domain ontology and a collection of semantically annotated tools. The domain ontology provides taxonomic classifications of the data types and operations in the application domain, as a controlled vocabulary of technical terms. Tools in the domain model are semantically annotated with their inputs, outputs and operations, using terms from the ontology. Additionally, the domain model might include (temporallogic) constraints to express further domain knowledge or rules.", "cite_spans": [], "ref_spans": [], "section": "Domain Model"}, {"text": "For example, Fig. 1 and Table 1 show fragments of a bioinformatics domain model from a recent case study on automated workflow composition in proteomics [25] . The domain ontology (see Fig. 1 ) was directly derived from the popular bioinformatics data and methods ontology EDAM [12] . Table 1 shows a few tool annotations from the same case study. Each tool is semantically annotated with the operation(s) it performs and its input and output data types and formats, using terms from the respective taxonomies. These annotations were directly derived from the bio.tools registry [13, 14] , a large collection of EDAM-annotated bioinformatics tools. Note that in this example, two dimensions (type and format) are used for the annotation of the input and output data. Other applications need only one (e.g. format), and yet others have more than two required dimensions. Hence, APE supports the use of multiple disjoint taxonomy trees to represent the required dimensions of data characterization.", "cite_spans": [{"start": 153, "end": 157, "text": "[25]", "ref_id": "BIBREF23"}, {"start": 278, "end": 282, "text": "[12]", "ref_id": "BIBREF10"}, {"start": 579, "end": 583, "text": "[13,", "ref_id": "BIBREF11"}, {"start": 584, "end": 587, "text": "14]", "ref_id": "BIBREF12"}], "ref_spans": [{"start": 13, "end": 19, "text": "Fig. 1", "ref_id": "FIGREF0"}, {"start": 24, "end": 31, "text": "Table 1", "ref_id": "TABREF0"}, {"start": 185, "end": 191, "text": "Fig. 1", "ref_id": "FIGREF0"}, {"start": 285, "end": 292, "text": "Table 1", "ref_id": "TABREF0"}], "section": "Domain Model"}, {"text": "Technically, we rely on existing and (de facto) standard formalisms for the representation of the domain model. APE loads the domain ontology from a file in Web Ontology Language (OWL) format. The tool annotations are represented in JavaScript Object Notation (JSON) format, following the schema that is used in the bio.tools registry [2].", "cite_spans": [], "ref_spans": [], "section": "Domain Model"}, {"text": "Once the domain model has been configured, APE is ready to be used for automated workflow composition. Therefor the user specifies the workflow inputs, intended outputs and additional constraints that the workflow has to fulfill. Internally the constraints are expressed in a formal (temporal) logic, but the APE interfaces expose them in the form of intuitive natural-language templates. For example (as illustrated in Fig. 2) , one workflow specification from the proteomics case study consists of \"Mass spectrum\" type in \"Thermo RAW format\" as input, \"Amino acid index (hydropathy)\" (in any format) as output, and constraints specifying to use tools that perform the operations \"peptide identification\", \"validation of peptide spectrum matches\" and \"retention time prediction\" (constraint template \"Use operation X \"). These operations are abstract terms from the ontology, known to scientists from the domain. This shows that formulating such constraints does not require knowledge of all available tools that fit the description. Based on the given specification APE synthesizes workflows that fulfill the specification by construction. Figure 2 shows two of many possible workflow solutions for the example specification. Automated workflow composition with APE can be performed through its command line interface (CLI) or its application programming interface (API). While the CLI provides a simple means to interact and experiment with the system, the API provides more flexibility and control over the synthesis process. It can also be used to integrate APE's functionality into other systems. ", "cite_spans": [], "ref_spans": [{"start": 420, "end": 427, "text": "Fig. 2)", "ref_id": "FIGREF1"}, {"start": 1142, "end": 1150, "text": "Figure 2", "ref_id": "FIGREF1"}], "section": "Automated Workflow Composition"}, {"text": "When running APE-<version>.jar from the command line, it requires a configuration file as a parameter and executes the complete automated workflow composition process accordingly. This JSON-based configuration file provides references to all therefor required information:", "cite_spans": [], "ref_spans": [], "section": "Command Line Interface (CLI)"}, {"text": "1. The domain model (as described in Sect. 2), provided as a pair of a wellformatted OWL and JSON files, 2. the workflow specification, provided as a list of workflow inputs/outputs and template-based workflow constraints, and 3. parameters for the synthesis execution, such as the number of desired solutions, output directory, system configurations, etc.", "cite_spans": [], "ref_spans": [], "section": "Command Line Interface (CLI)"}, {"text": "APE then writes the synthesized workflows into the defined output directory. Each solution consists of a text file that describes the steps of the workflow, a graphical representation, and a shell script that implements the workflow (depending on the availability of suitable shell commands in the tool annotations).", "cite_spans": [], "ref_spans": [], "section": "Command Line Interface (CLI)"}, {"text": "Like the CLI, the APE API relies on a configuration file that references the domain ontology, tool annotations, workflow specification and execution parameters. However, the API allows to edit this file programmatically, and thus for instance add constraints or change execution parameters dynamically. This is useful, for instance, for providing more interactive user interfaces or for systematically exploring and evaluating workflow synthesis results for varying specifications and execution parameters.", "cite_spans": [], "ref_spans": [], "section": "Application Programming Interface (API)"}, {"text": "JSONObject apeConfig = Utils.generateGeneralConfiguration(); apeConfig.put(\"ontology_path\", \"./EDAM.owl\"); apeConfig.put(\"tool_annotations_path\", \"./biotools.json\"); APE apeFramework = new APE(apeConfig); JSONObject runConfig = Utils.parseJson(\"./runConfig.json\"); List<SolutionWorkflow> solutions = apeFramework.runSynthesis(runConfig); apeFramework.writeSolutionToFile(solutions); apeFramework.writeDataFlowGraphs(solutions); Listing 1.1. APE API calls used to synthesize workflows and save solution.", "cite_spans": [], "ref_spans": [], "section": "Application Programming Interface (API)"}, {"text": "Listing 1.1 shows a small example of using the APE API for synthesizing a set of workflows similar to the example in Fig. 2 . First, the paths to the domain ontology and tool annotation files are added to the APE configuration object. Then a new instance of the APE framework is created based on the configuration, and the workflow synthesis algorithm is executed with the provided run configuration. The result of the synthesis run is a list of solutions obtained from the SAT solver, which are written into the output directory in textual and graphical (data-flow) format. The APE API provides further functionality, allowing for a more fine-grained interaction with the APE framework. Figure 3 outlines the API, for brevity focusing on the most relevant fields and functions. The ConstraintFactory and Constraint classes allow for the retrieval of constraint templates and for adding new or removing existing constraints, thus further constraining or loosening the specification, respectively. As shown in the example code above, the APE class constitutes the main interface for interaction with the framework. It is used to define the execution parameters as well as the output formats. Once the library has generated the solutions, they are provided as a list of SolutionWorkflows. Each solution is represented as a directed graph that comprises type and tool nodes (internally named modules). The interface for working with the workflow solutions (further elaborated in the next section) is provided by the classes Solu-tionWorkflow, TypeNode (representing type instances) and ModuleNode (representing tool instances).", "cite_spans": [], "ref_spans": [{"start": 117, "end": 123, "text": "Fig. 2", "ref_id": "FIGREF1"}, {"start": 688, "end": 696, "text": "Figure 3", "ref_id": "FIGREF2"}], "section": "Application Programming Interface (API)"}, {"text": "As mentioned above, APE provides functionality for exporting the synthesized workflows as textual representations, in the form of (data-flow and control-flow) graphs and as executable shell scripts. In practice it is often desirable to implement workflows in one of the languages used by popular workflow management systems, in order to be able to execute them with the respective workflow engines. Given the large number of existing workflow languages, it is however not feasible for APE to provide ready-to-use export functionality for all of them. Instead, the information contained in APE's own workflow representation can be used to create workflows in other languages. In the following we describe the APE workflow format and demonstrate how the contained information can be used to create corresponding workflows in the Common Workflow Language (CWL) [4] . This feature is going to be integrated to the APE API in the near future. The mapping process described in this paper can furthermore serve as a template for the translation of APE results to other workflow formats, such as NextFlow [7] , SnakeMake [19] or the Workflow Description Language (WDL) [3] .", "cite_spans": [{"start": 858, "end": 861, "text": "[4]", "ref_id": null}, {"start": 1097, "end": 1100, "text": "[7]", "ref_id": "BIBREF5"}, {"start": 1113, "end": 1117, "text": "[19]", "ref_id": "BIBREF17"}, {"start": 1161, "end": 1164, "text": "[3]", "ref_id": "BIBREF1"}], "ref_spans": [], "section": "Workflow Implementation"}, {"text": "APE represents the workflow solutions in the form of directed graphs. The lefthand side of Fig. 4 shows an example. Nodes in the graph represent instances of data (depicted as ellipses) and executions of operations (rectangles), while the edges represent inputs and outputs of these tools, shown as green and red arrows, respectively. In addition, labels on the edges represent the order in which they are given as arguments to the tools. This graph provides the trace information that is needed to create the workflow in another language.", "cite_spans": [], "ref_spans": [{"start": 91, "end": 97, "text": "Fig. 4", "ref_id": "FIGREF3"}], "section": "APE Workflow Format"}, {"text": "The APE API provides a set of functions to aid the interaction with the graph structure (see class SolutionWorkflow in Fig. 3) . The workflow inputs can simply be retrieved using the corresponding function of the SolutionWorkflow class, which returns it as a list of TypeNodes. Generally, each TypeNode comprises a (possibly empty) tool node that generated it as an output, a (possibly empty) list of tools that used it as an input, and a concrete data Type that identifies it. Further, the SolutionWorkflow class provides a function for retrieving the tools used in the workflow as list of ModuleNodes (sorted according to their order of execution), making it easy to iterate over all tools used in the workflow. Each ModuleNode provides information about the next and the previous ModuleNode in the sequence, the TypeNodes used as inputs and generated as outputs by the tool, as well as information about the actual tool (executable script, see class Module) that provides the information needed for its execution. Finally, the workflow outputs are provided in the same format as the initial inputs. Note that for this example the first proposed solution from Fig. 3 was artificially extended with additional inputs and outputs (depicted as gray ellipses) for illustrative purposes.", "cite_spans": [], "ref_spans": [{"start": 119, "end": 126, "text": "Fig. 3)", "ref_id": "FIGREF2"}, {"start": 1162, "end": 1168, "text": "Fig. 3", "ref_id": "FIGREF2"}], "section": "APE Workflow Format"}, {"text": "The Common Workflow Language 2 (CWL) [4] has recently emerged as an open standard for describing scientific workflows across platforms. It is increasingly adopted by the scientific community, with CWL support being added to popular scientific workflow management systems like, for example, Galaxy [10] and Toil [28] . CWL is a declarative language that focuses on workflows composed from command line tools. Basically, it describes a set of steps and dependencies between those steps. CWL has its roots in \"make\" and similar tools, and like them it determines the order of execution based on these dependencies between tasks, i.e. if there is a required order of the operations or if they can even be executed concurrently. Conveniently, the main CWL structure is quite similar to the APE workflow structure. A basic workflow (see right-hand side of Fig. 4 ) comprises a configuration header, a list of workflow inputs, steps to be performed and workflow outputs. The input/output dependencies have to be explicitly defined, again in line with our data trace workflow representation. The tools in CWL usually include a command field, explicitly defining the corresponding command line operation. In addition, they can be configured to run tools from Docker containers automatically, allowing for more flexible and scalable workflow implementations.", "cite_spans": [{"start": 37, "end": 40, "text": "[4]", "ref_id": null}, {"start": 297, "end": 301, "text": "[10]", "ref_id": "BIBREF8"}, {"start": 311, "end": 315, "text": "[28]", "ref_id": "BIBREF26"}], "ref_spans": [{"start": 850, "end": 856, "text": "Fig. 4", "ref_id": "FIGREF3"}], "section": "Translation to CWL"}, {"text": "However, as the fully automatic configuration for execution is not always feasible, the upcoming CWL version 1.2 will introduce abstract workflows. These workflows use descriptive containers instead of directly executable operations, and require additional (manual) configuration to become executable. The abstract containers are represented using the intent label (see Fig. 4 ). Given that functional description of tools is sufficient for workflow discovery with APE, the abstract CWL workflows match well with APE's own workflow representation. Furthermore, the bio.tools registry used as source for the tool annotations in the aforementioned bioinformatics case study is a typical example of such a set of tools. The repository contains the semantic annotations of the tools, but still might require some additional work from the user in order to execute the tool itself. Hence APE discovers workflows composed of tools that are not necessarily available on the local system, potentially requiring the installation and configuration of the tools on the execution system first.", "cite_spans": [], "ref_spans": [{"start": 370, "end": 376, "text": "Fig. 4", "ref_id": "FIGREF3"}], "section": "Translation to CWL"}, {"text": "To translate and APE workflow into CWL format, it is sufficient to 1) describe the original inputs, 2) iterate through the tools in the workflow sequence and specify the inputs used and outputs generated, and finally 3) specify the workflow output list. The right-hand side of Fig. 4 shows the CWL representation of the APE workflow on the left. To create it, first, the list of input objects is translated into a list of inputs that are annotated using their formats (see Label workflow in). This means that some information about the data get lost in the translation (specifically the type description). However, as at runtime the format is sufficient to perform the execution, this is not a problem. Second, each tool in the sequence is described. The description involves a definition of the inputs, outputs and tool execution specification (mappings are annotated using labels tool in, tool out and tool info, respectively). The most important part of the step is to keep track of the exact source of the tool inputs as well as to provide sufficient tool description that would allow for its execution. The input information is already part of the formalism, as APE keeps track of data flow traces for each data instance. The only requirement is to properly use the identifiers provided when creating the mappings to CWL. Regarding the tool descriptions, as long as the provided tool annotation file contains sufficient information, it can be translated into CWL. Third, the final workflow outputs need to be specified based on the given solution description (see Label workflow out).", "cite_spans": [], "ref_spans": [{"start": 277, "end": 283, "text": "Fig. 4", "ref_id": "FIGREF3"}], "section": "Translation to CWL"}, {"text": "The development of APE was accompanied by three concrete application scenarios for automated workflow composition: 1) The proteomics case study mentioned earlier in this paper [25] , 2) a case study on cartographic map generation [16] , and 3) geospatial data transformations in the QuAnGIS project [18, 26] . The experiences from these applications, in particular the feedback from the involved domain experts, influenced the design decisions that we took during the development of the APE CLI and API. While initial versions of all three application scenarios have been created with PROPHETS, they have meanwhile been migrated to APE completely and are publicly available 3 .", "cite_spans": [{"start": 176, "end": 180, "text": "[25]", "ref_id": "BIBREF23"}, {"start": 230, "end": 234, "text": "[16]", "ref_id": "BIBREF14"}, {"start": 299, "end": 303, "text": "[18,", "ref_id": "BIBREF16"}, {"start": 304, "end": 307, "text": "26]", "ref_id": "BIBREF24"}], "ref_spans": [], "section": "Applications and Lessons Learned"}, {"text": "Naturally, the quality of the workflows obtained through APE essentially depends on the quality of the semantic domain model (ontologies and functional tool annotations). Hence it is crucial to involve domain experts in the domain modeling process, or to rely on sources that have been created by expert communities, such as the EDAM ontology and bio.tools registry that we use in bioinformatics applications of APE. Essentially, the idea is that the domain model is provided and maintained by a small group of domain experts, and used by a larger and broader audience to automatically compose workflows. As a positive side effect on domain modeling, using APE for the systematic generation and evaluation of workflows from varying specifications proved to be helpful to revise and improve ontologies and annotations.", "cite_spans": [], "ref_spans": [], "section": "Applications and Lessons Learned"}, {"text": "Initially we used a tabular format for the tool annotations, like the one shown in Table 1 , because spreadsheets are easy to discuss with collaborators, and the corresponding CSV files easy to process programmatically. However, this approach quickly turned out to be insufficient to adequately capture non-trivial tool annotations. In the proteomics case study, we annotated tools' inputs and outputs with both data type and format terms from EDAM. As the tools have varying numbers of inputs and outputs, however, they could not be properly annotated in the tabular format with a fixed number of columns. To increase the expressiveness of APE's tool annotation template, but at the same time reuse an existing formalism, we decided to adopt the JSON-based tool annotation schema used in the bio.tools registry [2], which includes a well-defined and flexible mechanism for functional tool annotation. This has of course extremely simplified the setup of bioinformatics domain models based on bio.tools, but it has also shown to be easy to use in the other application domains.", "cite_spans": [], "ref_spans": [{"start": 83, "end": 90, "text": "Table 1", "ref_id": "TABREF0"}], "section": "Applications and Lessons Learned"}, {"text": "The APE CLI and API aim to be easy-to-use, but clearly target a techsavvy audience with a certain level coding and/or scripting confidence. To reach a broader audience, an intuitive interface that can be used without technical experience or specific training is required. As a proof of principle, we recently developed Burke (a Bio-tools and edam User interface foR automated worKflow Exploration 4 ). Preconfigured to the domain model of the proteomics case study, it provides the automated workflow composition functionality of APE through a browser-based graphical interface. Users can select input and output data types and formats, as well as constraint templates and their instantiations, from drop-down menus that are filled with the relevant EDAM terms. They can configure and run APE's synthesizer from the interface, and subsequently inspect the results, which are presented in a convenient tabular format. Feedback on Burke by APE novices has been very positive, hence we plan to develop a more sophisticated web interface for APE in the scope of future work on the framework.", "cite_spans": [], "ref_spans": [], "section": "Applications and Lessons Learned"}, {"text": "A graphical interface has also the potential to overcome another limitation of the framework: Currently it is a tedious process to compare the different possible workflows generated by APE. This is however needed to make an informed decision about which of the potentially many possible workflows to select for implementation and execution. A graphical interface provides more possibilities for dynamically filtering, aggregating and displaying workflow candidates according to different criteria. Which criteria would actually provide meaningful information for workflow selection is currently an open question. This is another challenge that we are going to work on in the future.", "cite_spans": [], "ref_spans": [], "section": "Applications and Lessons Learned"}, {"text": "We believe that automated workflow composition will take the work with scientific workflows to the next level. On top of today's comprehensive eScience infrastructure, it enables the automated generation of possible workflows for a given specification. In this paper we introduced APE v1.0 (the Automatic Pipeline Explorer), a command line tool and API that automates the exploration of scientific workflows. APE is under active development and continuously improving through the experiences and feedback from applications.", "cite_spans": [], "ref_spans": [], "section": "Conclusion"}, {"text": "Future work on the APE framework will address different remaining challenges of usability and scalability. We are going to work on more end useroriented interfaces that support better the whole life cycle of specifying, synthesizing, comparing, selecting, implementing and benchmarking computational pipelines. With growing domain models, the runtime performance of the underlying synthesis algorithm is likely to become a bottleneck. We have started to work on domain-specific search heuristics to improve synthesis performance and allow the approach to scale.", "cite_spans": [], "ref_spans": [], "section": "Conclusion"}], "bib_entries": {"BIBREF0": {"ref_id": "b0", "title": "Existing Workflow systems", "authors": [], "year": 2019, "venue": "", "volume": "52", "issn": "", "pages": "", "other_ids": {}}, "BIBREF1": {"ref_id": "b1", "title": "Workflow Description Language (WDL)", "authors": [], "year": 2020, "venue": "", "volume": "12", "issn": "", "pages": "", "other_ids": {}}, "BIBREF3": {"ref_id": "b3", "title": "Scientific workflows: past, present and future", "authors": [{"first": "M", "middle": [], "last": "Atkinson", "suffix": ""}, {"first": "S", "middle": [], "last": "Gesing", "suffix": ""}, {"first": "J", "middle": [], "last": "Montagnat", "suffix": ""}, {"first": "I", "middle": [], "last": "Taylor", "suffix": ""}], "year": 2017, "venue": "Future Gener. Comput. Syst", "volume": "75", "issn": "", "pages": "216--227", "other_ids": {}}, "BIBREF4": {"ref_id": "b4", "title": "Knime-the konstanz information miner: version 2.0 and beyond", "authors": [{"first": "M", "middle": ["R"], "last": "Berthold", "suffix": ""}], "year": 2009, "venue": "AcM SIGKDD Explor. Newslett", "volume": "11", "issn": "1", "pages": "26--31", "other_ids": {}}, "BIBREF5": {"ref_id": "b5", "title": "Nextflow enables reproducible computational workflows", "authors": [{"first": "P", "middle": [], "last": "Di Tommaso", "suffix": ""}, {"first": "M", "middle": [], "last": "Chatzou", "suffix": ""}, {"first": "E", "middle": ["W"], "last": "Floden", "suffix": ""}], "year": 2017, "venue": "Nat. Biotechnol", "volume": "35", "issn": "", "pages": "316--319", "other_ids": {}}, "BIBREF6": {"ref_id": "b6", "title": "Automated Planning and Acting, 1st edn", "authors": [{"first": "M", "middle": [], "last": "Ghallab", "suffix": ""}, {"first": "D", "middle": [], "last": "Nau", "suffix": ""}, {"first": "P", "middle": [], "last": "Traverso", "suffix": ""}], "year": 2016, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF7": {"ref_id": "b7", "title": "Wings: intelligent workflow-based design of computational experiments", "authors": [{"first": "Y", "middle": [], "last": "Gil", "suffix": ""}, {"first": "V", "middle": [], "last": "Ratnakar", "suffix": ""}, {"first": "J", "middle": [], "last": "Kim", "suffix": ""}], "year": 2011, "venue": "IEEE Intell. Syst", "volume": "26", "issn": "1", "pages": "62--72", "other_ids": {}}, "BIBREF8": {"ref_id": "b8", "title": "Galaxy: a comprehensive approach for supporting accessible, reproducible, and transparent computational research in the life sciences", "authors": [{"first": "J", "middle": [], "last": "Goecks", "suffix": ""}, {"first": "A", "middle": [], "last": "Nekrutenko", "suffix": ""}, {"first": "J", "middle": [], "last": "Taylor", "suffix": ""}], "year": 2010, "venue": "Genome Biol", "volume": "11", "issn": "8", "pages": "", "other_ids": {}}, "BIBREF9": {"ref_id": "b9", "title": "Program Synthesis, Foundations and Trends in Programming Languages", "authors": [{"first": "S", "middle": [], "last": "Gulwani", "suffix": ""}, {"first": "O", "middle": [], "last": "Polozov", "suffix": ""}, {"first": "R", "middle": [], "last": "Singh", "suffix": ""}], "year": 2017, "venue": "", "volume": "4", "issn": "", "pages": "", "other_ids": {}}, "BIBREF10": {"ref_id": "b10", "title": "EDAM: an ontology of bioinformatics operations, types of data and identifiers, topics and formats", "authors": [{"first": "J", "middle": [], "last": "Ison", "suffix": ""}, {"first": "M", "middle": [], "last": "Kala\u0161", "suffix": ""}, {"first": "I", "middle": [], "last": "Jonassen", "suffix": ""}], "year": 2013, "venue": "Bioinformatics", "volume": "29", "issn": "", "pages": "1325--1332", "other_ids": {"DOI": ["10.1093/bioinformatics/btt113"]}}, "BIBREF11": {"ref_id": "b11", "title": "Community curation of bioinformatics software and data resources. Brief. Bioinform. bbz075", "authors": [{"first": "J", "middle": [], "last": "Ison", "suffix": ""}], "year": 2019, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {"DOI": ["10.1093/bib/bbz075"]}}, "BIBREF12": {"ref_id": "b12", "title": "Tools and data services registry: a community effort to document bioinformatics resources", "authors": [{"first": "J", "middle": [], "last": "Ison", "suffix": ""}, {"first": "K", "middle": [], "last": "Rapacki", "suffix": ""}, {"first": "H", "middle": [], "last": "M\u00e9nager", "suffix": ""}], "year": 2016, "venue": "Nucleic Acids Res", "volume": "44", "issn": "D1", "pages": "38--47", "other_ids": {}}, "BIBREF13": {"ref_id": "b13", "title": "Workflow composition and enactment using jORCA", "authors": [{"first": "J", "middle": [], "last": "Karlsson", "suffix": ""}, {"first": "V", "middle": [], "last": "Mart\u00edn-Requena", "suffix": ""}, {"first": "J", "middle": [], "last": "R\u00edos", "suffix": ""}, {"first": "O", "middle": [], "last": "Trelles", "suffix": ""}], "year": 2010, "venue": "ISoLA 2010", "volume": "6415", "issn": "", "pages": "328--339", "other_ids": {"DOI": ["10.1007/978-3-642-16558-0_28"]}}, "BIBREF14": {"ref_id": "b14", "title": "Workflow discovery through semantic constraints: a geovisualization case study", "authors": [{"first": "V", "middle": [], "last": "Kasalica", "suffix": ""}, {"first": "A.-L", "middle": [], "last": "Lamprecht", "suffix": ""}], "year": 2019, "venue": "ICCSA 2019", "volume": "11621", "issn": "", "pages": "473--488", "other_ids": {"DOI": ["10.1007/978-3-030-24302-9_34"]}}, "BIBREF15": {"ref_id": "b15", "title": "Workflow Discovery with Semantic Constraints: A SAT-Based Implementation", "authors": [{"first": "V", "middle": [], "last": "Kasalica", "suffix": ""}, {"first": "A", "middle": ["L"], "last": "Lamprecht", "suffix": ""}], "year": 2020, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {"DOI": ["10.14279/tuj.eceasst.78.1092"]}}, "BIBREF16": {"ref_id": "b16", "title": "Loose programming of GIS workflows with geo-analytical concepts", "authors": [{"first": "H", "middle": [], "last": "Kruiger", "suffix": ""}, {"first": "V", "middle": [], "last": "Kasalica", "suffix": ""}, {"first": "R", "middle": [], "last": "Meerlo", "suffix": ""}, {"first": "A", "middle": ["L"], "last": "Lamprecht", "suffix": ""}, {"first": "S", "middle": [], "last": "Scheider", "suffix": ""}], "year": 2020, "venue": "Transactions in GIS", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF17": {"ref_id": "b17", "title": "Snakemake-a scalable bioinformatics workflow engine", "authors": [{"first": "J", "middle": [], "last": "K\u00f6ster", "suffix": ""}, {"first": "S", "middle": [], "last": "Rahmann", "suffix": ""}], "year": 2012, "venue": "Bioinformatics", "volume": "28", "issn": "19", "pages": "2520--2522", "other_ids": {}}, "BIBREF18": {"ref_id": "b18", "title": "User-Level Workflow Design -A Bioinformatics Perspective", "authors": [{"first": "A.-L", "middle": [], "last": "Lamprecht", "suffix": ""}], "year": 2013, "venue": "", "volume": "8311", "issn": "", "pages": "", "other_ids": {"DOI": ["10.1007/978-3-642-45389-2"]}}, "BIBREF19": {"ref_id": "b19", "title": "Synthesis-based loose programming", "authors": [{"first": "A", "middle": ["L"], "last": "Lamprecht", "suffix": ""}, {"first": "S", "middle": [], "last": "Naujokat", "suffix": ""}, {"first": "T", "middle": [], "last": "Margaria", "suffix": ""}, {"first": "B", "middle": [], "last": "Steffen", "suffix": ""}], "year": 2010, "venue": "QUATIC 2010", "volume": "", "issn": "", "pages": "262--267", "other_ids": {}}, "BIBREF20": {"ref_id": "b20", "title": "Semantics-based composition of EMBOSS services", "authors": [{"first": "A", "middle": ["L"], "last": "Lamprecht", "suffix": ""}, {"first": "S", "middle": [], "last": "Naujokat", "suffix": ""}, {"first": "T", "middle": [], "last": "Margaria", "suffix": ""}, {"first": "B", "middle": [], "last": "Steffen", "suffix": ""}], "year": 2011, "venue": "J. Biomed. Seman", "volume": "2", "issn": "1", "pages": "", "other_ids": {}}, "BIBREF21": {"ref_id": "b21", "title": "Constraint-guided workflow composition based on the EDAM ontology", "authors": [{"first": "A", "middle": ["L"], "last": "Lamprecht", "suffix": ""}, {"first": "S", "middle": [], "last": "Naujokat", "suffix": ""}, {"first": "B", "middle": [], "last": "Steffen", "suffix": ""}, {"first": "T", "middle": [], "last": "Margaria", "suffix": ""}, {"first": "A", "middle": [], "last": "Burger", "suffix": ""}, {"first": "M", "middle": ["S"], "last": "Marshall", "suffix": ""}, {"first": "P", "middle": [], "last": "Romano", "suffix": ""}, {"first": "A", "middle": [], "last": "Paschke", "suffix": ""}], "year": 2010, "venue": "Proceedings of the 3rd International Workshop on Semantic Web Applications and Tools for Life Sciences", "volume": "698", "issn": "", "pages": "", "other_ids": {}}, "BIBREF22": {"ref_id": "b22", "title": "Loose programming with PROPHETS", "authors": [{"first": "S", "middle": [], "last": "Naujokat", "suffix": ""}, {"first": "A.-L", "middle": [], "last": "Lamprecht", "suffix": ""}, {"first": "B", "middle": [], "last": "Steffen", "suffix": ""}], "year": 2012, "venue": "FASE 2012", "volume": "7212", "issn": "", "pages": "94--98", "other_ids": {"DOI": ["10.1007/978-3-642-28872-2_7"]}}, "BIBREF23": {"ref_id": "b23", "title": "Automated workflow composition in mass spectrometry-based proteomics", "authors": [{"first": "M", "middle": [], "last": "Palmblad", "suffix": ""}, {"first": "A", "middle": ["L"], "last": "Lamprecht", "suffix": ""}, {"first": "J", "middle": [], "last": "Ison", "suffix": ""}, {"first": "V", "middle": [], "last": "Schw\u00e4mmle", "suffix": ""}], "year": 2018, "venue": "Bioinformatics", "volume": "35", "issn": "", "pages": "656--664", "other_ids": {"DOI": ["10.1093/bioinformatics/bty646"]}}, "BIBREF24": {"ref_id": "b24", "title": "Ontology of core concept data types for answering geo-analytical questions", "authors": [{"first": "S", "middle": [], "last": "Scheider", "suffix": ""}, {"first": "R", "middle": [], "last": "Meerlo", "suffix": ""}, {"first": "V", "middle": [], "last": "Kasalica", "suffix": ""}, {"first": "A", "middle": ["L"], "last": "Lamprecht", "suffix": ""}], "year": 2020, "venue": "JOSIS", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF25": {"ref_id": "b25", "title": "Module configuration by minimal model construction", "authors": [{"first": "B", "middle": [], "last": "Steffen", "suffix": ""}, {"first": "T", "middle": [], "last": "Margaria", "suffix": ""}, {"first": "B", "middle": [], "last": "Freitag", "suffix": ""}], "year": 1993, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF26": {"ref_id": "b26", "title": "Toil enables reproducible, open source, big biomedical data analyses", "authors": [{"first": "J", "middle": [], "last": "Vivian", "suffix": ""}], "year": 2017, "venue": "Nat. Biotechnol", "volume": "35", "issn": "4", "pages": "314--316", "other_ids": {"DOI": ["10.1038/nbt.3772"]}}, "BIBREF27": {"ref_id": "b27", "title": "Wikipedia contributors: scientific workflow system -Wikipedia, the free encyclopedia", "authors": [], "year": 2019, "venue": "", "volume": "3", "issn": "", "pages": "", "other_ids": {}}}, "ref_entries": {"FIGREF0": {"text": "Fragment of a bioinformatics domain ontology.", "latex": null, "type": "figure"}, "FIGREF1": {"text": "Automated composition of a proteomics workflow.", "latex": null, "type": "figure"}, "FIGREF2": {"text": "Fragment of the APE API.", "latex": null, "type": "figure"}, "FIGREF3": {"text": "Workflow in APE's native format (left) and corresponding CWL (right).", "latex": null, "type": "figure"}, "TABREF0": {"text": "Fragment of an annotated set of bioinformatics tools[14].", "latex": null, "type": "table"}}, "back_matter": []}