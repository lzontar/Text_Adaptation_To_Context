{"paper_id": "0c46c22adbfc1d4129f7c8e7a8c2a1ed6bc91501", "metadata": {"title": "A Combined Method for Usage of NLP Libraries Towards Analyzing Software Documents", "authors": [{"first": "Xinyun", "middle": [], "last": "Cheng", "suffix": "", "affiliation": {"laboratory": "", "institution": "Southeast University", "location": {"settlement": "Nanjing", "country": "China"}}, "email": ""}, {"first": "Xianglong", "middle": [], "last": "Kong", "suffix": "", "affiliation": {"laboratory": "", "institution": "Southeast University", "location": {"settlement": "Nanjing", "country": "China"}}, "email": "xlkong@seu.edu.cn"}, {"first": "Li", "middle": [], "last": "Liao", "suffix": "", "affiliation": {"laboratory": "", "institution": "Southeast University", "location": {"settlement": "Nanjing", "country": "China"}}, "email": "lliao@seu.edu.cn"}, {"first": "Bixin", "middle": [], "last": "Li", "suffix": "", "affiliation": {"laboratory": "", "institution": "Southeast University", "location": {"settlement": "Nanjing", "country": "China"}}, "email": ""}]}, "abstract": [{"text": "Natural Language Processing (NLP) library is widely used while analyzing software documents. The numerous toolkits result in a problem on NLP library selection. The selection of NLP library in current work commonly misses some objective reasons, which may pose threats to validity. And it is also not clear that whether the existing guideline on selection still works for the latest versions. In this work, we propose a solution for NLP library selection when the effectiveness is unknown. We use the NLP libraries together in a combined method. Our combined method can utilize the strengths of different NLP libraries to obtain accurate results. The combination is conducted through two steps, i.e., document-level selection of NLP library and sentence-level overwriting. In document-level selection of primary library, the results are obtained from the library that has the highest overall accuracy. Through sentence-level overwriting, the possible fine-gained improvements from other libraries are extracted to overwrite the outputs of primary library. We evaluate the combined method with 4 widely used NLP libraries and 200 documents from 3 different sources. The results show that the combined method can generally outperform all the studied NLP libraries in terms of accuracy. The finding means that our combined method can be used instead of individual NLP library for more effective results.", "cite_spans": [], "ref_spans": [], "section": "Abstract"}], "body_text": [{"text": "Software documents are important sources of knowledge in an information system. The documents (e.g., requirement documents, design documents or logs) are commonly written in natural language by some developers or automatically created by generators for different purposes. To obtain the information contained in software documents, many researchers directly use state-of-the-art Natural Language Processing (NLP) libraries to carry out the tasks [11, 21, 26] . There are Technical paper. several high-quality NLP libraries which are widely used in both industry and academia, such as NLTK 1 , spaCy 2 , Stanford CoreNLP 3 , Google's SyntaxNet 4 , OpenNLP 5 and so on. ALL the NLP libraries can provide API supports for the common NLP tasks (e.g., tokenization and part-of-speech tagging). The rich sources of candidates result in a new problem on the selection of suitable NLP library while analyzing documents. In most cases, the selection of NLP library is subjective [22, 28, 29, 32] . And the results from different NLP libraries may also be different, the subjective selection may pose threats to validity [17] .", "cite_spans": [{"start": 446, "end": 450, "text": "[11,", "ref_id": "BIBREF10"}, {"start": 451, "end": 454, "text": "21,", "ref_id": "BIBREF20"}, {"start": 455, "end": 458, "text": "26]", "ref_id": "BIBREF25"}, {"start": 970, "end": 974, "text": "[22,", "ref_id": "BIBREF21"}, {"start": 975, "end": 978, "text": "28,", "ref_id": "BIBREF27"}, {"start": 979, "end": 982, "text": "29,", "ref_id": "BIBREF28"}, {"start": 983, "end": 986, "text": "32]", "ref_id": "BIBREF32"}, {"start": 1111, "end": 1115, "text": "[17]", "ref_id": "BIBREF16"}], "ref_spans": [], "section": "Introduction"}, {"text": "To solve the problem, Omran and Treude propose an empirical study to give a guideline for choosing appropriate NLP libraries [17] . The guideline is expressed as the best choice of NLP libraries for a specific type of software documents. The effectiveness of NLP libraries is influenced by the NLP task and the source. For example, spaCy performs best on Stack Overflow text with nearly 90% of tokens tagged correctly in the experiments, while it is significantly outperformed by Google's SyntaxNet when parsing GitHub ReadMe text. However, the guideline cannot always help researchers to choose the best NLP library for a specific task. There are three reasons for the possible inaccuracy. First, there exist a great variety of software documents in real world [4, 13, 20] , and it is too tedious to produce an universal guideline for all the types of software documents. Second, the NLP libraries are optimized continuously, the existing guideline may be inaccurate in some upcoming scenarios. Third, different types of software documents may be analyzed together in some cases [6, 31] , the individual selection of different NLP libraries on different documents and NLP tasks may weaken the automation.", "cite_spans": [{"start": 125, "end": 129, "text": "[17]", "ref_id": "BIBREF16"}, {"start": 762, "end": 765, "text": "[4,", "ref_id": "BIBREF3"}, {"start": 766, "end": 769, "text": "13,", "ref_id": "BIBREF12"}, {"start": 770, "end": 773, "text": "20]", "ref_id": "BIBREF19"}, {"start": 1080, "end": 1083, "text": "[6,", "ref_id": "BIBREF5"}, {"start": 1084, "end": 1087, "text": "31]", "ref_id": "BIBREF30"}], "ref_spans": [], "section": "Introduction"}, {"text": "Since it is impractical to summarize an universal and continuously updated guideline of NLP library selection, we turn to investigate a method to use them together. In this paper, we propose a combined method which can utilize the strengths of different NLP libraries to achieve more effective results. The combined method is expected to generate more accurate results than single NLP library. To obtain the combined results, we firstly choose the whole results from the NLP library which has the highest overlapping degree. The overlapping degree of a NLP library defined in our work is the average proportion of identical outputs (e.g., tokens or part-of-speech tags) among the results achieved by it and any other NLP library individually. The overlapped results have high possibility to be correct due to the high quality of the studied NLP libraries. When the primary NLP library is selected in the first step, we identify the result of each sentence. The results of low-overlap sentences within a document are overwritten with the fine-gained improvements from other NLP libraries.", "cite_spans": [], "ref_spans": [], "section": "Introduction"}, {"text": "Our study has two main novel aspects. First, we conduct an empirical study to check whether the existing guideline fits to different versions of NLP libraries and different documents. The subjects include 4 publicly available NLP libraries and 200 documents from 3 different sources. The results confirm that the existing guideline should be updated with the evolution of NLP libraries and the change of given documents. Furthermore, each NLP library can generate its own exclusive correctness. This finding inspires us to extract correct results from different libraries to achieve a better effectiveness. The combined method for usage of NLP libraries brings the second novelty of our work. It contains two steps, i.e., document-level selection of NLP library and sentence-level overwriting. We evaluate the combined method according to a handmade benchmark in our study. The results show that our method can outperform any individual library in terms of accuracy on tokenization and part-of-speech tagging. The numeric promotion is around 2%. Due to the high quality of the studied NLP libraries, the improvements are meaningful in practice. And the majority of correct NLP results come from the outputs of primary NLP library. These findings mean that our combined method can be used instead of individual NLP library for more effective results in the analysis of software documents.", "cite_spans": [], "ref_spans": [], "section": "Introduction"}, {"text": "To sum up, this paper makes the following contributions.", "cite_spans": [], "ref_spans": [], "section": "Introduction"}, {"text": "-We conduct an empirical study to investigate the effectiveness of NLP libraries, and prove that the existing guideline should be updated with the evolution of libraries and each library has its own exclusive results. -We propose a method to combine the strengths of different NLP libraries, and the combined method can outperform any individual NLP library in the experiments.", "cite_spans": [], "ref_spans": [], "section": "Introduction"}, {"text": "In the section, we discuss some background knowledge of our method, i.e., NLP Library, NLP task and software document.", "cite_spans": [], "ref_spans": [], "section": "Background"}, {"text": "There are a lot of NLP libraries in both academia and industry, and the publicly available libraries are very popular in the analysis of software documents. Among them, we introduce several widely used NLP libraries in this section. NLTK is a platform for building Python programs to work with human language data. It provides a suite of text processing libraries. OpenNLP is a toolkit based on machine-learning for processing natural language text. NLP tasks denote the various purposes of analyzing documents. We list 3 frequently used NLP tasks as follow. Tokenization is the process of dividing a string into several parts [30] . The resulting tokens will be used in other tasks. When processing texts in English, tokenization of strings is impacted by the rules on processing punctuations. Stop words removal is designed to save storage space and improve search efficiency, some words or phrases will be filtered while processing natural language texts. These stop words or phrases are commonly insignificant. Part-of-speech is a basic grammatical property of a vocabulary. Part-of-speech tagging is the process of determining the grammatical category of each word in a given sentence and tagging it [5, 18] , the tags are usually used in syntactic analysis and information retrieval.", "cite_spans": [{"start": 627, "end": 631, "text": "[30]", "ref_id": "BIBREF29"}, {"start": 1205, "end": 1208, "text": "[5,", "ref_id": "BIBREF4"}, {"start": 1209, "end": 1212, "text": "18]", "ref_id": "BIBREF17"}], "ref_spans": [], "section": "NLP Libraries and Tasks"}, {"text": "Documents in software life-cycle may contain both oral words and formal statements. The formal documents are usually generated by some approaches, and the human-written documents may have a low degree of formalization. According to the different degree of formalization, we introduce three types of software documents as below.", "cite_spans": [], "ref_spans": [], "section": "Software Documents"}, {"text": "Feature requests are requirements of new features which are received by developers in order to modify the code and documents [26] . The documents of feature requests can be extracted from JIRA 6 (an issue and project tracking system). There is not a standard of the formalization of the language in the documents of feature requests. ReadMe Files are written by the developers to help other people understand the projects. Developers can author the files in different languages. ReadMe files are more formal than descriptions of feature requests. Java API documentation is quite different from the documents mentioned above. Java API documentation has their own structures and not as casual as the descriptions of feature requests. Moreover, Java API documentation contains many code elements which may obey the rules of grammar in daily expression. It is the official text provided by the community 7 . Therefore, it can be treated as formal software documents. In this work, we apply the four NLP libraries on three types of software documents to conduct tokenization and part-of-speech tagging.", "cite_spans": [{"start": 125, "end": 129, "text": "[26]", "ref_id": "BIBREF25"}], "ref_spans": [], "section": "Software Documents"}, {"text": "It is hard to predict the accuracy of NLP libraries while analyzing software documents, especially for the people which are not professional at NLP. Since the subjective selection of NLP libraries may result in threats to the validity, and random selection may obtain unexpected NLP results, we want to propose a combined method to utilize the strengths of different NLP libraries. The overall framework of our combined method is illustrated in Fig. 1 . The combined method mainly consists of two stages: document-level selection of NLP library and sentence-level overwriting. In this section, we present the details of our approach in sequence. ", "cite_spans": [], "ref_spans": [{"start": 445, "end": 451, "text": "Fig. 1", "ref_id": "FIGREF1"}], "section": "Approach"}, {"text": "For the given documents, we firstly apply NLTK, spaCy, Stanford CoreNLP and OpenNLP to produce four sets of results independently. Then we calculate the degree of overlap for each studied NLP library. The NLP library with highest degree of overlap is selected as primary library, its outputs are transfered to the next step as primary outputs. Document-level overlapping degree of a NLP library defined in our experiment is the average proportion of identical outputs (e.g., tokens or part-of-speech tags) among the results achieved by it and any other NLP library individually. The degree of overlap between NLP library i and j is calculated as", "cite_spans": [], "ref_spans": [], "section": "Document-Level Selection of NLP Library"}, {"text": "where o i,j denotes the degree of overlap between NLP library i and j, {Outputs i } and {Outputs j } are the sets of all the annotations generated by NLP library i and j, respectively. The document-level overlapping degree of library i is calculated as", "cite_spans": [], "ref_spans": [], "section": "Document-Level Selection of NLP Library"}, {"text": "where O i denotes the document-level overlapping degree of library i, and k is the total number of studied NLP libraries.", "cite_spans": [], "ref_spans": [], "section": "Document-Level Selection of NLP Library"}, {"text": "We show the process of calculating document-level overlapping degree through a case. Figure 2 shows an example of document from Java API Documentation. The document contains 14 sentences, and we list the 2 selected sentences in the figure. For the whole document, NLTK, spaCy, Stanford CoreNLP and OpenNLP identify 244, 246, 242 and 246 tokens, respectively. Table 1 presents the results of document-level overlapping degrees on part-of-speech tagging. In the table, the first column presents the studied NLP libraries, and overlapping degrees of the paired NLP libraries are shown in column 2 to 5. The last column presents the document-level overlapping degree. The data within parentheses in row 2 to 5 denotes the number of identical tags for each pair of NLP libraries. In this case, NLTK gets the highest document-level overlapping degree, so we select NLTK as primary library. The reason for choosing a primary library is shown as follows. The studied NLP libraries are all widely used and well maintained by professional teams. So the expected effectiveness of these NLP libraries is high enough to ensure that the identical overlapping results in their outputs are highly possible to be correct. The selected NLP library in this step is supposed to have the best overall effectiveness. We also record the results of each sentence separately, which will be analyzed in the next step.", "cite_spans": [], "ref_spans": [{"start": 85, "end": 93, "text": "Figure 2", "ref_id": "FIGREF2"}, {"start": 359, "end": 366, "text": "Table 1", "ref_id": "TABREF1"}], "section": "Document-Level Selection of NLP Library"}, {"text": "After document-level selection, we obtain a primary NLP library which has the best overall performance. Then we try to investigate the fine-gained improvements on sentences. Due to the complex features of software documents, the primary NLP library may not perform better than other NLP libraries on every sentence within the document.", "cite_spans": [], "ref_spans": [], "section": "Sentence-Level Overwriting"}, {"text": "To locate the potential sentences, we calculate the overlapping degree of the primary NLP library for each sentence by treating it as an individual document. We apply the same formula as the previous step on each sentence. Once the sentence-level overlapping degree of a particular sentence is less than the document-level overlapping degree of the document it belongs to, we mark it as low-overlap sentence. The outputs of primary NLP library on low-overlap sentences are highly possible to have great space for improvements. For the lowoverlap sentence, we overwrite its primary outputs with another set of results from the library which has highest overlapping degree on it. Table 2 presents the overlapping degree of sentence 10 in this above case. We can find that the primary library NLTK obtains 0.67 \u2022 , which is smaller than the document-level degree (i.e., 0.87). And Stanford CoreNLP gets the highest overlapping degree on it, so we overwrite the primary outputs on sentence 10 with the annotations generated by Stanford CoreNLP. In this case, the tag of token getter changes from adjective to noun. The NLP library may have some exclusive correctness, which usually occur on some controversial spots. If we directly use sentence-level overlapping degree to combine the results, the exclusive results will be totally overwritten. In our method, we can keep parts of the exclusive correctness, which are extracted when other NLP libraries cannot generate the same wrong results. Algorithm 1 shows the details of our combined method. O () represents the calculation of overlapping degree, and R () denotes the related results of the subject. The document-level selection of NLP library is implemented in line 2 to line 8, NLP primary denotes the primary NLP library. The sentence-level overwriting is implemented in line 9 to line 19.", "cite_spans": [], "ref_spans": [{"start": 678, "end": 685, "text": "Table 2", "ref_id": "TABREF2"}], "section": "Sentence-Level Overwriting"}, {"text": "We propose a combined method for usage of NLP libraries to obtain more accurate NLP results than individual NLP library. The outputs generated by our method may include NLP annotations from several different NLP libraries. We discuss the effectiveness of our method in this section.", "cite_spans": [], "ref_spans": [], "section": "Experiment"}, {"text": "Our experiments investigate the following research questions.", "cite_spans": [], "ref_spans": [], "section": "Research Questions"}, {"text": "-RQ1: Does the existing guideline for NLP library selection still work for the latest version of NLP libraries? -RQ2: How effective is the combined method compared with individual NLP library?", "cite_spans": [], "ref_spans": [], "section": "Research Questions"}, {"text": "To answer RQ1, we evaluate the guideline according to the comparison of NLP libraries on different documents in our study. RQ2 evaluates the effectiveness of our method compared with individual NLP library on tokenization and part-of-speech tagging. We also want to discuss the contributions of the two sources of information in our final results.", "cite_spans": [], "ref_spans": [], "section": "Research Questions"}, {"text": "To answer the above two research questions, we conduct experiments with four state-of-the-art NLP libraries and several documents from three different sources.", "cite_spans": [], "ref_spans": [], "section": "Subjects"}, {"text": "Selection of NLP Libraries. In the literature, there are a wide variety of NLP libraries used in different studies. Since our method focuses on analysis of software documents, we select several publicly available NLP libraries according to empirical results in existing work [17] . In their work, NLTK achieves the best overall results on tokenization, and spaCy performs better than other NLP libraries on part-of-speech tagging. They also make a systematic literature review of 1,350 conference papers in the area of software engineering [17] . Their results show that Stanford CoreNLP is the most frequently used NLP library. Furthermore, we add a new NLP library in our experiments, i.e., Apache OpenNLP. Apache OpenNLP is another widely used NLP library and it is proved to have a good performance on text chunking and other NLP tasks [2] . Finally, we select NLTK (version 3.4), spaCy (version 2.0.18), Stanford CoreNLP (version 3.9.2) and OpenNLP (version 1.9.1) as NLP libraries in our experiments. These NLP libraries are used as either individual NLP library or a source of outputs in the combined method. The releasing time between our studied NLP libraries and the existing work [17] is more than 2 years, which may result in different performance.", "cite_spans": [{"start": 275, "end": 279, "text": "[17]", "ref_id": "BIBREF16"}, {"start": 540, "end": 544, "text": "[17]", "ref_id": "BIBREF16"}, {"start": 840, "end": 843, "text": "[2]", "ref_id": "BIBREF1"}, {"start": 1191, "end": 1195, "text": "[17]", "ref_id": "BIBREF16"}], "ref_spans": [], "section": "Subjects"}, {"text": "Selection of Software Documents. We select several software documents from feature requests in Jira, ReadMe files on GitHub and Java API documentation randomly to evaluate the effectiveness of our method. For feature requests, we select 160 descriptions from 8 Apache projects 8 , i.e., AXIF2, CXF, Hadoop HDFS, Hadoop Common, Hadoop MapReduce, Hbase, Maven and Struts2. These projects are widely used in research of software engineering [26, 32] , and we select 20 feature requests from each project. For ReadMe files, we randomly select 20 projects on Github 9 and remove Github markdown and code snippets in the selected documents. For Java API documentations, 20 APIs of Java7 are randomly selected. The total number of tokens from the selected software documents is around 40,000.", "cite_spans": [{"start": 438, "end": 442, "text": "[26,", "ref_id": "BIBREF25"}, {"start": 443, "end": 446, "text": "32]", "ref_id": "BIBREF32"}], "ref_spans": [], "section": "Subjects"}, {"text": "Selection of NLP Tasks. We select two NLP tasks in our experiments, i.e., tokenization and part-of-speech tagging. There are two reasons for this selection. One reason is that these NLP tasks are widely used in the literatures [3, 9, 11, 14, 23, 25] . Once researchers want to analyze software documents, tokenization and part-of-speech tagging are highly possible to be applied. The other reason is that both the two tasks can produce individual outputs, which can help us to conduct a quantitative assessment easily.", "cite_spans": [{"start": 227, "end": 230, "text": "[3,", "ref_id": "BIBREF2"}, {"start": 231, "end": 233, "text": "9,", "ref_id": "BIBREF8"}, {"start": 234, "end": 237, "text": "11,", "ref_id": "BIBREF10"}, {"start": 238, "end": 241, "text": "14,", "ref_id": "BIBREF13"}, {"start": 242, "end": 245, "text": "23,", "ref_id": "BIBREF22"}, {"start": 246, "end": 249, "text": "25]", "ref_id": "BIBREF24"}], "ref_spans": [], "section": "Subjects"}, {"text": "For each NLP task, we perform the following steps:", "cite_spans": [], "ref_spans": [], "section": "Experimental Steps"}, {"text": "-To control the size of inputs from different sources, the selected 200 documents (i.e., 160 descriptions of feature requests, 20 ReadMe files and 20 API documents) are repartitioned into 100 new documents. There are about 400 tokens in each document. All the documents are used to analyze the overlapping degree of the studied techniques, and help to evaluate the existing guideline on NLP library selection. -The four NLP libraries are applied to analyze the preprocessed documents for tokenization and part-of-speech tagging, respectively. -To obtain the benchmark of correct NLP results, 20 students in our group conduct manual tokenization and part-of-speech tagging. Due to the limitation of human labor, we only collect 50 documents (i.e., about 10,000 tokens in total) to build the benchmark. We also perform a cross-validation to identify the controversial spots. The threshold value of controversy is set as 0.5 overlapping degree, i.e., more than 10 students generate different annotations on it. We obtain 82 controversial results in total, and the final results are determined through our discussion. For the other parts of studied documents, the handmade benchmarks are generated by results with the highest degree of overlap. -We apply the two-steps method on the collected 50 documents, and discuss the effectiveness of our combined method and the four NLP libraries based on the handmade benchmark generated in the above step.", "cite_spans": [], "ref_spans": [], "section": "Experimental Steps"}, {"text": "To evaluate the accuracy of tokenization and part-of-speech tagging for the studied NLP libraries, we compare the generated results with manual annotations. Table 3 and Table 4 show the results of comparison on tokenization and part-ofspeech tagging, respectively. In the tables, column 1 lists all the studied libraries, column 2 presents the number of identical results from the outputs of NLP libraries and manual benchmark, column 3 presents the total number of results generated by NLP libraries. Column 4 presents the accuracy of each studied technique, i.e., the ratio of identical results to all the results. Columns 2 to 4 present the results on feature request, columns 5 to 7 present the results on ReadMe file, and columns 8 to 10 present the results on JavaDoc. We list the results of four individual NLP libraries at rows 3 to 6. And the last two rows in the tables present the results of our combined method which will be discussed in RQ2. From the data in Table 3 and Table 4 , we have the following observations. First, Stanford CoreNLP and NLTK perform best in terms of accuracy of tokenization on software documents. This finding is different with the existing guideline [17] . In that work, NLTK performs best on all kinds of software documents. Stanford CoreNLP performs worse than NLTK. Second, OpenNLP is the most effective NLP library on part-of-speech tagging in our experiments. While in the existing work [17] , spaCy outperforms other NLP libraries on partof-speech tagging except on Readme files. Based on the findings, we can infer that the guideline of NLP library selection should be updated with the change of releasing version and given documents. Table 5 presents the data of overlapping degree. In the tables, column 1 lists all the six pairs of NLP libraries, while columns 2 to 4 and columns 6 to 8 present the percentages of identical tokens/tags to the average number of tokens/tags generated by the two NLP libraries. Column 5 and column 9 present the average percentages of identical tokens/tags for each pair of NLP libraries. The performance of studied NLP libraries is close to each other on both tokenization and part-of-speech tagging.", "cite_spans": [{"start": 1190, "end": 1194, "text": "[17]", "ref_id": "BIBREF16"}, {"start": 1432, "end": 1436, "text": "[17]", "ref_id": "BIBREF16"}], "ref_spans": [{"start": 157, "end": 164, "text": "Table 3", "ref_id": "TABREF3"}, {"start": 169, "end": 176, "text": "Table 4", "ref_id": "TABREF4"}, {"start": 972, "end": 979, "text": "Table 3", "ref_id": "TABREF3"}, {"start": 984, "end": 991, "text": "Table 4", "ref_id": "TABREF4"}, {"start": 1682, "end": 1689, "text": "Table 5", "ref_id": "TABREF5"}], "section": "RQ1 Evaluation of the Existing Guideline"}, {"text": "Comparing the results in Table 4 and Table 5 , we find that the accuracy of part-of-speech tagging is higher than the overlapping degree of the paired NLP libraries in most cases. The promotion on accuracy of all the four NLP libraries indicates that every library has its own exclusive correctness on part-of-speech tagging. This finding inspires us to combine the exclusive correctness of each NLP library to achieve an improved effectiveness. The only one exception occurs on the overlapping degree of NLTK and OpenNLP on part-of-speech tags. They obtain 88% overlapped results, that is higher than the accuracy (i.e., 87%) in Table 4 . We check the exception manually, and find that it is caused by the identical wrong results generated by the two libraries. Based on the degree of overlap in Table 5 , we apply the combined method to generate results through document-level selection and sentence-level overwriting. The final results on tokenization and part-of-speech tagging are showed in last two rows in Table 3 and Table 4 . According to the comparison of results, the combined method outperforms the studied libraries in most cases of tokenization and part-of-speech tagging. The exceptions occur in tokenization of Java API documentations by NLTK and Stanford CoreNLP. They already obtains a really high accuracy of tokenization, so the improvements from other NLP libraries cannot help too much in this case. Our combined method can achieve slight improvements on tokenization and part-of-speech tagging on the basis of stateof-the-art NLP libraries. Since the initial results of the NLP libraries already have high quality, the 2% promotion is small but meaningful. The promotion means that our combined method is better than the best selection of independent NLP library. We can use the combined method instead of any individual NLP library in the analysis of software documents.", "cite_spans": [], "ref_spans": [{"start": 25, "end": 32, "text": "Table 4", "ref_id": "TABREF4"}, {"start": 37, "end": 44, "text": "Table 5", "ref_id": "TABREF5"}, {"start": 630, "end": 637, "text": "Table 4", "ref_id": "TABREF4"}, {"start": 797, "end": 804, "text": "Table 5", "ref_id": "TABREF5"}, {"start": 1013, "end": 1032, "text": "Table 3 and Table 4", "ref_id": "TABREF3"}], "section": "RQ2 Effectiveness of the Combined Method"}, {"text": "To evaluate the contribution of two steps in our combined method, i.e., document-level selection of NLP library and sentence-level overwriting, we analyze the proportion of each source in the final correct results. In our experiments, 1% of correct tokens and 4% of correct part-of-speech tags come from the improvements in sentence-level overwriting, and the other correct results are generated by the primary NLP library in document-level selection. Documentlevel selection plays a more important role than sentence-level overwriting in terms of contribution to correct results. However, the improvements of our combined method on individual NLP library mainly come from the sentence-level overwriting. The studied NLP libraries are all high-qualified toolkits with their own exclusive correctness. This is the main reason that we do not simply treat each sentence as an individual document and combined the results with highest sentence-level overlapping degree into the results of a document. The final outputs should mainly inherit the results of a primary NLP library. In this way, we can keep some exclusive correctness in the final results.", "cite_spans": [], "ref_spans": [], "section": "Finding 2 The combined method can generally outperform the individual NLP libraries in terms of effectiveness. The promotion on accuracy is around 2%."}, {"text": "The majority of correct NLP results come from the outputs of primary NLP library. The meaningful improvements of our combined method on individual NLP library come from sentence-level overwriting.", "cite_spans": [], "ref_spans": [], "section": "Finding 3"}, {"text": "The NLP-related researchers have proposed many meaningful works for the analysis of documents [7, 10, 12, 15, 24] . These jobs are mostly designed to obtain accurate results of tokenization and part-of-speech tagging. Some works are already considered in the widely used NLP libraries [1, 8] . However, for the researchers who are not professional at NLP, the common solution for NLP tasks is using state-of-the-art NLP libraries. To solve the problem on selection of NLP libraries, we propose a combined method to utilize the strengths of different NLP libraries.", "cite_spans": [{"start": 94, "end": 97, "text": "[7,", "ref_id": "BIBREF6"}, {"start": 98, "end": 101, "text": "10,", "ref_id": "BIBREF9"}, {"start": 102, "end": 105, "text": "12,", "ref_id": "BIBREF11"}, {"start": 106, "end": 109, "text": "15,", "ref_id": "BIBREF14"}, {"start": 110, "end": 113, "text": "24]", "ref_id": "BIBREF23"}, {"start": 285, "end": 288, "text": "[1,", "ref_id": "BIBREF0"}, {"start": 289, "end": 291, "text": "8]", "ref_id": "BIBREF7"}], "ref_spans": [], "section": "Analyzing Software Artifacts with NLP Libraries"}, {"text": "There are also several works which focus on the empirical comparison of current NLP libraries. Tian and Lo [27] conduct a comparison of the effectiveness of partof-speech tagging on bug reports. In their work, Stanford CoreNLP performs better than other toolkits. To investigate the impacts of NLP toolkits on analyzing different texts, Pinto et al. [19] compared the results of tokenization and another three NLP tasks achieved by four NLP libraries. Olney et al. [16] investigated the accuracy of 9 part-of-speech taggers on more than 200 source code identifiers Omran et al. [17] compared the results of tokenization and part-of-speech tags achieved by four NLP libraries. Compared to their work, we select three types of software documents, along with four publicly available NLP libraries in this paper. We aim to check the effectiveness of the existing guideline, rather than the comparison of current NLP libraries. According to our results, each NLP library has its own exclusive results. This finding inspires us to investigate a combined method.", "cite_spans": [{"start": 107, "end": 111, "text": "[27]", "ref_id": "BIBREF26"}, {"start": 350, "end": 354, "text": "[19]", "ref_id": "BIBREF18"}, {"start": 465, "end": 469, "text": "[16]", "ref_id": "BIBREF15"}, {"start": 578, "end": 582, "text": "[17]", "ref_id": "BIBREF16"}], "ref_spans": [], "section": "Empirical Study on NLP Libraries"}, {"text": "This paper evaluates the existing guideline on NLP library selection with 4 publicly available NLP libraries and 200 documents. The results report that the guideline should be updated continuously and each library has its own exclusive results. Based on these findings, we turn to investigate a combined method to utilize the strengths of different libraries. The evaluation confirms that our combined method can outperform any individual NLP library in the experiments. In future, we will conduct the study on more NLP tasks with additional NLP libraries and different software documents to improve the combined method.", "cite_spans": [], "ref_spans": [], "section": "Conclusion"}], "bib_entries": {"BIBREF0": {"ref_id": "b0", "title": "Natural language parsing of program element names for concept extraction", "authors": [{"first": "S", "middle": ["L"], "last": "Abebe", "suffix": ""}, {"first": "P", "middle": [], "last": "Tonella", "suffix": ""}], "year": 2010, "venue": "Proceedings of the 18th IEEE International Conference on Program Comprehension", "volume": "", "issn": "", "pages": "156--159", "other_ids": {}}, "BIBREF1": {"ref_id": "b1", "title": "Change impact analysis for natural language requirements: an NLP approach", "authors": [{"first": "C", "middle": [], "last": "Arora", "suffix": ""}, {"first": "M", "middle": [], "last": "Sabetzadeh", "suffix": ""}, {"first": "A", "middle": [], "last": "Goknil", "suffix": ""}, {"first": "L", "middle": ["C"], "last": "Briand", "suffix": ""}, {"first": "F", "middle": [], "last": "Zimmer", "suffix": ""}], "year": 2015, "venue": "Proceedings of the 23rd IEEE International Requirements Engineering Conference", "volume": "", "issn": "", "pages": "6--15", "other_ids": {}}, "BIBREF2": {"ref_id": "b2", "title": "Exploring API method parameter recommendations", "authors": [{"first": "M", "middle": [], "last": "Asaduzzaman", "suffix": ""}, {"first": "C", "middle": ["K"], "last": "Roy", "suffix": ""}, {"first": "S", "middle": [], "last": "Monir", "suffix": ""}, {"first": "K", "middle": ["A"], "last": "Schneider", "suffix": ""}], "year": 2015, "venue": "Proceedings of IEEE International Conference on Software Maintenance and Evolution", "volume": "", "issn": "", "pages": "271--280", "other_ids": {}}, "BIBREF3": {"ref_id": "b3", "title": "Reformulation of natural language queries on source code base using NLP techniques", "authors": [{"first": "B", "middle": ["P"], "last": "Swathi", "suffix": ""}, {"first": "R", "middle": [], "last": "Anju", "suffix": ""}], "year": 2019, "venue": "Int. J. Adv. Comput. Technol", "volume": "8", "issn": "2", "pages": "3047--3052", "other_ids": {}}, "BIBREF4": {"ref_id": "b4", "title": "A simple rule-based part of speech tagger", "authors": [{"first": "E", "middle": [], "last": "Brill", "suffix": ""}], "year": 1992, "venue": "Proceedings of the 3rd Applied Natural Language Processing Conference", "volume": "", "issn": "", "pages": "152--155", "other_ids": {}}, "BIBREF5": {"ref_id": "b5", "title": "Toward accurate link between code and software documentation", "authors": [{"first": "Y", "middle": [], "last": "Cao", "suffix": ""}, {"first": "Y", "middle": [], "last": "Zou", "suffix": ""}, {"first": "Y", "middle": [], "last": "Luo", "suffix": ""}, {"first": "B", "middle": [], "last": "Xie", "suffix": ""}, {"first": "J", "middle": [], "last": "Zhao", "suffix": ""}], "year": 2018, "venue": "Sci. China Inf. Sci", "volume": "61", "issn": "5", "pages": "1--15", "other_ids": {"DOI": ["10.1007/s11432-017-9402-3"]}}, "BIBREF6": {"ref_id": "b6", "title": "Improving IR-based traceability recovery via noun-based indexing of software artifacts", "authors": [{"first": "G", "middle": [], "last": "Capobianco", "suffix": ""}, {"first": "A", "middle": ["D"], "last": "Lucia", "suffix": ""}, {"first": "R", "middle": [], "last": "Oliveto", "suffix": ""}, {"first": "A", "middle": [], "last": "Panichella", "suffix": ""}, {"first": "S", "middle": [], "last": "Panichella", "suffix": ""}], "year": 2013, "venue": "J. Softw.: Evol. Process", "volume": "25", "issn": "7", "pages": "743--762", "other_ids": {}}, "BIBREF7": {"ref_id": "b7", "title": "Part-of-speech tagging for Twitter: annotation, features, and experiments", "authors": [{"first": "K", "middle": [], "last": "Gimpel", "suffix": ""}], "year": 2011, "venue": "Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics: Human Language Technologies", "volume": "", "issn": "", "pages": "42--47", "other_ids": {}}, "BIBREF8": {"ref_id": "b8", "title": "DeepFix: fixing common C language errors by deep learning", "authors": [{"first": "R", "middle": [], "last": "Gupta", "suffix": ""}, {"first": "S", "middle": [], "last": "Pal", "suffix": ""}, {"first": "A", "middle": [], "last": "Kanade", "suffix": ""}, {"first": "S", "middle": ["K"], "last": "Shevade", "suffix": ""}], "year": 2017, "venue": "Proceedings of the 31st AAAI Conference on Artificial Intelligence", "volume": "", "issn": "", "pages": "1345--1351", "other_ids": {}}, "BIBREF9": {"ref_id": "b9", "title": "Part-of-speech tagging of program identifiers for improved text-based software engineering tools", "authors": [{"first": "S", "middle": [], "last": "Gupta", "suffix": ""}, {"first": "S", "middle": [], "last": "Malik", "suffix": ""}, {"first": "L", "middle": ["L"], "last": "Pollock", "suffix": ""}, {"first": "K", "middle": [], "last": "Vijay-Shanker", "suffix": ""}], "year": 2013, "venue": "Proceedings of the 21st IEEE International Conference on Program Comprehension", "volume": "", "issn": "", "pages": "3--12", "other_ids": {}}, "BIBREF10": {"ref_id": "b10", "title": "Deep code comment generation", "authors": [{"first": "X", "middle": [], "last": "Hu", "suffix": ""}, {"first": "G", "middle": [], "last": "Li", "suffix": ""}, {"first": "X", "middle": [], "last": "Xia", "suffix": ""}, {"first": "D", "middle": [], "last": "Lo", "suffix": ""}, {"first": "Z", "middle": [], "last": "Jin", "suffix": ""}], "year": 2018, "venue": "Proceedings of the 26th Conference on Program Comprehension", "volume": "", "issn": "", "pages": "200--210", "other_ids": {}}, "BIBREF11": {"ref_id": "b11", "title": "A cascaded linear model for joint Chinese word segmentation and part-of-speech tagging", "authors": [{"first": "W", "middle": [], "last": "Jiang", "suffix": ""}, {"first": "L", "middle": [], "last": "Huang", "suffix": ""}, {"first": "Q", "middle": [], "last": "Liu", "suffix": ""}, {"first": "Y", "middle": [], "last": "L\u00fc", "suffix": ""}], "year": 2008, "venue": "Proceedings of the 46th Annual Meeting of the Association for Computational Linguistics", "volume": "", "issn": "", "pages": "897--904", "other_ids": {}}, "BIBREF12": {"ref_id": "b12", "title": "Automatic quality assessment of source code comments: the JavadocMiner", "authors": [{"first": "N", "middle": [], "last": "Khamis", "suffix": ""}, {"first": "R", "middle": [], "last": "Witte", "suffix": ""}, {"first": "J", "middle": [], "last": "Rilling", "suffix": ""}], "year": 2010, "venue": "NLDB 2010", "volume": "6177", "issn": "", "pages": "68--79", "other_ids": {"DOI": ["10.1007/978-3-642-13881-2_7"]}}, "BIBREF13": {"ref_id": "b13", "title": "FaCoY: a code-to-code search engine", "authors": [{"first": "K", "middle": [], "last": "Kim", "suffix": ""}], "year": 2018, "venue": "Proceedings of the 40th International Conference on Software Engineering", "volume": "", "issn": "", "pages": "946--957", "other_ids": {}}, "BIBREF14": {"ref_id": "b14", "title": "Minority language Twitter: part-of-speech tagging and analysis of Irish tweets", "authors": [{"first": "T", "middle": [], "last": "Lynn", "suffix": ""}, {"first": "K", "middle": ["P"], "last": "Scannell", "suffix": ""}, {"first": "E", "middle": [], "last": "Maguire", "suffix": ""}], "year": 2015, "venue": "Proceedings of the Workshop on Noisy User-generated Text", "volume": "", "issn": "", "pages": "1--8", "other_ids": {}}, "BIBREF15": {"ref_id": "b15", "title": "Part of speech tagging java method names", "authors": [{"first": "W", "middle": [], "last": "Olney", "suffix": ""}, {"first": "E", "middle": [], "last": "Hill", "suffix": ""}, {"first": "C", "middle": [], "last": "Thurber", "suffix": ""}, {"first": "B", "middle": [], "last": "Lemma", "suffix": ""}], "year": 2016, "venue": "Proceedings of IEEE International Conference on Software Maintenance and Evolution", "volume": "", "issn": "", "pages": "483--487", "other_ids": {}}, "BIBREF16": {"ref_id": "b16", "title": "Choosing an NLP library for analyzing software documentation: a systematic literature review and a series of experiments", "authors": [{"first": "Al", "middle": [], "last": "Omran", "suffix": ""}, {"first": "F", "middle": ["N A"], "last": "Treude", "suffix": ""}, {"first": "C", "middle": [], "last": "", "suffix": ""}], "year": 2017, "venue": "Proceedings of the 14th International Conference on Mining Software Repositories", "volume": "", "issn": "", "pages": "187--197", "other_ids": {}}, "BIBREF17": {"ref_id": "b17", "title": "A universal part-of-speech tagset", "authors": [{"first": "S", "middle": [], "last": "Petrov", "suffix": ""}, {"first": "D", "middle": [], "last": "Das", "suffix": ""}, {"first": "R", "middle": [], "last": "Mcdonald", "suffix": ""}], "year": 2011, "venue": "Comput. Sci", "volume": "1", "issn": "3", "pages": "2089--2096", "other_ids": {}}, "BIBREF18": {"ref_id": "b18", "title": "Comparing the performance of different NLP toolkits in formal and social media text", "authors": [{"first": "A", "middle": ["M"], "last": "Pinto", "suffix": ""}, {"first": "H", "middle": ["G"], "last": "Oliveira", "suffix": ""}, {"first": "A", "middle": ["O"], "last": "Alves", "suffix": ""}], "year": 2016, "venue": "Proceedings of the 5th Symposium on Languages, Applications and Technologies", "volume": "3", "issn": "", "pages": "1--3", "other_ids": {}}, "BIBREF19": {"ref_id": "b19", "title": "Extracting core requirements for software product lines", "authors": [{"first": "I", "middle": [], "last": "Reinhartz-Berger", "suffix": ""}, {"first": "M", "middle": [], "last": "Kemelman", "suffix": ""}], "year": 2019, "venue": "Require. Eng", "volume": "25", "issn": "1", "pages": "47--65", "other_ids": {"DOI": ["10.1007/s00766-018-0307-0"]}}, "BIBREF20": {"ref_id": "b20", "title": "Semantics-based code search", "authors": [{"first": "S", "middle": ["P"], "last": "Reiss", "suffix": ""}], "year": 2009, "venue": "Proceedings of the 31st International Conference on Software Engineering", "volume": "", "issn": "", "pages": "243--253", "other_ids": {}}, "BIBREF21": {"ref_id": "b21", "title": "Security vulnerability information service with natural language query support", "authors": [{"first": "C", "middle": [], "last": "Rodriguez", "suffix": ""}, {"first": "S", "middle": [], "last": "Zamanirad", "suffix": ""}, {"first": "R", "middle": [], "last": "Nouri", "suffix": ""}, {"first": "K", "middle": [], "last": "Darabal", "suffix": ""}, {"first": "B", "middle": [], "last": "Benatallah", "suffix": ""}, {"first": "M", "middle": [], "last": "Al-Banna", "suffix": ""}], "year": 2019, "venue": "Advanced Information Systems Engineering", "volume": "", "issn": "", "pages": "497--512", "other_ids": {}}, "BIBREF22": {"ref_id": "b22", "title": "Stepwise API usage assistance using n-gram language models", "authors": [{"first": "A", "middle": ["L"], "last": "Santos", "suffix": ""}, {"first": "G", "middle": [], "last": "Prendi", "suffix": ""}, {"first": "H", "middle": [], "last": "Sousa", "suffix": ""}, {"first": "R", "middle": [], "last": "Ribeiro", "suffix": ""}], "year": 2017, "venue": "J. Syst. Softw", "volume": "131", "issn": "", "pages": "461--474", "other_ids": {}}, "BIBREF23": {"ref_id": "b23", "title": "Why so complicated? Simple term filtering and weighting for location-based bug report assignment recommendation", "authors": [{"first": "R", "middle": [], "last": "Shokripour", "suffix": ""}, {"first": "J", "middle": [], "last": "Anvik", "suffix": ""}, {"first": "Z", "middle": ["M"], "last": "Kasirun", "suffix": ""}, {"first": "S", "middle": [], "last": "Zamani", "suffix": ""}], "year": 2013, "venue": "Proceedings of the 10th Working Conference on Mining Software Repositories", "volume": "", "issn": "", "pages": "2--11", "other_ids": {}}, "BIBREF24": {"ref_id": "b24", "title": "WebAPIRec: recommending web apis to software projects via personalized ranking", "authors": [{"first": "F", "middle": [], "last": "Thung", "suffix": ""}, {"first": "R", "middle": ["J"], "last": "Oentaryo", "suffix": ""}, {"first": "D", "middle": [], "last": "Lo", "suffix": ""}, {"first": "Y", "middle": [], "last": "Tian", "suffix": ""}], "year": 2017, "venue": "IEEE Trans. Emerg. Top. Comput. Intell", "volume": "1", "issn": "3", "pages": "145--156", "other_ids": {}}, "BIBREF25": {"ref_id": "b25", "title": "Automatic recommendation of API methods from feature requests", "authors": [{"first": "F", "middle": [], "last": "Thung", "suffix": ""}, {"first": "S", "middle": [], "last": "Wang", "suffix": ""}, {"first": "D", "middle": [], "last": "Lo", "suffix": ""}, {"first": "J", "middle": ["L"], "last": "Lawall", "suffix": ""}], "year": 2013, "venue": "Proceedings of the 28th IEEE/ACM International Conference on Automated Software Engineering", "volume": "", "issn": "", "pages": "290--300", "other_ids": {}}, "BIBREF26": {"ref_id": "b26", "title": "A comparative study on the effectiveness of part-of-speech tagging techniques on bug reports", "authors": [{"first": "Y", "middle": [], "last": "Tian", "suffix": ""}, {"first": "D", "middle": [], "last": "Lo", "suffix": ""}], "year": 2015, "venue": "Proceedings of the 22nd IEEE International Conference on Software Analysis, Evolution, and Reengineering", "volume": "", "issn": "", "pages": "570--574", "other_ids": {}}, "BIBREF27": {"ref_id": "b27", "title": "Application of natural language processing in object oriented software development", "authors": [{"first": "A", "middle": [], "last": "Tripathy", "suffix": ""}, {"first": "S", "middle": ["K"], "last": "Rath", "suffix": ""}], "year": 2014, "venue": "Proceedings of International Conference on Recent Trends in Information Technology", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF28": {"ref_id": "b28", "title": "Extracting declarative process models from natural language", "authors": [{"first": "H", "middle": [], "last": "Van Der Aa", "suffix": ""}, {"first": "C", "middle": [], "last": "Di Ciccio", "suffix": ""}, {"first": "H", "middle": [], "last": "Leopold", "suffix": ""}, {"first": "H", "middle": ["A"], "last": "Reijers", "suffix": ""}], "year": 2019, "venue": "CAiSE 2019", "volume": "11483", "issn": "", "pages": "365--382", "other_ids": {"DOI": ["10.1007/978-3-030-21290-2_23"]}}, "BIBREF29": {"ref_id": "b29", "title": "Tokenization as the initial phase in NLP", "authors": [{"first": "J", "middle": ["J"], "last": "Webster", "suffix": ""}, {"first": "C", "middle": [], "last": "Kit", "suffix": ""}], "year": 1992, "venue": "Proceedings of the 14th International Conference on Computational Linguistics", "volume": "", "issn": "", "pages": "1106--1110", "other_ids": {}}, "BIBREF30": {"ref_id": "b30", "title": "Intelligent software development environments: integrating natural language processing with the eclipse platform", "authors": [{"first": "R", "middle": [], "last": "Witte", "suffix": ""}, {"first": "B", "middle": [], "last": "Sateli", "suffix": ""}, {"first": "N", "middle": [], "last": "Khamis", "suffix": ""}, {"first": "J", "middle": [], "last": "Rilling", "suffix": ""}], "year": null, "venue": "AI 2011", "volume": "6657", "issn": "", "pages": "408--419", "other_ids": {}}, "BIBREF32": {"ref_id": "b32", "title": "MULAPI: improving API method recommendation with API usage location", "authors": [{"first": "C", "middle": [], "last": "Xu", "suffix": ""}, {"first": "X", "middle": [], "last": "Sun", "suffix": ""}, {"first": "B", "middle": [], "last": "Li", "suffix": ""}, {"first": "X", "middle": [], "last": "Lu", "suffix": ""}, {"first": "H", "middle": [], "last": "Guo", "suffix": ""}], "year": 2018, "venue": "J. Syst. Softw", "volume": "142", "issn": "", "pages": "195--205", "other_ids": {}}}, "ref_entries": {"FIGREF0": {"text": "Springer Nature Switzerland AG 2020 S. Dustdar et al. (Eds.): CAiSE 2020, LNCS 12127, pp. 515-529, 2020. https://doi.org/10.1007/978-3-030-49435-3_32", "latex": null, "type": "figure"}, "FIGREF1": {"text": "Overall framework of the combined method", "latex": null, "type": "figure"}, "FIGREF2": {"text": "Document from JavaDoc of javax.management.openmbean", "latex": null, "type": "figure"}, "FIGREF3": {"text": "Combined usage of NLP libraries Input : Given Document D, candidate NLP libraries {NLP } Output: Combined NLP results 1 InitialResultsSet{InitialR} \u2190 Analyze(NLP , D); 2 for each NLPi \u2208 {NLP } do 3 for each (Ri, Rj ) \u2208 InitialR do 4 Document-level overlapping degree O(dij ) \u2190 Compare((Ri, Rj ) ; 5 end 6 O(di) \u2190 |{NLP }|\u22121 j=1 O(dij ) / (|{NLP }| \u2212 1) ; 7 end 8 NLPprimary \u2190 {NLPi, max (O(di))} ; 9 for each d \u2208 {D} do 10 for each s \u2208 {d} do 11 for each NLP k \u2208 {{NLP }-NLPprimary} do 12 O(s primary,k ) \u2190 Compare((Rprimary, R k ) ; 13 end 14 O(sprimary) \u2190 |{NLP }|\u22121 k=1 O(s primary,k ) / (|{NLP }| \u2212 1) ; 15 if O(sprimary) < O(d) then 16 {Simprove} \u2190 (s, Rs); 17 end 18 end 19 end 20 F inalResults \u2190 Combine(Rprimary, {Simprove}); 21 return F inalResults", "latex": null, "type": "figure"}, "TABREF1": {"text": "Document-level overlapping degree of NLP libraries on POS tagging", "latex": null, "type": "table", "html": "<html><body><table><tr><td>Document </td><td>NLTK (244) </td><td>spaCy (246) </td><td>CoreNLP (242) </td><td>OpenNLP (246) </td><td>Overlapping degree\n</td></tr><tr><td>NLTK </td><td>- </td><td>0.89 (218) </td><td>0.84 (203) </td><td>0.87 (213) </td><td>0.87\n</td></tr><tr><td>spaCy </td><td>0.89 (218) </td><td>- </td><td>0.82 (199) </td><td>0.87 (214) </td><td>0.86\n</td></tr><tr><td>CoreNLP </td><td>0.84 (203) </td><td>0.82 (199) </td><td>- </td><td>0.81 (197) </td><td>0.82\n</td></tr><tr><td>OpenNLP </td><td>0.87 (213) </td><td>0.87 (214) </td><td>0.81 (197) </td><td>- </td><td>0.85\n</td></tr></table></body></html>"}, "TABREF2": {"text": "Sentence-level overlapping degree of NLP libraries on POS tagging", "latex": null, "type": "table", "html": "<html><body><table><tr><td>Sentence 10 </td><td>NLTK (11) </td><td>spaCy (11) </td><td>CoreNLP (11) </td><td>OpenNLP (11) </td><td>Overlapping degree\n</td></tr><tr><td>NLTK </td><td>- </td><td>0.64 (7) </td><td>0.73 (8) </td><td>0.64 (7) </td><td>0.67\n</td></tr><tr><td>spaCy </td><td>0.64 (7) </td><td>- </td><td>0.82 (9) </td><td>0.64 (7) </td><td>0.70\n</td></tr><tr><td>CoreNLP </td><td>0.73 (8) </td><td>0.82 (9) </td><td>- </td><td>0.73 (8) </td><td>0.76\n</td></tr><tr><td>OpenNLP </td><td>0.64 (7) </td><td>0.64 (7) </td><td>0.73 (8) </td><td>- </td><td>0.67\n</td></tr></table></body></html>"}, "TABREF3": {"text": "Comparison on tokens (NLP libraries vs. Manual benchmark)", "latex": null, "type": "table", "html": "<html><body><table><tr><td>\u00a0</td><td>Feature request </td><td>\u00a0</td><td>ReadMe file </td><td>\u00a0</td><td>JavaDoc\n</td><td>\u00a0</td><td>\u00a0</td></tr><tr><td>\u00a0</td><td>Identical </td><td>All </td><td>ACC </td><td>Identical </td><td>All </td><td>ACC </td><td>Identical </td><td>All </td><td>ACC\n</td></tr><tr><td>NLTK </td><td>2484 </td><td>2545 </td><td>98% </td><td>3154 </td><td>3238 </td><td>98% </td><td>4209 </td><td>4256 </td><td>99%\n</td></tr><tr><td>spaCy </td><td>2453 </td><td>2580 </td><td>96% </td><td>3113 </td><td>3335 </td><td>95% </td><td>4188 </td><td>4348 </td><td>97%\n</td></tr><tr><td>Stanford CoreNLP </td><td>2478 </td><td>2529 </td><td>98% </td><td>3170 </td><td>3243 </td><td>98% </td><td>4222 </td><td>4245 </td><td>99%\n</td></tr><tr><td>OpenNLP </td><td>2382 </td><td>2535 </td><td>94% </td><td>3080 </td><td>3218 </td><td>96% </td><td>4105 </td><td>4221 </td><td>97%\n</td></tr><tr><td>Combined method </td><td>2496 </td><td>2543 </td><td>99% </td><td>3171 </td><td>3215 </td><td>99% </td><td>4219 </td><td>4243 </td><td>99%\n</td></tr><tr><td>\u00a0</td><td>\u00a0</td><td>\u00a0</td><td>\u00a0</td><td>\u00a0</td><td>Overall improvement </td><td>1% </td><td>1% </td><td>0%\n</td></tr></table></body></html>"}, "TABREF4": {"text": "Comparison on POS tags (NLP libraries vs. Manual benchmark)", "latex": null, "type": "table", "html": "<html><body><table><tr><td>\u00a0</td><td>Feature request </td><td>\u00a0</td><td>ReadMe file </td><td>\u00a0</td><td>JavaDoc\n</td><td>\u00a0</td><td>\u00a0</td></tr><tr><td>\u00a0</td><td>Identical </td><td>All </td><td>ACC </td><td>Identical </td><td>All </td><td>ACC </td><td>Identical </td><td>All </td><td>ACC\n</td></tr><tr><td>NLTK </td><td>2165 </td><td>2545 </td><td>85% </td><td>2807 </td><td>3238 </td><td>87% </td><td>3701 </td><td>4256 </td><td>87%\n</td></tr><tr><td>spaCy </td><td>2241 </td><td>2580 </td><td>88% </td><td>2851 </td><td>3335 </td><td>87% </td><td>3732 </td><td>4348 </td><td>87%\n</td></tr><tr><td>Stanford CoreNLP </td><td>2123 </td><td>2529 </td><td>84% </td><td>2717 </td><td>3243 </td><td>84% </td><td>3549 </td><td>4245 </td><td>84%\n</td></tr><tr><td>OpenNLP </td><td>2197 </td><td>2535 </td><td>87% </td><td>2842 </td><td>3218 </td><td>89% </td><td>3665 </td><td>4221 </td><td>87%\n</td></tr><tr><td>Combined method </td><td>2308 </td><td>2528 </td><td>91% </td><td>2931 </td><td>3227 </td><td>91% </td><td>3824 </td><td>4252 </td><td>90%\n</td></tr><tr><td>\u00a0</td><td>\u00a0</td><td>\u00a0</td><td>\u00a0</td><td>\u00a0</td><td>Overall Improvement </td><td>3% </td><td>2% </td><td>3%\n</td></tr></table></body></html>"}, "TABREF5": {"text": "Degree of overlap on tokens and part-of-speech tags", "latex": null, "type": "table", "html": "<html><body><table><tr><td>\u00a0</td><td>Tokens </td><td>\u00a0</td><td>\u00a0</td><td>\u00a0</td><td>Part-of-speech tags\n</td><td>\u00a0</td><td>\u00a0</td></tr><tr><td>\u00a0</td><td>Feature request\n</td><td>ReadMe </td><td>JavaDoc </td><td>Avg </td><td>Feature Request </td><td>ReadMe </td><td>JavaDoc </td><td>Avg\n</td></tr><tr><td>NLTK vs. spaCy </td><td>92% </td><td>95% </td><td>97% </td><td>95% </td><td>79% </td><td>84% </td><td>85% </td><td>83%\n</td></tr><tr><td>NLTK vs. CoreNLP </td><td>95% </td><td>88% </td><td>99% </td><td>94% </td><td>75% </td><td>71% </td><td>82% </td><td>76%\n</td></tr><tr><td>NLTK vs. OpenNLP </td><td>93% </td><td>94% </td><td>98% </td><td>95% </td><td>82% </td><td>84% </td><td>88% </td><td>85%\n</td></tr><tr><td>spaCy vs. CoreNLP </td><td>89% </td><td>94% </td><td>97% </td><td>94% </td><td>74% </td><td>79% </td><td>83% </td><td>79%\n</td></tr><tr><td>spaCy vs. OpenNLP </td><td>89% </td><td>94% </td><td>96% </td><td>93% </td><td>80% </td><td>85% </td><td>86% </td><td>84%\n</td></tr><tr><td>CoreN vs. OpenNLP </td><td>90% </td><td>87% </td><td>98% </td><td>92% </td><td>77% </td><td>75% </td><td>84% </td><td>79%\n</td></tr></table></body></html>"}}, "back_matter": []}