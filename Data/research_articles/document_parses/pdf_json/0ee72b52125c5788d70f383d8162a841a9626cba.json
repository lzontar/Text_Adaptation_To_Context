{"paper_id": "0ee72b52125c5788d70f383d8162a841a9626cba", "metadata": {"title": "Mutation Operators for Large Scale Data Processing Programs in Spark", "authors": [{"first": "Jo\u00e3o", "middle": [], "last": "Batista", "suffix": "", "affiliation": {}, "email": ""}, {"first": "Souza", "middle": [], "last": "Neto", "suffix": "", "affiliation": {"laboratory": "", "institution": "Federal University of Rio Grande do Norte", "location": {"settlement": "Natal", "country": "Brazil"}}, "email": ""}, {"first": "Anamaria", "middle": ["Martins"], "last": "Moreira", "suffix": "", "affiliation": {"laboratory": "", "institution": "Federal University of Rio de Janeiro", "location": {"settlement": "Rio de Janeiro", "country": "Brazil"}}, "email": "anamaria@dcc.ufrj.br"}, {"first": "Genoveva", "middle": [], "last": "Vargas-Solar", "suffix": "", "affiliation": {"laboratory": "University Grenoble Alpes, CNRS, Grenoble INP, LIG-LAFMIA", "institution": "", "location": {"settlement": "Grenoble", "country": "France"}}, "email": "genoveva.vargas@imag.fr"}, {"first": "Martin", "middle": ["Alejandro"], "last": "Musicante", "suffix": "", "affiliation": {"laboratory": "", "institution": "Federal University of Rio Grande do Norte", "location": {"settlement": "Natal", "country": "Brazil"}}, "email": ""}]}, "abstract": [{"text": "This paper proposes a mutation testing approach for big data processing programs that follow a data flow model, such as those implemented on top of Apache Spark. Mutation testing is a fault-based technique that relies on fault simulation by modifying programs, to create faulty versions called mutants. Mutant creation is carried on by operators able to simulate specific and well identified faults. A testing process must be able to signal faults within mutants and thereby avoid having ill behaviours within a program. We propose a set of mutation operators designed for Spark programs characterized by a data flow and data processing operations. These operators model changes in the data flow and operations, to simulate faults that take into account Spark program characteristics. We performed manual experiments to evaluate the proposed mutation operators in terms of cost and effectiveness. Thereby, we show that mutation operators can contribute to the testing process, in the construction of reliable Spark programs.", "cite_spans": [], "ref_spans": [], "section": "Abstract"}], "body_text": [{"text": "The intrinsic characteristics of data and associated processing environments introduce challenges to the development of big data processing programs. These programs need to deal with data Volume; Velocity in which data is produced; Variety of representation and Veracity level of the data. These technical characteristics, allied to the Value of the knowledge obtained by processing big data (the five V's [18] ), have contributed to the development of systems and frameworks adapted to big data processing.", "cite_spans": [{"start": 406, "end": 410, "text": "[18]", "ref_id": "BIBREF18"}], "ref_spans": [], "section": "Introduction"}, {"text": "Existing frameworks adopt either control flow [4, 6] or data flow approaches [3, 26, 28] . In both cases, frameworks provide a complete and general execution environment that automates lower level tasks (processing and data distribution and fault tolerance), allowing developers to (mostly) concentrate on the algorithmic aspects of big data programs.", "cite_spans": [{"start": 46, "end": 49, "text": "[4,", "ref_id": "BIBREF3"}, {"start": 50, "end": 52, "text": "6]", "ref_id": "BIBREF5"}, {"start": 77, "end": 80, "text": "[3,", "ref_id": "BIBREF2"}, {"start": 81, "end": 84, "text": "26,", "ref_id": "BIBREF26"}, {"start": 85, "end": 88, "text": "28]", "ref_id": "BIBREF28"}], "ref_spans": [], "section": "Introduction"}, {"text": "Reliability of big data processing programs becomes important, due to the fine-grain tuning required, regarding both the programming logic and particularly, their extensive use of computational resources [12] . This introduces the need to verify and validate programs before running them in production in a costly distributed environment. In this context, software testing techniques emerge as important and key tools. Testing big data processing programs is an open issue that is receiving increasing attention [5, 20] . There exist only few works on functional testing of big data programs, most of them address testing of programs built using control flow based programming models like MapReduce [20] .", "cite_spans": [{"start": 204, "end": 208, "text": "[12]", "ref_id": "BIBREF12"}, {"start": 512, "end": 515, "text": "[5,", "ref_id": "BIBREF4"}, {"start": 516, "end": 519, "text": "20]", "ref_id": "BIBREF20"}, {"start": 699, "end": 703, "text": "[20]", "ref_id": "BIBREF20"}], "ref_spans": [], "section": "Introduction"}, {"text": "This paper addresses big data programming testing by exploring the application of Mutation Testing on Apache Spark programs. Mutation testing is a fault-based technique that explores the creation of erroneous versions of a program, called mutants, to generate and evaluate tests. Mutants are created by applying modification rules, called mutation operators, that define how to create faulty versions from a program. In this paper, we present a set of mutation operators based on the data flow model of Apache Spark programs. We manually applied our mutation operators in an experiment to show the feasibility of mutation testing in Spark programs and to make a preliminary assessment of application costs and effectiveness of the proposed mutation operators. The results of these experiments agree with the preliminary results obtained using a prototype, currently under development 1 .", "cite_spans": [{"start": 884, "end": 885, "text": "1", "ref_id": "BIBREF0"}], "ref_spans": [], "section": "Introduction"}, {"text": "This paper is organized as follows: Sect. 2 describes works that have addressed some aspects of big data program testing. Section 3 introduces the main concepts of mutation testing adopted in our work. Section 4 introduces Apache Spark and presents the set of mutation operators that we designed for Spark programs. Section 5 describes our experimental setting and discusses results. Section 6 concludes the paper and discusses future work.", "cite_spans": [], "ref_spans": [], "section": "Introduction"}, {"text": "The emerging need of processing big data together with the democratization of access to computing power has led to the proposal of environments providing solutions that ease the development of big data processing programs at scale. Even if these environments prevent programmers from dealing with the burden of low level control issues (e.g. fault tolerance, data and process distribution), programming must still consider several details regarding data flow (e.g., explicit data caching, exchange, sharing requests). Thus, testing methodologies must be proposed considering the particular characteristics of big data.", "cite_spans": [], "ref_spans": [], "section": "Related Work"}, {"text": "The testing of big data processing programs has gained interest as pointed out in [5] and [20] . Most work has focused on performance testing since performance is a major concern in a big data environment given the computational resources required [20] . Regarding functional testing, few works have been done, most of them being concentrated on MapReduce [20] , leaving an open research area for testing big data programs on other models and technologies.", "cite_spans": [{"start": 82, "end": 85, "text": "[5]", "ref_id": "BIBREF4"}, {"start": 90, "end": 94, "text": "[20]", "ref_id": "BIBREF20"}, {"start": 248, "end": 252, "text": "[20]", "ref_id": "BIBREF20"}, {"start": 356, "end": 360, "text": "[20]", "ref_id": "BIBREF20"}], "ref_spans": [], "section": "Related Work"}, {"text": "The work in [8] applies symbolic execution to search for test cases and data. It proposes to encode MapReduce correctness conditions into symbolic program constraints which are then used to derive the test cases and test data. The proposal in [16] applies a similar technique to test Pig Latin [22] programs. The MRFlow technique in [19] builds a data flow graph to define the paths to test and uses graph-based testing [1] to search for test cases in MapReduce.", "cite_spans": [{"start": 12, "end": 15, "text": "[8]", "ref_id": "BIBREF7"}, {"start": 243, "end": 247, "text": "[16]", "ref_id": "BIBREF16"}, {"start": 294, "end": 298, "text": "[22]", "ref_id": "BIBREF22"}, {"start": 333, "end": 337, "text": "[19]", "ref_id": "BIBREF19"}, {"start": 420, "end": 423, "text": "[1]", "ref_id": "BIBREF0"}], "ref_spans": [], "section": "Related Work"}, {"text": "Concerning data flow systems, most of the them support unit test execution for their programs. The work in [14] provides a framework that supports execution of unit testing and property checking of Spark programs. The tool does not provide support for the design of test cases, which is a critical part of the testing process. The area is still lacking techniques and tools that exploit the characteristics of big data processing programs, showing that more research needs to be done. Mutation testing provides criteria for the systematic design of test cases. In this context, our work explores both the design and application of mutation testing in Spark.", "cite_spans": [{"start": 107, "end": 111, "text": "[14]", "ref_id": "BIBREF14"}], "ref_spans": [], "section": "Related Work"}, {"text": "Mutation testing is a fault-based technique based on creating variants of a program, called mutants, simulating common faults inserted through simple modifications to the original program [1] . Mutants can be used to design test cases that identify the simulated faults or to assess the quality of an already implemented test set by looking if it can identify erroneous behaviors generated by the mutants. Different studies [11, 21, 25] have shown the effectiveness of mutation testing by comparing it with other testing criteria and techniques.", "cite_spans": [{"start": 188, "end": 191, "text": "[1]", "ref_id": "BIBREF0"}, {"start": 424, "end": 428, "text": "[11,", "ref_id": "BIBREF11"}, {"start": 429, "end": 432, "text": "21,", "ref_id": "BIBREF21"}, {"start": 433, "end": 436, "text": "25]", "ref_id": "BIBREF25"}], "ref_spans": [], "section": "Mutation Testing"}, {"text": "A general mutation testing process is shown in Fig. 1 . Given a source program assumed to be nearly correct (developed by a competent programmer), Mutation Generation consists in creating variations of the program ( Mutants), by introducing changes or mutations to the source code. Examples of classic mutations include the replacement of literals in the program (value mutations); substitution of operators in expressions or conditions (decision mutations) and the deletion or duplication of statements (statement mutations) [1] . This phase of the testing process is strongly dependent on the model or language of the program being tested and on a number of mutation operators, rules which define how to derive mutants from the original program. The task of generating mutants of a given program can be automated using parsing and source-to-source code generation techniques. The production of test cases is the next stage of the process. In this step input data, corresponding to each test case, is defined for the program and its mutants. The results of executing the test cases with each mutant are compared with the results obtained by the original program. A mutant is said to be killed if its results differ from those of the original program for some test case. The goal of a test set is then to kill as many mutants as possible. This indicates that the test set was able to detect the potential inserted code defects. Mutants that produce the same results as the original program, no matter which input data is provided, cannot be killed and are said to be equivalent to the original program.", "cite_spans": [{"start": 526, "end": 529, "text": "[1]", "ref_id": "BIBREF0"}], "ref_spans": [{"start": 47, "end": 53, "text": "Fig. 1", "ref_id": "FIGREF0"}], "section": "Mutation Testing"}, {"text": "Given a program P and a set of test cases T , a mutation score is given by:", "cite_spans": [], "ref_spans": [], "section": "Run T on P"}, {"text": "where DM (P, T ) is the number of killed mutants; M (P ) is the number of mutants and EM (P ) is the number of mutants that are equivalent to P . The mutation score measures the quality of the test set. This score is used to decide whether to produce more test cases, to improve the test set or to stop the testing process.", "cite_spans": [], "ref_spans": [], "section": "Run T on P"}, {"text": "Mutation testing is strongly influenced by the programming model, language and framework of the target program. Thus, mutation operators and tools have been developed to support mutation testing for different contexts as shown in [13] . Such contexts include mutation operators and tools for programs in specific languages like C [23] and Java [17] , aspect-oriented programs [10] and web services [15] . To the best of our knowledge, there is no previous work addressing mutation testing for data flow programs in the context of big data processing.", "cite_spans": [{"start": 230, "end": 234, "text": "[13]", "ref_id": "BIBREF13"}, {"start": 330, "end": 334, "text": "[23]", "ref_id": "BIBREF23"}, {"start": 344, "end": 348, "text": "[17]", "ref_id": "BIBREF17"}, {"start": 376, "end": 380, "text": "[10]", "ref_id": "BIBREF10"}, {"start": 398, "end": 402, "text": "[15]", "ref_id": "BIBREF15"}], "ref_spans": [], "section": "Run T on P"}, {"text": "Apache Spark is a general-purpose analytics engine for large-scale data processing on cluster systems [28] . It adopts a data flow-oriented programming model with data models, execution plans and programming interfaces with built in operations as building blocks for big data processing programs. Spark is centered on the concept of Resilient Distributed Dataset (RDD) [27] , a read-only, fault-tolerant data collection that is partitioned across a cluster. RDDs can be processed by two kinds of operations: transformations and actions. Transformations are operations that result in a new RDD from processing another one. Actions are operations that generate values that are not RDDs or that save the RDD into an external storage system. Spark transformations are evaluated under a lazy strategy when an action is called.", "cite_spans": [{"start": 102, "end": 106, "text": "[28]", "ref_id": "BIBREF28"}, {"start": 369, "end": 373, "text": "[27]", "ref_id": "BIBREF27"}], "ref_spans": [], "section": "Testing Apache Spark Programs"}, {"text": "A Spark program is defined as a set of initial RDDs loaded from an external storage, a sequence of transformations to be applied on these RDDs and actions that trigger the program execution. The sequence of operations implementing a Spark program is represented by a Directed Acyclic Graph (DAG) which acts as execution plan defining dependencies between transformations and representing the program data flow. These aspects are key elements for developing specific testing methodologies.", "cite_spans": [], "ref_spans": [], "section": "Testing Apache Spark Programs"}, {"text": "Spark provides a set of transformations for a wide variety of data processing operations. These transformations are described by a high-level interface with input parameters, which are functions that are applied to process elements on the RDD, and outputs. We classify transformations into families, according to the type of processing operation: Mapping, apply functions to map one element of the RDD to another (e.g., map and flatMap); Filtering, filter elements based on predicate functions that determine whether an element should remain in the RDD (e.g., filter); Aggregation, aggregate elements applying a binary function on the RDD elements (e.g., reduceByKey and aggregateByKey); Set, operate like mathematical set operations on two RDDs (e.g., union and intersection); Join, make a relational-like join between two RDDs (e.g., (inner) join and leftOuter-Join); and Ordering, for operations that sort the elements on the RDD (e.g., sortBy and sortByKey). We call unary transformations those that operate on a single RDD and binary transformations those that operate on two RDDs.", "cite_spans": [], "ref_spans": [], "section": "Testing Apache Spark Programs"}, {"text": "In order to propose a fault based approach for testing Apache Spark programs, we first studied representative example programs and the framework documentation to identify common faults or mistakes. Within Spark's programming approach, a program is defined by a (i) data flow that defines data transmission, sharing, caching and persistence strategies to be adopted by processes running on cluster components; and (ii) data processing operations. Considering this characteristic of Spark programs we have classified faults that can emerge within these complementary aspects and proposed a fault taxonomy. This taxonomy was then used as reference to the definition of the mutation operators that are a key element of our mutation testing based approach 2 . The mutation operators we propose have been designed considering the Spark data flow model and its operations (transformations). These components are independent of the programming language chosen to develop Spark programs (which can be done in Scala, Java or Python). Thus, our mutation operators are agnostic to the programming language and can be applied to any program that follows the data flow model of Spark. The next sections introduce these operators and their experimental validation.", "cite_spans": [], "ref_spans": [], "section": "Testing Apache Spark Programs"}, {"text": "Mutation operators are rules that define changes on a program to add simulated faults. These operators are designed to mimic common faults, such as a missing iteration of a loop or a mistake in an arithmetical or logical expression, or to prompt testers to follow common test heuristics, such as requiring a test where a specific action is executed [1] .", "cite_spans": [{"start": 349, "end": 352, "text": "[1]", "ref_id": "BIBREF0"}], "ref_spans": [], "section": "Mutation Operators for Apache Spark Programs"}, {"text": "Common faults and mistakes in Spark programs are generally related to the incorrect definition of the data flow of a program, such as calling transformations in a wrong order, and mistakes in specific transformations, such as calling the wrong transformation or passing the wrong parameter.", "cite_spans": [], "ref_spans": [], "section": "Mutation Operators for Apache Spark Programs"}, {"text": "In this paper, we propose two groups of mutation operators: data flow and transformations. Data flow operators define modifications in the sequence of transformations of a program (i.e., altering the flow of data between transformations). Transformation operators define modifications in specific groups of transformations, like replacing a transformation by another or changing a parameter. This section introduces these operators intuitively see their formal definition in [9] .", "cite_spans": [{"start": 475, "end": 478, "text": "[9]", "ref_id": "BIBREF9"}], "ref_spans": [], "section": "Mutation Operators for Apache Spark Programs"}, {"text": "Mutation Operators for the Data Flow: Operators in this class change the sequence of operations that defines the data flow of a Spark program.", "cite_spans": [], "ref_spans": [], "section": "Mutation Operators for Apache Spark Programs"}, {"text": "Unary Transformations Replacement (UTR) -Replace one unary transformation for another with the same input and output signature (RDD types).", "cite_spans": [], "ref_spans": [], "section": "Mutation Operators for Apache Spark Programs"}, {"text": "Unary Transformation Swap (UTS) -Swap the calls of two transformations of the program, provided that they have the same input and output signature.", "cite_spans": [], "ref_spans": [], "section": "Mutation Operators for Apache Spark Programs"}, {"text": "Unary Transformation Deletion (UTD) -Bypass a transformation that has the same RDD type as input and output.", "cite_spans": [], "ref_spans": [], "section": "Mutation Operators for Apache Spark Programs"}, {"text": "We also define operators similar to UTS and UTR, adapted to binary transformations: Binary Transformation Swap (BTS) and Binary Transformations Replacement (BTR).", "cite_spans": [], "ref_spans": [], "section": "Mutation Operators for Apache Spark Programs"}, {"text": "To illustrate the mutation operators for data flow, let us consider the excerpt from a Spark program presented in Fig. 2 . In this program we manipulate an integer RDD (input: RDD[Int]). Line 1 filters the even numbers of the dataset. Then, each number is mapped to its square (line 2). Finally, the RDD is sorted (line 3). All the mutants generated for this program by our data flow mutation operators are presented in Table 1 . In that table, only the lines affected by the mutation are included. For instance, applying the UTS operator to the transformations in lines 1 and 2, results in the mutant 7 of Table 1 . In this mutant, the filter transformation that was called on line 1 is swapped with the map transformation that was called on line 2 in the original program.", "cite_spans": [], "ref_spans": [{"start": 114, "end": 120, "text": "Fig. 2", "ref_id": "FIGREF1"}, {"start": 420, "end": 427, "text": "Table 1", "ref_id": "TABREF1"}, {"start": 607, "end": 614, "text": "Table 1", "ref_id": "TABREF1"}], "section": "Mutation Operators for Apache Spark Programs"}, {"text": "val even = input.filter(x => x % 2 == 0) val square = even.map(x => x * x) val sorted = square.sortBy(x => x) Mapping Transformation Replacement (MTR) -for each mapping transformation (map, flatMap) in the program, replace the mapping function passed as a parameter to that transformation by a different mapping function. We propose a mapping function that returns a constant value of the same type as the original, or makes some modification to the value returned by the original function. For example, for a mapping function that operates on integers, we can replace this function by one that returns zero or another that reverses the sign of the value returned by the original. In Table 3 we present mapping values of basic types and collections that can be returned by the mutant mapping function. To illustrate the MTR operator, consider the mapping transformation applied in line 2 of Fig. 2 . The operator generates mutants 1-5 in Table 2 . Filter Transformation Deletion (FTD) -for each filter transformation in the program, create a mutant where the call to that transformation is deleted from the program. For example, considering the filter transformation in line 1 of Fig. 2 , applying the FTD operator generates the mutation of line 6 in Table 2 .", "cite_spans": [], "ref_spans": [{"start": 684, "end": 691, "text": "Table 3", "ref_id": "TABREF3"}, {"start": 891, "end": 897, "text": "Fig. 2", "ref_id": "FIGREF1"}, {"start": 938, "end": 945, "text": "Table 2", "ref_id": "TABREF2"}, {"start": 1180, "end": 1186, "text": "Fig. 2", "ref_id": "FIGREF1"}, {"start": 1251, "end": 1258, "text": "Table 2", "ref_id": "TABREF2"}], "section": "Mutation Operators for Apache Spark Programs"}, {"text": "Negation of Filter Transformation Predicate (NFTP) -for each filter transformation in the program, replace the predicate function passed as a parameter to that transformation by a predicate function that negates the result of the original function. For the filter transformation in line 1 of Fig. 2 , the NFTP operator generates the mutation 7 in Table 2 . The application of the STR operator to this transformation creates the five mutants, described by lines 8-12 in Table 2 .", "cite_spans": [], "ref_spans": [{"start": 292, "end": 298, "text": "Fig. 2", "ref_id": "FIGREF1"}, {"start": 347, "end": 354, "text": "Table 2", "ref_id": "TABREF2"}, {"start": 469, "end": 476, "text": "Table 2", "ref_id": "TABREF2"}], "section": "Mutation Operators for Apache Spark Programs"}, {"text": "Distinct Transformation Deletion (DTD) -for each call of a distinct transformation in the program, create a mutant by deleting it. As the distinct transformation removes duplicated data from the RDD, this mutation keeps the duplicates. For example, the application of DTD in the following excerpt of code generates the mutant 13 of Table 2: val rdd4 = rdd3.distinct() Distinct Transformation Insertion (DTI) -for each transformation in the program, create a mutant inserting a distinct transformation call after that transformation. Applying DTI to the transformations presented in Fig. 2 generates the mutants 14-16 of Table 2 .", "cite_spans": [], "ref_spans": [{"start": 332, "end": 340, "text": "Table 2:", "ref_id": "TABREF2"}, {"start": 582, "end": 588, "text": "Fig. 2", "ref_id": "FIGREF1"}, {"start": 620, "end": 627, "text": "Table 2", "ref_id": "TABREF2"}], "section": "Set Transformation Replacement (STR) -"}, {"text": "Aggregation Transformation Replacement (ATR) -for each aggregation transformation in the program, replace the aggregation function passed as a parameter by a different aggregation function. We propose five replacement functions. For an original function f (x, y), the replacement functions f m (x, y) are defined as: (1) a function that returns the first parameter (f m (x, y) = x); (2) a function that returns the second parameter (f m (x, y) = y); (3) a function that ignores the second parameter and calls the original function with a duplicated first parameter (f m (x, y) = f (x, x)); (4) a function that ignores the first parameter and calls the original function with a duplicated second parameter (f m (x, y) = f (y, y)); and (5) a function that swaps the order of the parameters (f m (x, y) = f (y, x)), which generates a different value for non-commutative functions. For example, considering the following excerpt of code with an aggregation transformation (reduceByKey) and an aggregation function that adds two values, the application of ATR generates the mutants 17-21 of Table 2 .", "cite_spans": [], "ref_spans": [{"start": 1086, "end": 1093, "text": "Table 2", "ref_id": "TABREF2"}], "section": "Set Transformation Replacement (STR) -"}, {"text": "val rdd4 = rdd3.reduceByKey((x, y) => x + y) Join Transformation Replacement (JTR) -for each occurrence of a join transformation ((inner) join, leftOuterJoin, rightOuterJoin and fullOuterJoin) in the program, replace that transformation by the remaining three join transformations. Additionally, a map transformation is inserted after the join to adjust the typing of the new join with the old one. This is necessary because depending on the join type, the left side, right side, or both can be optional, which makes the resulting RDD of the new join slightly different from the previous one. So we adjust the type of the resulting RDD to be of the same type as the original join. For example, replacing the join transformation by leftOuterJoin makes right-side values optional. To keep type consistency with the original transformation, we map empty right-side values to default values, in case of basic types, or null, otherwise.", "cite_spans": [], "ref_spans": [], "section": "Set Transformation Replacement (STR) -"}, {"text": "To illustrate the JTR operator, let us consider the following code snippet where two RDDs are joined. Assume that rdd3 is of type RDD to String. When this value is empty (None), we assign the empty string (\"\").", "cite_spans": [{"start": 130, "end": 133, "text": "RDD", "ref_id": null}], "ref_spans": [], "section": "Set Transformation Replacement (STR) -"}, {"text": "val rdd4 = rdd3.join(rdd2)", "cite_spans": [], "ref_spans": [], "section": "Set Transformation Replacement (STR) -"}, {"text": "Order Transformation Deletion (OTD) -for each order transformation (sortBy and sortByKey) in the program, create a mutant where the call to that transformation is deleted from the program. For example, considering the order transformation called in line 3 of Fig. 2 , the application of OTD generates the mutant 25 of Table 2 .", "cite_spans": [], "ref_spans": [{"start": 259, "end": 265, "text": "Fig. 2", "ref_id": "FIGREF1"}, {"start": 318, "end": 325, "text": "Table 2", "ref_id": "TABREF2"}], "section": "Set Transformation Replacement (STR) -"}, {"text": "Order Transformation Inversion (OTI) -for each order transformation in the program, create a mutant where the ordering of that transformations is replaced by the inverse ordering (ascending or descending). Applying OTI to the same order transformation of Fig. 2 generates the mutant 26 of Table 2 , where the ascending ordering that is true by default was changed for false.", "cite_spans": [], "ref_spans": [{"start": 255, "end": 261, "text": "Fig. 2", "ref_id": "FIGREF1"}, {"start": 289, "end": 296, "text": "Table 2", "ref_id": "TABREF2"}], "section": "Set Transformation Replacement (STR) -"}, {"text": "We conducted experiments to evaluate the cost and effectiveness of the proposed mutation operators. We selected a set of eight representative Spark programs 3 to apply the mutation testing process described in Fig. 1 . These programs perform common data analysis such as text and log analysis, queries on tabular datasets inspired by the benchmark presented in [2] , and data exploration and recommendation based on the collaborative filtering algorithm [24] . These programs were selected to explore the features necessary to apply the operators, such as having data flow and transformations commonly used in Spark programs and that could be modified in the testing process.", "cite_spans": [{"start": 361, "end": 364, "text": "[2]", "ref_id": null}, {"start": 454, "end": 458, "text": "[24]", "ref_id": "BIBREF24"}], "ref_spans": [{"start": 210, "end": 216, "text": "Fig. 1", "ref_id": "FIGREF0"}], "section": "Experiments"}, {"text": "The experiments presented in this section show a first assessment of the mutation operators. The process described in Fig. 1 was strictly followed, by manually executing each step. For each code to be tested, and each applicable mutation operator, the source was edited to simulate the application of the operator, generating a mutant. A script was then executed to run each mutant. Test cases were developed incrementally to kill the mutants. Comparison of the results with the original program and metrics calculation were also executed manually. Once we implemented a prototype mutation testing tool, the results of these experiments evaluated and results were corroborated.", "cite_spans": [], "ref_spans": [{"start": 118, "end": 124, "text": "Fig. 1", "ref_id": "FIGREF0"}], "section": "Experiments"}, {"text": "Finally, we performed a cost analysis based on the number of mutants generated and tests needed to kill all mutants (ms = 100%). We also analyzed the effectiveness of the mutation operators by identifying the operators that generated mutants that were killed by most of the tests and operators that generated mutants that were harder to kill. Table 4 summarizes the results for each program, showing the number of transformations in each program, number of mutants, number of tests created, number of killed mutants, number of equivalent mutants, and mutation score (ms). Table 5 summarizes the results aggregated for each mutation operator. It shows the total number of mutants generated by the operator, the number of equivalent mutants and the killed ratio 4 . The killed ratio shows how easy it was to kill the mutants generated with that mutation operator. Thus, operators with a low ratio generated mutants harder to kill (they required more specific tests). This measures the effectiveness of the mutation operator because mutants that are not killed trivially (get killed by any test) simulate faults that are not easily revealed. The mutation operators for data flow (UTS, BTS, UTR, BTR and UTD) were responsible for 19,6% of the generated mutants. The number of mutants generated by each of these operators depends on the number of transformations that have the same input dataset type and the same output dataset type. The number of mutants generated by UTS and BTS is equal to the number of twoby-two combinations between these transformations. In the case of the UTR and BTR, the number of mutants depends on the number of permutations of these transformations. The UTD generates a number of mutants equal to the number of transformations that have input and output datasets of the same type. From these operators, UTR, BTR and UTD generated the most relevant mutants since their mutants were killed by fewer tests.", "cite_spans": [{"start": 760, "end": 761, "text": "4", "ref_id": "BIBREF3"}], "ref_spans": [{"start": 343, "end": 350, "text": "Table 4", "ref_id": "TABREF5"}, {"start": 572, "end": 579, "text": "Table 5", "ref_id": "TABREF6"}], "section": "Experiments"}, {"text": "The MTR operator generated the largest number of mutants (38,3% of total). Mapping operations are common in big data processing programs, which explains the number of mutants. The number of mutants depends on the type to which data is being mapped according to Table 3 . For example, a mapping transformation that generates a numeric value will generate five mutants since we define five mapping values for numeric types. Analyzing the total, the mutants generated with the MTR were the easiest to kill, as we can see in Table 5 . Individually, the mappings for 1, with numeric types, and List(x.head) and Nil, in list type, obtained the best results with ratios below 70%.", "cite_spans": [], "ref_spans": [{"start": 261, "end": 268, "text": "Table 3", "ref_id": "TABREF3"}, {"start": 521, "end": 528, "text": "Table 5", "ref_id": "TABREF6"}], "section": "Experiments"}, {"text": "The operators FTD and NFTP, related with filter transformations, and OTD and OTI, related with order transformations, generate a number of mutants equal to the number of transformations of the respective types. A subsumption relationship between FTD and NFTP, and between OTD and OTI was observed in the results. All tests that killed FTD mutants also killed NFTP mutants, just as all tests that killed OTD mutants also killed OTI mutants, but the opposite in both cases was not observed. This indicates that the FTD and OTD operators are stronger than the NFTP and OTI operators, which in turn indicates that when FTD and OTD are applied, the NFTP and OTI operators are not required.", "cite_spans": [], "ref_spans": [], "section": "Experiments"}, {"text": "The operator DTI generated 14.5% of all mutants, being the second operator that generated the most mutants. DTI is the most applicable operator because it can be applied after any transformation considering the resulting dataset is always the same type as the original. This operator also generated the largest number of equivalent mutants. This occurs because in some cases the operator is applied after aggregation transformations, so the repeated data had already been aggregated and the dataset no longer had duplicate data. In general, the DTI operator generated relevant mutants considering they were killed by less than 30% of the tests. The number of mutants generated with DTD is equal to the number of distinct transformations called in the program. In our experiment, only one program used distinct, which explains the existence of only one mutant.", "cite_spans": [], "ref_spans": [], "section": "Experiments"}, {"text": "ATR generated 11,2% of the mutants in the experiment. The number of mutants it generates is proportional to the number of aggregation transformations in the program, with five mutants for each transformation. The ATR operator has helped to improve the test set because it requires testing with diverse data to aggregate in order to kill the mutants. All equivalent mutants generated by ATR in our experiments were generated by the commutative replacement (f m (x, y) = f (y, x)) because all aggregation functions applied in the programs were commutative. Even so, the commutative replacement mutation is useful because aggregation operations in distributed environments must be commutative to be deterministic [7] . Thus, this mutation can ensure that the commutative property is being taken into account in the testing process.", "cite_spans": [{"start": 710, "end": 713, "text": "[7]", "ref_id": "BIBREF6"}], "ref_spans": [], "section": "Experiments"}, {"text": "The mutation operators for binary transformations STR, for set-like transformations, and JTR, for join transformations, generate mutants proportional to the number of these types of transformations. A set transformation generate five mutants, whereas a join transformation generates three mutants. Both operators force the creation of test cases that include two input datasets with diversified data, containing data common to both as well as data not shared between them. In this manner, STR and JTR contribute to the improvement of the test set as they require nontrivial test data. This can be seen in Table 5 which shows that the killed ratio was 34,4% for STR and 22,2% for JTR, which we consider relevant results.", "cite_spans": [], "ref_spans": [{"start": 605, "end": 612, "text": "Table 5", "ref_id": "TABREF6"}], "section": "Experiments"}, {"text": "In general, the results showed a reasonable cost estimation for the mutation operators proposed in this work and the viability of their application in the mutation testing process. The number of mutants generated depends on the amount of transformations in the program and their types. The analysis of these aspects, as well as an analysis of the results shown in Table 5 , such as the killed ratio, can be used as a reference to the selection of the operators to apply to the mutation testing of big data processing programs.", "cite_spans": [], "ref_spans": [{"start": 364, "end": 371, "text": "Table 5", "ref_id": "TABREF6"}], "section": "Experiments"}, {"text": "The development of big data processing programs has gained interest in recent years. The distributed environment and computational resources required to run such programs make their costs high, which makes it necessary to validate and verify them before production. This paper addressed this issue by proposing the application of mutation testing to big data programs based on data flow systems.", "cite_spans": [], "ref_spans": [], "section": "Conclusions and Future Work"}, {"text": "We proposed a set of 15 mutation operators that take into account characteristics and operations of data flow systems to model changes in Spark programs and simulate faults. We applied these operators in an experiment to show their feasibility and make a first assessment of costs and effectiveness. The results showed the feasibility to apply mutation testing and design test cases for big data programs, at a reasonable cost. The experiment also hinted at the quality of mutation operators by showing which operators generated mutants, and hence faults, which were more difficult to identify, thus leading to more interesting test cases. This was revealed by the killed ratio for each operator in Table 5 .", "cite_spans": [], "ref_spans": [{"start": 699, "end": 706, "text": "Table 5", "ref_id": "TABREF6"}], "section": "Conclusions and Future Work"}, {"text": "Our approach is complementary to traditional mutation testing criteria developed for Scala, Java and Python. The mutation analysis at the workflow level has several advantages. First, it reflects the two-level organization of Apache Spark programs, where the programmer defines the basic processing blocks (transformation) and the composition of these blocks (data flow). We designed our testing criteria to deal with this composition. Second, it can be used in addition to traditional mutation testing at the programming language level. Finally, it can be generalised to other data flow big data processing frameworks which have similarities in program definition and operations. Thus, we plan to do experiments to apply the proposed mutation operators for testing programs in other data flow frameworks such as Apache Flink [6] , DryadLINQ [26] and Apache Beam [3] .", "cite_spans": [{"start": 826, "end": 829, "text": "[6]", "ref_id": "BIBREF5"}, {"start": 842, "end": 846, "text": "[26]", "ref_id": "BIBREF26"}, {"start": 863, "end": 866, "text": "[3]", "ref_id": "BIBREF2"}], "ref_spans": [], "section": "Conclusions and Future Work"}, {"text": "Our work has shown that mutation testing can be successfully applied to big data processing programs by designing mutation operators specific to this class of programs. However, due to the effort required for generation, execution and analysis of the mutants, mutation testing is dependent on automation so that it can be viable. Thus, we are consolidating our prototype to automate the process of generation and execution of mutants, to assist the mutation testing of big data programs. Moreover, we plan to evaluate the effectiveness of our mutation operators by comparing the test sets created in the process with other test coverage criteria (e.g., input space partitioning and logic coverage [1] ).", "cite_spans": [{"start": 697, "end": 700, "text": "[1]", "ref_id": "BIBREF0"}], "ref_spans": [], "section": "Conclusions and Future Work"}], "bib_entries": {"BIBREF0": {"ref_id": "b0", "title": "Introduction to Software Testing", "authors": [{"first": "P", "middle": [], "last": "Ammann", "suffix": ""}, {"first": "J", "middle": [], "last": "Offutt", "suffix": ""}], "year": 2017, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF2": {"ref_id": "b2", "title": "Apache Foundation: Apache Beam: An advanced unified programming model", "authors": [], "year": 2016, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF3": {"ref_id": "b3", "title": "Apache Foundation: Apache Hadoop Documentation", "authors": [], "year": 2019, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF4": {"ref_id": "b4", "title": "MapReduce program testing: a systematic mapping study", "authors": [{"first": "L", "middle": ["C"], "last": "Camargo", "suffix": ""}, {"first": "S", "middle": ["R"], "last": "Vergilio", "suffix": ""}], "year": 2013, "venue": "Chilean Computer Science Society (SCCC), 32nd International Conference of the Computation", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF5": {"ref_id": "b5", "title": "Apache Flink: stream and batch processing in a single engine", "authors": [{"first": "P", "middle": [], "last": "Carbone", "suffix": ""}, {"first": "S", "middle": [], "last": "Ewen", "suffix": ""}, {"first": "S", "middle": [], "last": "Haridi", "suffix": ""}, {"first": "A", "middle": [], "last": "Katsifodimos", "suffix": ""}, {"first": "V", "middle": [], "last": "Markl", "suffix": ""}, {"first": "K", "middle": [], "last": "Tzoumas", "suffix": ""}], "year": 2015, "venue": "IEEE Data Eng. Bull", "volume": "38", "issn": "4", "pages": "28--38", "other_ids": {}}, "BIBREF6": {"ref_id": "b6", "title": "An executable sequential specification for spark aggregation", "authors": [{"first": "Y.-F", "middle": [], "last": "Chen", "suffix": ""}, {"first": "C.-D", "middle": [], "last": "Hong", "suffix": ""}, {"first": "O", "middle": [], "last": "Leng\u00e1l", "suffix": ""}, {"first": "S.-C", "middle": [], "last": "Mu", "suffix": ""}, {"first": "N", "middle": [], "last": "Sinha", "suffix": ""}, {"first": "B.-Y", "middle": [], "last": "Wang", "suffix": ""}], "year": 2017, "venue": "NETYS 2017", "volume": "10299", "issn": "", "pages": "421--438", "other_ids": {"DOI": ["10.1007/978-3-319-59647-1_31"]}}, "BIBREF7": {"ref_id": "b7", "title": "New ideas track: testing mapreduce-style programs", "authors": [{"first": "C", "middle": [], "last": "Csallner", "suffix": ""}, {"first": "L", "middle": [], "last": "Fegaras", "suffix": ""}, {"first": "C", "middle": [], "last": "Li", "suffix": ""}], "year": null, "venue": "Proceedings of the 19th ACM SIGSOFT Symposium and the 13th", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF8": {"ref_id": "b8", "title": "European Conference on Foundations of Software Engineering", "authors": [], "year": 2011, "venue": "", "volume": "", "issn": "", "pages": "504--507", "other_ids": {}}, "BIBREF9": {"ref_id": "b9", "title": "An approach to mutation testing of big data processing programs", "authors": [{"first": "J", "middle": ["B"], "last": "De Souza Neto", "suffix": ""}], "year": 2019, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF10": {"ref_id": "b10", "title": "Mutation testing for aspect-oriented programs", "authors": [{"first": "F", "middle": ["C"], "last": "Ferrari", "suffix": ""}, {"first": "J", "middle": ["C"], "last": "Maldonado", "suffix": ""}, {"first": "A", "middle": [], "last": "Rashid", "suffix": ""}], "year": 2008, "venue": "2008 1st International Conference on Software Testing, Verification, and Validation", "volume": "", "issn": "", "pages": "52--61", "other_ids": {}}, "BIBREF11": {"ref_id": "b11", "title": "All-uses vs mutation testing: an experimental comparison of effectiveness", "authors": [{"first": "P", "middle": ["G"], "last": "Frankl", "suffix": ""}, {"first": "S", "middle": ["N"], "last": "Weiss", "suffix": ""}, {"first": "C", "middle": [], "last": "Hu", "suffix": ""}], "year": 1997, "venue": "J. Syst. Softw", "volume": "38", "issn": "3", "pages": "235--253", "other_ids": {}}, "BIBREF12": {"ref_id": "b12", "title": "Challenges and techniques for testing of big data", "authors": [{"first": "N", "middle": [], "last": "Garg", "suffix": ""}, {"first": "S", "middle": [], "last": "Singla", "suffix": ""}, {"first": "S", "middle": [], "last": "Jangra", "suffix": ""}], "year": 2016, "venue": "International Conference on Computational Modelling and Security", "volume": "85", "issn": "", "pages": "940--948", "other_ids": {}}, "BIBREF13": {"ref_id": "b13", "title": "An analysis and survey of the development of mutation testing", "authors": [{"first": "Y", "middle": [], "last": "Jia", "suffix": ""}, {"first": "M", "middle": [], "last": "Harman", "suffix": ""}], "year": 2011, "venue": "IEEE Trans. Softw. Eng", "volume": "37", "issn": "5", "pages": "649--678", "other_ids": {}}, "BIBREF14": {"ref_id": "b14", "title": "Spark testing base", "authors": [{"first": "H", "middle": [], "last": "Karau", "suffix": ""}], "year": 2019, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF15": {"ref_id": "b15", "title": "Generating test cases for XML-based Web component interactions using mutation analysis", "authors": [{"first": "S", "middle": ["C"], "last": "Lee", "suffix": ""}, {"first": "J", "middle": [], "last": "Offutt", "suffix": ""}], "year": 2001, "venue": "Proceedings 12th International Symposium on Software Reliability Engineering", "volume": "", "issn": "", "pages": "200--209", "other_ids": {}}, "BIBREF16": {"ref_id": "b16", "title": "SEDGE: symbolic example data generation for dataflow programs", "authors": [{"first": "K", "middle": [], "last": "Li", "suffix": ""}, {"first": "C", "middle": [], "last": "Reichenbach", "suffix": ""}, {"first": "Y", "middle": [], "last": "Smaragdakis", "suffix": ""}, {"first": "Y", "middle": [], "last": "Diao", "suffix": ""}, {"first": "C", "middle": [], "last": "Csallner", "suffix": ""}], "year": 2013, "venue": "28th IEEE/ACM International Conference on Automated Software Engineering", "volume": "", "issn": "", "pages": "235--245", "other_ids": {}}, "BIBREF17": {"ref_id": "b17", "title": "MuJava: an automated class mutation system", "authors": [{"first": "Y", "middle": ["S"], "last": "Ma", "suffix": ""}, {"first": "J", "middle": [], "last": "Offutt", "suffix": ""}, {"first": "Y", "middle": ["R"], "last": "Kwon", "suffix": ""}], "year": 2005, "venue": "Softw. Test. Verif. Reliab", "volume": "15", "issn": "2", "pages": "97--133", "other_ids": {}}, "BIBREF18": {"ref_id": "b18", "title": "Big Data: Using SMART Big Data, Analytics and Metrics to Make Better Decisions and Improve Performance", "authors": [{"first": "B", "middle": [], "last": "Marr", "suffix": ""}], "year": 2015, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF19": {"ref_id": "b19", "title": "Testing data transformations in MapReduce programs", "authors": [{"first": "J", "middle": [], "last": "Mor\u00e1n", "suffix": ""}, {"first": "C", "middle": [], "last": "De La Riva", "suffix": ""}, {"first": "J", "middle": [], "last": "Tuya", "suffix": ""}], "year": 2015, "venue": "Proceedings of the 6th International Workshop on Automating Test Case Design, Selection and Evaluation", "volume": "", "issn": "", "pages": "20--25", "other_ids": {}}, "BIBREF20": {"ref_id": "b20", "title": "Testing MapReduce programs: a systematic mapping study", "authors": [{"first": "J", "middle": [], "last": "Mor\u00e1n", "suffix": ""}, {"first": "C", "middle": [], "last": "De La Riva", "suffix": ""}, {"first": "J", "middle": [], "last": "Tuya", "suffix": ""}], "year": 2019, "venue": "J. Softw. Evol. Process", "volume": "31", "issn": "3", "pages": "", "other_ids": {}}, "BIBREF21": {"ref_id": "b21", "title": "An experimental evaluation of data flow and mutation testing", "authors": [{"first": "A", "middle": ["J"], "last": "Offutt", "suffix": ""}, {"first": "J", "middle": [], "last": "Pan", "suffix": ""}, {"first": "K", "middle": [], "last": "Tewary", "suffix": ""}, {"first": "T", "middle": [], "last": "Zhang", "suffix": ""}], "year": 1996, "venue": "Softw. Pract. Exper", "volume": "26", "issn": "2", "pages": "165--176", "other_ids": {}}, "BIBREF22": {"ref_id": "b22", "title": "Pig Latin: a not-soforeign language for data processing", "authors": [{"first": "C", "middle": [], "last": "Olston", "suffix": ""}, {"first": "B", "middle": [], "last": "Reed", "suffix": ""}, {"first": "U", "middle": [], "last": "Srivastava", "suffix": ""}, {"first": "R", "middle": [], "last": "Kumar", "suffix": ""}, {"first": "A", "middle": [], "last": "Tomkins", "suffix": ""}], "year": 2008, "venue": "Proceedings of the 2008 ACM SIGMOD International Conference on Management of Data", "volume": "", "issn": "", "pages": "1099--1110", "other_ids": {}}, "BIBREF23": {"ref_id": "b23", "title": "Design of mutant operators for the C programming language", "authors": [{"first": "H", "middle": ["A"], "last": "Richard", "suffix": ""}], "year": 1989, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF24": {"ref_id": "b24", "title": "Item-based collaborative filtering recommendation algorithms", "authors": [{"first": "B", "middle": [], "last": "Sarwar", "suffix": ""}, {"first": "G", "middle": [], "last": "Karypis", "suffix": ""}, {"first": "J", "middle": [], "last": "Konstan", "suffix": ""}, {"first": "J", "middle": [], "last": "Riedl", "suffix": ""}], "year": 2001, "venue": "Proceedings of the 10th International Conference on World Wide Web", "volume": "", "issn": "", "pages": "285--295", "other_ids": {}}, "BIBREF25": {"ref_id": "b25", "title": "A measure of test case completeness (software, engineering)", "authors": [{"first": "P", "middle": ["J"], "last": "Walsh", "suffix": ""}], "year": 1985, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF26": {"ref_id": "b26", "title": "DryadLINQ: a system for general-purpose distributed data-parallel computing using a high-level language", "authors": [{"first": "Y", "middle": [], "last": "Yu", "suffix": ""}], "year": 2008, "venue": "Proceedings of the 8th USENIX Conference on Operating Systems Design and Implementation", "volume": "", "issn": "", "pages": "1--14", "other_ids": {}}, "BIBREF27": {"ref_id": "b27", "title": "Resilient distributed datasets: a fault-tolerant abstraction for in-memory cluster computing", "authors": [{"first": "M", "middle": [], "last": "Zaharia", "suffix": ""}], "year": 2012, "venue": "Proceedings of the 9th USENIX Conference on Networked Systems Design and Implementation, p. 2. USENIX Association", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF28": {"ref_id": "b28", "title": "Spark: cluster computing with working sets", "authors": [{"first": "M", "middle": [], "last": "Zaharia", "suffix": ""}, {"first": "M", "middle": [], "last": "Chowdhury", "suffix": ""}, {"first": "M", "middle": ["J"], "last": "Franklin", "suffix": ""}, {"first": "S", "middle": [], "last": "Shenker", "suffix": ""}, {"first": "I", "middle": [], "last": "Stoica", "suffix": ""}], "year": 2010, "venue": "Proceedings of the 2nd USENIX Conference on Hot Topics in Cloud Computing", "volume": "", "issn": "", "pages": "", "other_ids": {}}}, "ref_entries": {"FIGREF0": {"text": "Mutation testing process (Adapted from[1]).", "latex": null, "type": "figure"}, "FIGREF1": {"text": "Example of part of a Spark program.", "latex": null, "type": "figure"}, "FIGREF2": {"text": "for each occurrence of a set transformation (union, intersection and subtract) in a program, create five mutants:(1)(2) replacing the transformation by each of the other remaining set transformations, (3) keeping just the first RDD, (4) keeping just the second RDD, and (5) changing the order of the RDDs in the transformation call. For example, given the following excerpt of code with a union between two RDDs: val rdd3 = rdd1.union(rdd2)", "latex": null, "type": "figure"}, "TABREF1": {"text": "Mutants generated with the data flow mutation operators.", "latex": null, "type": "table", "html": "<html><body><table><tr><td>Id </td><td>Operator </td><td>Lines </td><td>\u00a0</td><td>Mutation\n</td></tr><tr><td>1 </td><td>UTR </td><td>1 </td><td>val </td><td>even </td><td>=input.map( x =&gt;x \u2217 x )\n</td></tr><tr><td>2 </td><td>UTR </td><td>1 </td><td>val </td><td>even </td><td>=input.sortBy( x =&gt;x )\n</td></tr><tr><td>3 </td><td>UTR </td><td>2 </td><td>val </td><td>\u00a0</td><td>=even.filter( x =&gt;x % 2 ==0 )\n</td></tr><tr><td>4 </td><td>UTR </td><td>2 </td><td>val </td><td>square square sorted sorted </td><td>=even.sortBy( x =&gt;x )\n</td></tr><tr><td>5 </td><td>UTR </td><td>3 </td><td>val </td><td>=square.filter( x =&gt;x % 2 ==0 )\n</td></tr><tr><td>6 </td><td>UTR </td><td>3 </td><td>val </td><td>=square.map( x =&gt;x \u2217 x )\n</td></tr><tr><td>7 </td><td>UTS </td><td>1,2\n</td><td>val </td><td>even = </td><td>input.map(x =&gt; x \u2217 x)\n= even.filter(x =&gt; x % 2 </td></tr><tr><td>\u00a0</td><td>\u00a0</td><td>\u00a0</td><td>val </td><td>square </td><td>== 0)\n</td></tr><tr><td>\u00a0</td><td>UTS </td><td>1,3\n</td><td>val </td><td>even = </td><td>input.sortBy(x =&gt; x)\n</td></tr><tr><td>8 </td><td>\u00a0</td><td>\u00a0</td><td>\u00a0</td><td>\u00a0</td></tr><tr><td>\u00a0</td><td>\u00a0</td><td>\u00a0</td><td>val </td><td>\u00a0</td><td>= square.filter(x =&gt; x % 2 == 0)\n</td></tr><tr><td>\u00a0</td><td>UTS </td><td>\u00a0</td><td>val </td><td>sorted square </td><td>= even.sortBy(x =&gt; x)%\n</td></tr><tr><td>9 </td><td>2,3\n</td><td>\u00a0</td><td>\u00a0</td><td>\u00a0</td></tr><tr><td>\u00a0</td><td>\u00a0</td><td>\u00a0</td><td>val </td><td>sorted </td><td>= square.map(x =&gt; x \u2217 x)\n</td></tr><tr><td>10 </td><td>UTD </td><td>1 </td><td>val </td><td>even </td><td>=input\n</td></tr><tr><td>11 UTD </td><td>2 </td><td>val </td><td>\u00a0</td><td>=even\n</td></tr><tr><td>12 UTD </td><td>3 </td><td>val </td><td>square sorted </td><td>=square\n</td></tr></table></body></html>"}, "TABREF2": {"text": "Mutants generated with the transformation mutation operators.", "latex": null, "type": "table", "html": "<html><body><table><tr><td>Id </td><td>Operator </td><td>Line </td><td>\u00a0</td><td>Mutation\n</td></tr><tr><td>1 </td><td>MTR </td><td>2 </td><td>val </td><td>square =even.map(x =&gt;0)\n</td></tr><tr><td>2 </td><td>MTR </td><td>2 </td><td>val </td><td>square =even.map(x =&gt;1) square =even.map(x =&gt;Int.MaxValue) square =even.map(x =&gt;Int.MinValue)\n</td></tr><tr><td>3 </td><td>MTR </td><td>2 </td><td>val </td></tr><tr><td>4 </td><td>\u00a0</td><td>2 </td><td>val </td></tr><tr><td>\u00a0</td><td>MTR </td><td>\u00a0</td><td>\u00a0</td><td>\u00a0</td><td>\u00a0</td></tr><tr><td>5 </td><td>MTR </td><td>2 </td><td>val </td><td>square =even.map(x =&gt;\u2212(x \u2217 x))\n</td></tr><tr><td>6 </td><td>FTD </td><td>1 </td><td>val </td><td>even </td><td>=input\n</td></tr><tr><td>7 </td><td>NFTP </td><td>1 </td><td>val </td><td>even </td><td>=input.filter(x =&gt;!(x % 2 ==0))\n</td></tr><tr><td>8 </td><td>STR </td><td>- </td><td>val </td><td>rdd3 </td><td>=rdd1.intersection(rdd2)\n</td></tr><tr><td>9 </td><td>STR </td><td>- </td><td>val </td><td>rdd3 </td><td>=rdd1.subtract(rdd2)\n</td></tr><tr><td>10 </td><td>STR </td><td>- </td><td>val </td><td>rdd3 </td><td>=rdd1\n</td></tr><tr><td>11 </td><td>STR </td><td>- </td><td>val </td><td>rdd3 </td><td>=rdd2\n</td></tr><tr><td>12 </td><td>STR </td><td>- </td><td>val </td><td>rdd3 </td><td>=rdd2.union(rdd1)\n</td></tr><tr><td>13 </td><td>DTD </td><td>- </td><td>val </td><td>rdd4 </td><td>=rdd3\n</td></tr><tr><td>14 </td><td>DTI </td><td>1 </td><td>val </td><td>even </td><td>=input.filter(x =&gt;x % 2 ==0).distinct() square =even.map(x =&gt;x \u2217 x).distinct()\n</td></tr><tr><td>15 </td><td>DTI </td><td>2 </td><td>val </td><td>\u00a0</td><td>\u00a0</td></tr><tr><td>16 </td><td>DTI </td><td>3 </td><td>val </td><td>sorted </td><td>=square.sortBy(x =&gt;x).distinct()\n</td></tr><tr><td>17 </td><td>ATR </td><td>- </td><td>val </td><td>rdd4 </td><td>=rdd3.reduceByKey((x, y)=&gt;x)\n</td></tr><tr><td>18 </td><td>ATR </td><td>- </td><td>val </td><td>rdd4 </td><td>=rdd3.reduceByKey((x, y)=&gt;y)\n</td></tr><tr><td>19 </td><td>ATR </td><td>- </td><td>val </td><td>rdd4 </td><td>=rdd3.reduceByKey((x, y)=&gt;x + x)\n</td></tr><tr><td>20 </td><td>ATR </td><td>- </td><td>val </td><td>rdd4 </td><td>=rdd3.reduceByKey((x, y)=&gt;y + y)\n</td></tr><tr><td>21 </td><td>ATR </td><td>- </td><td>val </td><td>rdd4 </td><td>=rdd3.reduceByKey((x, y)=&gt;y + x)\n</td></tr><tr><td>\u00a0</td><td>\u00a0</td><td>\u00a0</td><td>val </td><td>rdd4 </td><td>= rdd3.leftOuterJoin(rdd2)\n</td></tr><tr><td>22 </td><td>JTR </td><td>-\n</td><td>\u00a0</td><td>\u00a0</td><td>.map(x =&gt; (x. 1,\n</td></tr><tr><td>\u00a0</td><td>\u00a0</td><td>\u00a0</td><td>\u00a0</td><td>\u00a0</td><td>(x. 2. 1, x. 2. 2.getOrElse(\"\"))))\n</td></tr><tr><td>23 </td><td>JTR </td><td>-\n</td><td>val </td><td>rdd4 </td><td>= rdd3.rightOuterJoin(rdd2) .map(x =&gt; (x. 1,\n</td></tr><tr><td>\u00a0</td><td>\u00a0</td><td>\u00a0</td><td>\u00a0</td><td>\u00a0</td><td>(x. 2. 1.getOrElse(0), x. 2. 2)))\n</td></tr><tr><td>24 </td><td>JTR </td><td>-\n</td><td>val </td><td>rdd4 </td><td>= rdd3.fullOuterJoin(rdd2) .map(x =&gt; (x. 1,\n</td></tr><tr><td>25 </td><td>OTD </td><td>3 </td><td>val </td><td>sorted sorted </td><td>(x. 2. 1.getOrElse(0), x. 2. 2.getOrElse(\"\"))))\n=square\n</td></tr><tr><td>\u00a0</td><td>26 </td><td>OTI </td><td>3 </td><td>val </td><td>=square.sortBy(x =&gt;x, ascending =false)\n</td></tr></table></body></html>"}, "TABREF3": {"text": "Mapping values for basic and collections types.General nullDescription: x represents the value generated by the original mapping function; k and v represents the key and value generated by the original mapping function in case of Key-Value tuples; km and vm represents modified values for the key and value, which is the application of other mapping values respecting the type.", "latex": null, "type": "table"}, "TABREF4": {"text": "[(Int, Int)] and that rdd2 is of type RDD[(Int, String)]. The resulting RDD of this join (rdd4) is of type RDD[(Int, (Int, String))]. Applying JTR to this transformation generates the mutants 22-24 of Table 1. Taking mutant 22 as an example, replacing join with leftOuterJoin, the resulting RDD is of type RDD[(Int, (Int, Option[String]))]. Thus, the map following the leftOuterJoin serves to set the value of type Option[String]", "latex": null, "type": "table"}, "TABREF5": {"text": "Total of mutants and tests per program.", "latex": null, "type": "table", "html": "<html><body><table><tr><td>Program </td><td>Transformations </td><td>Mutants </td><td>Tests </td><td>Killed </td><td>Equiv. </td><td>ms (%)\n</td></tr><tr><td>NGramsCount </td><td>5 </td><td>27 </td><td>5 </td><td>20 </td><td>5 </td><td>100\n</td></tr><tr><td>ScanQuery </td><td>3 </td><td>12 </td><td>3 </td><td>12 </td><td>0 </td><td>100\n</td></tr><tr><td>AggregationQuery </td><td>3 </td><td>15 </td><td>3 </td><td>11 </td><td>2 </td><td>100\n</td></tr><tr><td>DistinctUserVisitsPerPage </td><td>4 </td><td>16 </td><td>2 </td><td>10 </td><td>6 </td><td>100\n</td></tr><tr><td>MoviesRatingsAverage </td><td>5 </td><td>25 </td><td>4 </td><td>22 </td><td>3 </td><td>100\n</td></tr><tr><td>MoviesRecomendation </td><td>12 </td><td>37 </td><td>5 </td><td>33 </td><td>4 </td><td>100\n</td></tr><tr><td>JoinQuery </td><td>11 </td><td>27 </td><td>6 </td><td>25 </td><td>2 </td><td>100\n</td></tr><tr><td>NasaApacheWebLogsAnalysis </td><td>7 </td><td>55 </td><td>4 </td><td>49 </td><td>6 </td><td>100\n</td></tr><tr><td>Total </td><td>50 </td><td>214 </td><td>32 </td><td>182 </td><td>28 </td><td>-\n</td></tr></table></body></html>"}, "TABREF6": {"text": "Total of mutants and killed ratio per mutation operator.", "latex": null, "type": "table", "html": "<html><body><table><tr><td>Mut. </td><td># of </td><td># of </td><td>Killed\n</td><td>Mut. </td><td># of </td><td># of </td><td>Killed\n</td></tr><tr><td>Op. </td><td>Mutants </td><td>Equiv. </td><td>Ratio (%)\n</td><td>Op. </td><td>Mutants </td><td>Equiv. </td><td>Ratio (%)\n</td></tr><tr><td>UTS </td><td>11 </td><td>2 </td><td>67,6\n</td><td>STR </td><td>10 </td><td>2 </td><td>34,4\n</td></tr><tr><td>BTS </td><td>1 </td><td>0 </td><td>75,0\n</td><td>DTI </td><td>31 </td><td>10 </td><td>27,7\n</td></tr><tr><td>UTR </td><td>22 </td><td>2 </td><td>39,0\n</td><td>DTD </td><td>1 </td><td>0 </td><td>25,0\n</td></tr><tr><td>BTR </td><td>2 </td><td>0 </td><td>37,5\n</td><td>ATR </td><td>20 </td><td>4 </td><td>46,4\n</td></tr><tr><td>UTD </td><td>6 </td><td>0 </td><td>32,0\n</td><td>JTR </td><td>6 </td><td>3 </td><td>22,2\n</td></tr><tr><td>MTR </td><td>82 </td><td>5 </td><td>76,1\n</td><td>OTI </td><td>4 </td><td>0 </td><td>30,0\n</td></tr><tr><td>FTD </td><td>7 </td><td>0 </td><td>34,4\n</td><td>OTD </td><td>4 </td><td>0 </td><td>20,0\n</td></tr><tr><td>\u00a0</td><td>\u00a0</td><td>\u00a0</td><td>\u00a0</td><td>NFTP </td><td>7 </td><td>0 </td><td>65,6\n</td></tr></table></body></html>"}}, "back_matter": []}