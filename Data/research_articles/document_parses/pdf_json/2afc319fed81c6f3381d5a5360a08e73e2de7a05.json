{
    "paper_id": "2afc319fed81c6f3381d5a5360a08e73e2de7a05",
    "metadata": {
        "title": "mu-term: Verify Termination Properties Automatically (System Description)",
        "authors": [
            {
                "first": "Ra\u00fal",
                "middle": [],
                "last": "Guti\u00e9rrez",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Universitat Polit\u00e8cnica de Val\u00e8ncia",
                    "location": {
                        "addrLine": "Camino de Vera s/n",
                        "postCode": "46022",
                        "settlement": "Valencia",
                        "country": "Spain"
                    }
                },
                "email": "rgutierrez@dsic.upv.es"
            },
            {
                "first": "Salvador",
                "middle": [],
                "last": "Lucas",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Universitat Polit\u00e8cnica de Val\u00e8ncia",
                    "location": {
                        "addrLine": "Camino de Vera s/n",
                        "postCode": "46022",
                        "settlement": "Valencia",
                        "country": "Spain"
                    }
                },
                "email": "slucas@dsic.upv.es"
            }
        ]
    },
    "abstract": [
        {
            "text": "We report on the new version of mu-term, a tool for proving termination properties of variants of rewrite systems, including conditional, context-sensitive, equational, and order-sorted rewrite systems. We follow a unified, logic-based approach to describe rewriting computations. The automatic generation of logical models for suitable firstorder theories and formulas provides a common basis to implement the proofs.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        },
        {
            "text": "Supported by EU (FEDER), and projects RTI2018-094403-B-C32,PROMETEO/ 2019/098, and SP20180225. Also by INCIBE program \"Ayudas para la excelencia de los equipos de investigaci\u00f3n avanzada en ciberseguridad\" (Ra\u00fal Guti\u00e9rrez).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "mu-term is a tool that can be used to automatically verify termination properties of variants of Term Rewriting Systems (TRSs): termination and innermost termination of TRSs using the DP Framework for TRSs [10] (this framework is also used to prove termination of String Rewriting Systems); termination and innermost termination of context-sensitive rewriting [16, 17] using the Context-Sensitive DP Framework [2, 13] ; termination of rewriting modulo associative/commutative theories using the A\u2228C-DP Framework [4] ; termination of order-sorted rewriting using the Order-Sorted DP Framework [22] ; and operational termination of Conditional TRSs (CTRSs) using the 2D DP Framework [24, 25] . In this setting, describing different kinds of rewriting computations as proofs of goals s \u2192 t and s \u2192 * t with respect to an appropriate inference system is useful. Such an approach, exploiting the logic-based description of rewriting computations, involves the use of several techniques which have been recently investigated elsewhere: (i) the generation logical models and well-founded relations [19] , (ii) modeling operational termination of CTRSs with conditional dependency pairs [23] , (iii) the use of removal triples [24] generated by logical models [25] , etc. Giving support to such techniques in termination proofs motivated the development of a new version of our tool, mu-term 6.0: http://zenon.dsic.upv.es/muterm",
            "cite_spans": [
                {
                    "start": 206,
                    "end": 210,
                    "text": "[10]",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 360,
                    "end": 364,
                    "text": "[16,",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 365,
                    "end": 368,
                    "text": "17]",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 410,
                    "end": 413,
                    "text": "[2,",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 414,
                    "end": 417,
                    "text": "13]",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 512,
                    "end": 515,
                    "text": "[4]",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 592,
                    "end": 596,
                    "text": "[22]",
                    "ref_id": "BIBREF25"
                },
                {
                    "start": 681,
                    "end": 685,
                    "text": "[24,",
                    "ref_id": "BIBREF27"
                },
                {
                    "start": 686,
                    "end": 689,
                    "text": "25]",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 1091,
                    "end": 1095,
                    "text": "[19]",
                    "ref_id": "BIBREF22"
                },
                {
                    "start": 1179,
                    "end": 1183,
                    "text": "[23]",
                    "ref_id": "BIBREF26"
                },
                {
                    "start": 1219,
                    "end": 1223,
                    "text": "[24]",
                    "ref_id": "BIBREF27"
                },
                {
                    "start": 1252,
                    "end": 1256,
                    "text": "[25]",
                    "ref_id": "BIBREF28"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "We report on the new logic-based approach followed by mu-term 6.0, and also on the new features included since the last description of the system in 2010 [3] .",
            "cite_spans": [
                {
                    "start": 154,
                    "end": 157,
                    "text": "[3]",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "In the following, we enumerate the new features of mu-term 6.0 and illustrate them with some examples. Examples are intended to provide a better understanding of the techniques and often display solutions not necessarily obtained by an automatic proof with the tool, where the use of a specific proof strategy combining a sequence of several techniques (see Sect. 3) may dismiss the focused technique. Although we use some examples from other papers, all proofs of (operational) termination displayed here are new. For instance, the CTRS in Example 1 was proved operationally terminating in [25, Example 33 ], but the use of models in Example 3 below to show the absence of a link in the dependency graph is new. Examples 6 and 7 (of Order-Sorted TRSs) are discussed and proved here for the first time.",
            "cite_spans": [
                {
                    "start": 591,
                    "end": 595,
                    "text": "[25,",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 596,
                    "end": 606,
                    "text": "Example 33",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "New Features of mu-term"
        },
        {
            "text": "Given an oriented CTRS R, with rules \u2192 r \u21d0 s 1 \u2248 t 1 , . . . , s n \u2248 t n , 1 an inference system I(R) is obtained from the following generic inference system I CTRS",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Logic-Based Representation of CTRSs"
        },
        {
            "text": ". . , s n \u2248 t n \u2208 R by specializing (C) f,i for each k-ary symbol f in the signature F and 1 \u2264 i \u2264 k, and (Rl) \u03b1 for all conditional rules \u03b1 : \u2192 r \u21d0 c in R. Rules B1 \u00b7\u00b7\u00b7 Bn A in I(R) are schematic: they can be used under any instance \u03c3(B1) \u00b7\u00b7\u00b7 \u03c3(Bn)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Logic-Based Representation of CTRSs"
        },
        {
            "text": "Operational termination of R is defined as the absence of infinite proof trees for goals s \u2192 t and s \u2192 * t in I(R) [21] . In the analysis of computational properties of R, we use the first-order theory R obtained from I(R) by translating the inference rules (\u03c1) B1 \u00b7\u00b7\u00b7 Bn A in I(R) into sentences \u03c1 of the form (\u2200x) B 1 \u2227 \u00b7 \u00b7 \u00b7 \u2227 B n \u21d2 A, for x the sequence of variables occurring in A, B 1 , . . . , B n [18, Sect. 4.5 ]. ",
            "cite_spans": [
                {
                    "start": 115,
                    "end": 119,
                    "text": "[21]",
                    "ref_id": "BIBREF24"
                },
                {
                    "start": 405,
                    "end": 409,
                    "text": "[18,",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 410,
                    "end": 419,
                    "text": "Sect. 4.5",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Logic-Based Representation of CTRSs"
        },
        {
            "text": "the theory R is given in Fig. 1 .",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 25,
                    "end": 31,
                    "text": "Fig. 1",
                    "ref_id": null
                }
            ],
            "section": "Logic-Based Representation of CTRSs"
        },
        {
            "text": "In [24, 25] a framework for automatically proving operational termination of (oriented) CTRSs using appropriate notions of dependency pairs (adapting the original notion for TRSs [5] ) has been introduced: the 2D DP Framework.",
            "cite_spans": [
                {
                    "start": 3,
                    "end": 7,
                    "text": "[24,",
                    "ref_id": "BIBREF27"
                },
                {
                    "start": 8,
                    "end": 11,
                    "text": "25]",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 179,
                    "end": 182,
                    "text": "[5]",
                    "ref_id": "BIBREF7"
                }
            ],
            "ref_spans": [],
            "section": "Operational Termination of Conditional Rewrite Systems"
        },
        {
            "text": "Dependency Pairs for CTRSs. Given a CTRS R, two new CTRSs DP H (R) and DP V (R) are introduced to capture the two horizontal and vertical dimensions of operational termination of CTRSs [23] : the usual absence of infinite rewrite sequences (termination), and the absence of infinite 'climbs' on a proof tree when trying to prove a goal s \u2192 t or s \u2192 * t (called V -termination). DP H (R) consists of rules u \u2192 v \u21d0 c whose terms u and v capture the progress of infinite rewrite sequences involving rules \u2192 r \u21d0 c with u and v marked versions of and a subterm of r respectively (only the root symbol f is marked as f , or just capitalized: F ). Similarly,",
            "cite_spans": [
                {
                    "start": 185,
                    "end": 189,
                    "text": "[23]",
                    "ref_id": "BIBREF26"
                }
            ],
            "ref_spans": [],
            "section": "Operational Termination of Conditional Rewrite Systems"
        },
        {
            "text": "As in [7, Sect. 5], we use a set of sorts S DP = {s, p} so that symbols f are (automatically) given a rank f : s \u00b7 \u00b7 \u00b7 s \u2192 s and marked symbols are given rank F : s \u00b7 \u00b7 \u00b7 s \u2192 p [25, Sect. 4.3] . Variables of formulas in R (e.g., Fig. 1 ) are then assumed to be universally quantified on sort s.",
            "cite_spans": [
                {
                    "start": 177,
                    "end": 181,
                    "text": "[25,",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 182,
                    "end": 192,
                    "text": "Sect. 4.3]",
                    "ref_id": null
                }
            ],
            "ref_spans": [
                {
                    "start": 229,
                    "end": 235,
                    "text": "Fig. 1",
                    "ref_id": null
                }
            ],
            "section": "Operational Termination of Conditional Rewrite Systems"
        },
        {
            "text": "The 2D DP Framework for CTRSs. The absence of infinite chains of 2D DPs (i.e., sequences of 2D DPs which model infinite branches in the proof trees for goals s \u2192 t and s \u2192 * t) characterizes operational termination of CTRSs [23] . This is proved using a divide-and-conquer strategy which successively decomposes operational termination problems into smaller and simpler ones. Processors P are used for this purpose [24] . They simplify problems by decomposing or shrinking them. In particular, the appropriate estimation of graphs G whose nodes are dependency pairs is useful to analyze the existence of such infinite chains as cycles in the graph. The absence of cycles implies operational termination. The presence of conditional rules and pairs introduces some particular issues which we enumerate, and discuss below.",
            "cite_spans": [
                {
                    "start": 224,
                    "end": 228,
                    "text": "[23]",
                    "ref_id": "BIBREF26"
                },
                {
                    "start": 415,
                    "end": 419,
                    "text": "[24]",
                    "ref_id": "BIBREF27"
                }
            ],
            "ref_spans": [],
            "section": "Operational Termination of Conditional Rewrite Systems"
        },
        {
            "text": "1. Some pairs could be infeasible, i.e., unable to be used in any of the aforementioned chains. Then, we could remove them [24, Sect. 4] . Also, arcs in G are defined by specific (often undecidable) sequences s 1 1 t 1 , . . . , s n n t n (called f-sequences [15] ) where s i and t i are terms and i are predicates \u2192 * i that capture the possibility of having two nodes involved in a chain [20, Sect. 4.5] and must be proved feasible or infeasible (for some substitution \u03c3 which applies to terms s i and t i ). A typical strategy is discarding arcs whose associated sequence is infeasible. We discuss this in paragraph Infeasibility in Termination Proofs below (see Examples 3 and 4). 2. Some pairs could be 'harmless', i.e., unable to be persistently used in any infinite chain. This can be shown if we prove a 'decrease' when such pairs are used in a chain. Again, we can remove them to obtain a simplification [25, Sect. 4.3] . We discuss this in paragraph Use of Well-Founded Relations below (see Example 5) .",
            "cite_spans": [
                {
                    "start": 123,
                    "end": 127,
                    "text": "[24,",
                    "ref_id": "BIBREF27"
                },
                {
                    "start": 128,
                    "end": 136,
                    "text": "Sect. 4]",
                    "ref_id": null
                },
                {
                    "start": 259,
                    "end": 263,
                    "text": "[15]",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 390,
                    "end": 394,
                    "text": "[20,",
                    "ref_id": "BIBREF23"
                },
                {
                    "start": 395,
                    "end": 405,
                    "text": "Sect. 4.5]",
                    "ref_id": null
                },
                {
                    "start": 913,
                    "end": 917,
                    "text": "[25,",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 918,
                    "end": 928,
                    "text": "Sect. 4.3]",
                    "ref_id": null
                },
                {
                    "start": 1001,
                    "end": 1011,
                    "text": "Example 5)",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Operational Termination of Conditional Rewrite Systems"
        },
        {
            "text": "Infeasibility in Termination Proofs. Given a (C)TRS R we say that a sequence",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Operational Termination of Conditional Rewrite Systems"
        },
        {
            "text": "In termination proofs, proving infeasibility is useful at different levels. As remarked above, when the conditional part c of a pair u \u2192 v \u21d0 c is proved infeasible, we can remove it. Also, the absence of an arc between two nodes (pairs) u \u2192 v \u21d0 c and u \u2192 v \u21d0 c in the graph G can be treated as the infeasibility of v \u2192 * u (where, as usual, we assume that v and u share no variable). For instance, for R in Example 1, it is possible to prove that there is no arc in the 'horizontal' graph which consists of a single node F(k(a), k(b), x) \u2192 F(x, x, x) (the only dependency pair in DP H (R)) by just finding a model of",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Operational Termination of Conditional Rewrite Systems"
        },
        {
            "text": "For this purpose, model generators AGES [14] and Mace4 [26] are used by mu-term.",
            "cite_spans": [
                {
                    "start": 40,
                    "end": 44,
                    "text": "[14]",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 55,
                    "end": 59,
                    "text": "[26]",
                    "ref_id": "BIBREF29"
                }
            ],
            "ref_spans": [],
            "section": "Operational Termination of Conditional Rewrite Systems"
        },
        {
            "text": "Example 3. We obtain a model A of (5) with Mace4. The domain is A = {0, 1} (Mace4 does not support sorts; thus, both s and p are merged into a single sort). Function and predicate symbols are interpreted as follows:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Operational Termination of Conditional Rewrite Systems"
        },
        {
            "text": "Discarding the arc would not be possible by the usual unification-based technique in [9] . With regard to infeasibility of pairs, consider the following wellknown example. ",
            "cite_spans": [
                {
                    "start": 85,
                    "end": 88,
                    "text": "[9]",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [],
            "section": "Operational Termination of Conditional Rewrite Systems"
        },
        {
            "text": "where",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Operational Termination of Conditional Rewrite Systems"
        },
        {
            "text": "We obtain a model with AGES. The domain is A = N \u2212 {0} (since no marked symbol is involved, we can use a single interpretation domain); for function and predicate symbols:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Operational Termination of Conditional Rewrite Systems"
        },
        {
            "text": "We can safely remove both pairs. Thus no infinite chain of pairs in DP H (R) exists.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Operational Termination of Conditional Rewrite Systems"
        },
        {
            "text": "The removal triple processor [24, Def. 70] implements the use of removal triples ( , , =), including a well-founded relation = to remove pairs from, and hence simplify, termination problems. For instance, as shown in [25, Sect. 4.3] , R in Example 1 is operationally terminating if we find a model A of",
            "cite_spans": [
                {
                    "start": 29,
                    "end": 33,
                    "text": "[24,",
                    "ref_id": "BIBREF27"
                },
                {
                    "start": 34,
                    "end": 42,
                    "text": "Def. 70]",
                    "ref_id": null
                },
                {
                    "start": 217,
                    "end": 221,
                    "text": "[25,",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 222,
                    "end": 232,
                    "text": "Sect. 4.3]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Use of Well-Founded Relations."
        },
        {
            "text": "where \u03c0 = (a new predicate symbol representing =) is interpreted as a wellfounded relation \u03c0 A = , and S RT R extends R with the following additional requirements to apply the processor [24, Definitions 68 and 69]:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Use of Well-Founded Relations."
        },
        {
            "text": "(\u2200x, y : p) x \u03c0 y \u2227 y \u03c0 = z \u21d2 x \u03c0 = z",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Use of Well-Founded Relations."
        },
        {
            "text": "(\u2200x, y : p) x \u2192 y \u21d2 x \u03c0 y (11) No predicate \u03c0 is necessary in this example (where a single pair is considered).",
            "cite_spans": [
                {
                    "start": 26,
                    "end": 30,
                    "text": "(11)",
                    "ref_id": "BIBREF13"
                }
            ],
            "ref_spans": [],
            "section": "Use of Well-Founded Relations."
        },
        {
            "text": "We obtain a model A of (9) with AGES. Domains are A p = {\u22121, 0, 1} and A s = {0, 1}. With regard to function and predicate symbols:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Example 5."
        },
        {
            "text": "where, as in the semantic approach in [25, Sect. 4.3] , \u2192 and \u2192 * are overloaded for sorts p and s; thus, \u22121) , (1, 0)} is well-founded on A p . Thus, we conclude operational termination of R.",
            "cite_spans": [
                {
                    "start": 38,
                    "end": 42,
                    "text": "[25,",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 43,
                    "end": 53,
                    "text": "Sect. 4.3]",
                    "ref_id": null
                }
            ],
            "ref_spans": [
                {
                    "start": 106,
                    "end": 109,
                    "text": "\u22121)",
                    "ref_id": null
                }
            ],
            "section": "Example 5."
        },
        {
            "text": "Sorts are often used to reinforce program termination. Order-sorted dependency pairs were introduced in [22] for proving termination of order-sorted TRSs.",
            "cite_spans": [
                {
                    "start": 104,
                    "end": 108,
                    "text": "[22]",
                    "ref_id": "BIBREF25"
                }
            ],
            "ref_spans": [],
            "section": "Termination of Order-Sorted Rewriting"
        },
        {
            "text": "Example 6. The following many-sorted TRS R in [29, Sect. 3.3] (in the hopefully self-explained Maude format [6] ) is a terminating version of Toyama's example, which is nonterminating as a TRS (i.e., without sort information):",
            "cite_spans": [
                {
                    "start": 108,
                    "end": 111,
                    "text": "[6]",
                    "ref_id": "BIBREF8"
                }
            ],
            "ref_spans": [],
            "section": "Termination of Order-Sorted Rewriting"
        },
        {
            "text": "mod Toyama-MS is sorts S1 S2 . ops a b : -> S1 . op f : S1 S1 S1 -> S1 . op g : S2 S2 -> S2 . vars x : S1 . vars y z : S2 . rl g(y,z) => y . rl g(y,z) => z . rl f(a,b,x) => f(x,x,x) . endm",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Termination of Order-Sorted Rewriting"
        },
        {
            "text": "The 2010 version of mu-term could not prove it terminating. 3 According to [22] , R has a single dependency pair:",
            "cite_spans": [
                {
                    "start": 75,
                    "end": 79,
                    "text": "[22]",
                    "ref_id": "BIBREF25"
                }
            ],
            "ref_spans": [],
            "section": "Termination of Order-Sorted Rewriting"
        },
        {
            "text": "where F has rank S1 S1 S1 \u2192 P for a new sort P [22, Sect. 3.2] and x has sort S1. We can prove that the dependency graph consisting of this single pair has no cycle. With AGES we can compute a model of R \u222a {\u00ac(\u2203x, y : S1) F(x, x, x) \u2192 * F(a, b, y)} which is as follows: A S1 = {0, 1}, A S2 = {1}, A P = \u2212N (i.e., the set of nonpositive integers), and functions and predicates interpreted as follows:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Termination of Order-Sorted Rewriting"
        },
        {
            "text": "The crucial point to obtain the proof in Example 6 is the ability to provide different interpretations to different sorts. The following example from [28] could not be handled by the 2010 version of mu-term because orderings were generated without paying attention to sorts (see [22, Sect. 6] ).",
            "cite_spans": [
                {
                    "start": 150,
                    "end": 154,
                    "text": "[28]",
                    "ref_id": "BIBREF31"
                },
                {
                    "start": 279,
                    "end": 283,
                    "text": "[22,",
                    "ref_id": "BIBREF25"
                },
                {
                    "start": 284,
                    "end": 292,
                    "text": "Sect. 6]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Termination of Order-Sorted Rewriting"
        },
        {
            "text": "mod Example11-OL96 is sorts S S1 S2 S3 S4 . subsorts S1 S2 S3 S4 < S . ops f g : S -> S . op g : S3 -> S1 . op g : S4 -> S2 . op h : S1 -> S2 .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Example 7. The following OS-TRS R [28, Example 11] is nonterminating as a TRS:"
        },
        {
            "text": "op a : -> S3 . op b : -> S4 . var x : S1 .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Example 7. The following OS-TRS R [28, Example 11] is nonterminating as a TRS:"
        },
        {
            "text": "There is a single OS-DP for R: F(x) \u2192 F(h(x)), where F has rank S \u2192 P for a new sort P and x has sort S1. We can prove termination of R by finding a removal triple ( , , =) such that the rules of R are compatible with , and F(x) = F(h(x)) holds whenever x ranges on terms of sort S1. With AGES we obtain an interpretation A as follows: sorts are interpreted as",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Example 7. The following OS-TRS R [28, Example 11] is nonterminating as a TRS:"
        },
        {
            "text": "Functions and predicates are interpreted as follows:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Example 7. The following OS-TRS R [28, Example 11] is nonterminating as a TRS:"
        },
        {
            "text": "(where different overloaded versions of g use the input sort as a subindex) and",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Example 7. The following OS-TRS R [28, Example 11] is nonterminating as a TRS:"
        },
        {
            "text": "Note that the interpretation of the 'original' rewrite relation concerns sort S only because it is the top sort of the full sort hierarchy.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Example 7. The following OS-TRS R [28, Example 11] is nonterminating as a TRS:"
        },
        {
            "text": "In context-sensitive rewriting (CSR [16] ), a replacement map \u03bc is used to restrict the arguments \u03bc(f ) \u2286 {1, . . . , k} which can be rewritten for each k-ary symbol f . The restriction on arguments is top-down propagated to positions of terms t, which are called active positions of t. We write s \u2192 t if an active subterm of s can be rewritten so that s \u2192 t. In the dependency pair approach for proving termination of CSR [2] , rules of the form f ( 1 , . . . , k ) \u2192 r are given dependency  pairs f ( 1 , . . . , k ) \u2192 g (s 1 , . . . , s m ), for s = g(s 1 , . . . , s m ) a replacing subterm of r (i.e., a subterm s = r| p occurring at an active position p of r) and g a defined symbol. The notation f means that f is marked (capital letters F are often used instead of f ). However, due to rules \u2192 r \u2208 R with migrating variables x \u2208 Var \u03bc (r)\\Var \u03bc ( ) (that are frozen, i.e., not active, in but become active in r, possibly 'awaking' infinite rewrite sequences), we also need collapsing dependency pairs \u2192 x where x is a migrating variable of the rule. ",
            "cite_spans": [
                {
                    "start": 36,
                    "end": 40,
                    "text": "[16]",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 423,
                    "end": 426,
                    "text": "[2]",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [
                {
                    "start": 481,
                    "end": 574,
                    "text": "dependency  pairs f ( 1 , . . . , k ) \u2192 g (s 1 , . . . , s m ), for s = g(s 1 , . . . , s m )",
                    "ref_id": null
                }
            ],
            "section": "Termination of Context-Sensitive Rewriting"
        },
        {
            "text": "Collapsing pairs capture a kind of recursion which is hidden below frozen parts of the terms involved in infinite context-sensitive rewrite sequences until a migrating variable within a rule \u2192 r shows them up. The hidden terms of a TRS R are defined subterms occurring at frozen positions in the rhs of some rule of R [2] . Hiding contexts are contexts where hidden terms can occur at active positions within a context-sensitive rewrite sequence [1, 13] . There, hidden terms can restart a delayed recursive call after the application of a rule with migrating variables (see [12] for a detailed analysis). For R and \u03bc in Example 8, the only rule with hidden terms is fact(x) \u2192 if(zero(x), s(0), fact(p(x)) \u00d7 x). Symbols fact and '\u00d7' hide position 1 because p(x) is rooted by a defined symbol. Symbol '\u00d7' does not hide position 2. Symbol p hides no position. The refinements introduced in [12] have led to a more precise notion of hidden terms and contexts, enabling a better analysis of the connections between them. This has greatly improved the ability of mu-term to prove termination of CSR. For instance, the proof of termination of R and \u03bc in Example 8, which could not be obtained with the 2010 version of mu-term, is now possible with mu-term 6.0, see the proof of CSR 04/ExIntrod Zan97.xml in the 2019 Termination Competition http://group-mmm.org/termination/competitions/Y2019/caches/ termination 33019.html or in our local benchmarks: http://zenon.dsic.upv.es/muterm/benchmarks/ijcar20/TRS Contextsensitive/benchmarks.html",
            "cite_spans": [
                {
                    "start": 318,
                    "end": 321,
                    "text": "[2]",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 446,
                    "end": 449,
                    "text": "[1,",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 450,
                    "end": 453,
                    "text": "13]",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 575,
                    "end": 579,
                    "text": "[12]",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 888,
                    "end": 892,
                    "text": "[12]",
                    "ref_id": "BIBREF14"
                }
            ],
            "ref_spans": [],
            "section": "Example 8. For the following TRS R in [30, Introduction]"
        },
        {
            "text": "The arbitrary application of processors can generate a huge search space. Furthermore, proofs usually proceed under some timeout. For this reason, we need to choose a fixed strategy where fast processors that reduce the number of rules are first used, and slow processors, or processors that increase the number of rules, are used when fast processors fail. Hence, the frequency of use for the different processors depends on the chosen strategy. With small differences depending on the particular kind of problem, we do the following:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Termination Expert"
        },
        {
            "text": "1. If R is a TRS or a CS-TRS, we check whether the system is innermost equivalent [3, Sect. 2.2]. If it is true, then we transform the problem into an innermost one. 2. Then, we obtain the corresponding dependency pairs, obtaining a CTRS, OS, CS, or DP problem. Then we perform the following steps repeatedly (a) Decision point between processors for proving (operational) nontermination and the strongly connected component (SCC) processor. (b) Subterm criterion processor. (c) Removal triple processor generating models with AGES (we try different configurations, from simpler to more complex). (d) If R is a CTRS, we apply simplification and removal processors on the conditions (using AGES when a model is necessary). (e) Transformation processors on rules, pairs and conditions: instantiation, forward instantiation, and narrowing.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Termination Expert"
        },
        {
            "text": "Full explanations of the processors can be found in [4, 12, 13, 19, 20, 24, 25] . The mu-term 6.0 logic-based approach has led to dramatic improvements, as reported here:",
            "cite_spans": [
                {
                    "start": 52,
                    "end": 55,
                    "text": "[4,",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 56,
                    "end": 59,
                    "text": "12,",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 60,
                    "end": 63,
                    "text": "13,",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 64,
                    "end": 67,
                    "text": "19,",
                    "ref_id": "BIBREF22"
                },
                {
                    "start": 68,
                    "end": 71,
                    "text": "20,",
                    "ref_id": "BIBREF23"
                },
                {
                    "start": 72,
                    "end": 75,
                    "text": "24,",
                    "ref_id": "BIBREF27"
                },
                {
                    "start": 76,
                    "end": 79,
                    "text": "25]",
                    "ref_id": "BIBREF28"
                }
            ],
            "ref_spans": [],
            "section": "Termination Expert"
        },
        {
            "text": "http://zenon.dsic.upv.es/muterm/benchmarks/ijcar20/Comparison/ benchmarks.html where the use of logical models is compared with the exclusive use of polynomial interpretations (as in mu-term 5.0). Polynomial interpretations are strictly less powerful in terms of solved examples (as every proof using polynomial interpretations can be obtained using the new logic-based approach). However, we keep them in mu-term 6.0 as they lead to faster proofs. We use polynomial interpretations as part of mu-term 6.0 strategy (via the removal triple processor). mu-term 6.0 consists of more than 30000 lines of Haskell code. In the webbased interface, besides the fully automatic use of the termination expert, we can also use specific techniques like polynomial orderings, matrix interpretations, (context-sensitive) recursive path ordering, etc., which we have found useful for teaching purposes.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Termination Expert"
        },
        {
            "text": "Since 2014, mu-term has proven to be the most powerful tool for proving operational termination of conditional rewriting and termination of contextsensitive rewriting, each year winning the corresponding subcategory of the annual International Competition of Termination Tools, see http://zenon.dsic. upv.es/muterm/?page id=82 for an historical account. In the CSR subcategory, since 2014 mu-term is able to prove all the examples proved by any other participating tool (thanks to the results in [12] ).",
            "cite_spans": [
                {
                    "start": 496,
                    "end": 500,
                    "text": "[12]",
                    "ref_id": "BIBREF14"
                }
            ],
            "ref_spans": [],
            "section": "Experimental Evaluation"
        },
        {
            "text": "The benchmarks web page of mu-term reports on specific experiments comparing the 2010 and 2020 versions. First, the 2010 version did not support CTRSs. For CS-TRSs, three new examples can be proved now (and all the examples handled by the 2010 version are also handled now). As for OS-TRSs, mu-term 6.0 is able to prove or disprove termination of all the OS-TRSs in the 2010 benchmark suite (except a non-sort-decreasing OS-TRS, not covered by the theory in [22] , where sort-decreasingness [11] is required). The 2010 version could not disprove termination of OS-TRSs.",
            "cite_spans": [
                {
                    "start": 458,
                    "end": 462,
                    "text": "[22]",
                    "ref_id": "BIBREF25"
                },
                {
                    "start": 491,
                    "end": 495,
                    "text": "[11]",
                    "ref_id": "BIBREF13"
                }
            ],
            "ref_spans": [],
            "section": "Experimental Evaluation"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Improving context-sensitive dependency pairs",
            "authors": [
                {
                    "first": "B",
                    "middle": [],
                    "last": "Alarc\u00f3n",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "LPAR 2008",
            "volume": "5330",
            "issn": "",
            "pages": "636--651",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "Context-sensitive dependency pairs",
            "authors": [
                {
                    "first": "B",
                    "middle": [],
                    "last": "Alarc\u00f3n",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Guti\u00e9rrez",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Lucas",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "Inf. Comput",
            "volume": "208",
            "issn": "8",
            "pages": "922--968",
            "other_ids": {
                "DOI": [
                    "10.1016/j.ic.2010.03.003"
                ]
            }
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Proving termination properties with mu-term",
            "authors": [
                {
                    "first": "B",
                    "middle": [],
                    "last": "Alarc\u00f3n",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Guti\u00e9rrez",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Lucas",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Navarro-Marset",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "A dependency pair framework for A \u2228 Ctermination",
            "authors": [
                {
                    "first": "B",
                    "middle": [],
                    "last": "Alarc\u00f3n",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Lucas",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Meseguer",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "WRLA 2010",
            "volume": "6381",
            "issn": "",
            "pages": "35--51",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Termination of term rewriting using dependency pairs",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Arts",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Giesl",
                    "suffix": ""
                }
            ],
            "year": 2000,
            "venue": "Theor. Comput. Sci",
            "volume": "236",
            "issn": "1-2",
            "pages": "207--215",
            "other_ids": {
                "DOI": [
                    "10.1016/S0304-3975(99)00207-8"
                ]
            }
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "All About Maude -A High-Performance Logical Framework",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Clavel",
                    "suffix": ""
                }
            ],
            "year": 2007,
            "venue": "LNCS",
            "volume": "4350",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-540-71999-1"
                ]
            }
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "Matrix interpretations for proving termination of term rewriting",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Endrullis",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Waldmann",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Zantema",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "J. Autom. Reasoning",
            "volume": "40",
            "issn": "2-3",
            "pages": "195--220",
            "other_ids": {
                "DOI": [
                    "10.1007/s10817-007-9087-9"
                ]
            }
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "Verification of erlang processes by dependency pairs",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Giesl",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Arts",
                    "suffix": ""
                }
            ],
            "year": 2001,
            "venue": "Appl. Algebra Eng. Commun. Comput",
            "volume": "12",
            "issn": "1/2",
            "pages": "39--72",
            "other_ids": {
                "DOI": [
                    "10.1007/s002000100063"
                ]
            }
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "Proving and disproving termination of higher-order functions",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Giesl",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Thiemann",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Schneider-Kamp",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "FroCoS 2005",
            "volume": "3717",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1007/11559306_12"
                ]
            }
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "Mechanizing and improving dependency pairs",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Giesl",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Thiemann",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Schneider-Kamp",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Falke",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "J. Autom. Reasoning",
            "volume": "37",
            "issn": "3",
            "pages": "155--203",
            "other_ids": {
                "DOI": [
                    "10.1007/s10817-006-9057-7"
                ]
            }
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "Order-sorted algebra I: equational deduction for multiple inheritance, overloading, exceptions and partial operations",
            "authors": [
                {
                    "first": "J",
                    "middle": [
                        "A"
                    ],
                    "last": "Goguen",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Meseguer",
                    "suffix": ""
                }
            ],
            "year": 1992,
            "venue": "Theor. Comput. Sci",
            "volume": "105",
            "issn": "2",
            "pages": "217--273",
            "other_ids": {
                "DOI": [
                    "10.1016/0304-3975(92)90302-V"
                ]
            }
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "Function calls at frozen positions in termination of context-sensitive rewriting",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Guti\u00e9rrez",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Lucas",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "Logic, Rewriting, and Concurrency",
            "volume": "9200",
            "issn": "",
            "pages": "311--330",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-23165-5_15"
                ]
            }
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "Proving termination in the context-sensitive dependency pair framework",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Guti\u00e9rrez",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Lucas",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "WRLA 2010",
            "volume": "6381",
            "issn": "",
            "pages": "18--34",
            "other_ids": {}
        },
        "BIBREF17": {
            "ref_id": "b17",
            "title": "Automatic generation of logical models with AGES",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Guti\u00e9rrez",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Lucas",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "CADE 2019",
            "volume": "11716",
            "issn": "",
            "pages": "287--299",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-030-29436-6_17"
                ]
            }
        },
        "BIBREF18": {
            "ref_id": "b18",
            "title": "Automatically proving and disproving feasibility conditions",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Guti\u00e9rrez",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Lucas",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "IJCAR 2020. LNAI",
            "volume": "12167",
            "issn": "",
            "pages": "416--435",
            "other_ids": {}
        },
        "BIBREF19": {
            "ref_id": "b19",
            "title": "Context-sensitive computations in functional and functional logic programs",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Lucas",
                    "suffix": ""
                }
            ],
            "year": 1998,
            "venue": "J. Funct. Log. Program",
            "volume": "1998",
            "issn": "1",
            "pages": "1--61",
            "other_ids": {}
        },
        "BIBREF20": {
            "ref_id": "b20",
            "title": "Context-sensitive rewriting strategies",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Lucas",
                    "suffix": ""
                }
            ],
            "year": 2002,
            "venue": "Inf. Comput",
            "volume": "178",
            "issn": "1",
            "pages": "294--343",
            "other_ids": {
                "DOI": [
                    "10.1006/inco.2002.3176"
                ]
            }
        },
        "BIBREF21": {
            "ref_id": "b21",
            "title": "Proving semantic properties as first-order satisfiability",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Lucas",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Artif. Intell",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1016/j.artint.2019.103174"
                ]
            }
        },
        "BIBREF22": {
            "ref_id": "b22",
            "title": "Automatic synthesis of logical models for order-sorted first-order theories",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Lucas",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Guti\u00e9rrez",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "J. Autom. Reasoning",
            "volume": "60",
            "issn": "4",
            "pages": "465--501",
            "other_ids": {
                "DOI": [
                    "10.1007/s10817-017-9419-3"
                ]
            }
        },
        "BIBREF23": {
            "ref_id": "b23",
            "title": "Use of logical models for proving infeasibility in term rewriting",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Lucas",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Guti\u00e9rrez",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Inf. Process. Lett",
            "volume": "136",
            "issn": "",
            "pages": "90--95",
            "other_ids": {
                "DOI": [
                    "10.1016/j.ipl.2018.04.002"
                ]
            }
        },
        "BIBREF24": {
            "ref_id": "b24",
            "title": "Operational termination of conditional term rewriting systems",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Lucas",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "March\u00e9",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Meseguer",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "Inf. Process. Lett",
            "volume": "95",
            "issn": "4",
            "pages": "446--453",
            "other_ids": {
                "DOI": [
                    "10.1016/j.ipl.2005.05.002"
                ]
            }
        },
        "BIBREF25": {
            "ref_id": "b25",
            "title": "Order-sorted dependency pairs",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Lucas",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Meseguer",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "Proceedings of the 10th International ACM SIGPLAN Conference on Principles and Practice of Declarative Programming",
            "volume": "",
            "issn": "",
            "pages": "108--119",
            "other_ids": {
                "DOI": [
                    "10.1145/1389449.1389463"
                ]
            }
        },
        "BIBREF26": {
            "ref_id": "b26",
            "title": "Dependency pairs for proving termination properties of conditional term rewriting systems",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Lucas",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Meseguer",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "J. Log. Algebraic Methods Program",
            "volume": "86",
            "issn": "1",
            "pages": "236--268",
            "other_ids": {
                "DOI": [
                    "10.1016/j.jlamp.2016.03.003"
                ]
            }
        },
        "BIBREF27": {
            "ref_id": "b27",
            "title": "The 2D dependency pair framework for conditional rewrite systems. Part I: Definition and basic processors",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Lucas",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Meseguer",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Guti\u00e9rrez",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "J. Comput. Syst. Sci",
            "volume": "96",
            "issn": "",
            "pages": "74--106",
            "other_ids": {
                "DOI": [
                    "10.1016/j.jcss.2018.04.002"
                ]
            }
        },
        "BIBREF28": {
            "ref_id": "b28",
            "title": "The 2D dependency pair framework for conditional rewrite systems-part II: advanced processors and implementation techniques",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Lucas",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Meseguer",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Guti\u00e9rrez",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "J. Autom. Reasoning",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1007/s10817-020-09542-3"
                ]
            }
        },
        "BIBREF29": {
            "ref_id": "b29",
            "title": "Prover9 & Mace4",
            "authors": [
                {
                    "first": "W",
                    "middle": [],
                    "last": "Mccune",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF30": {
            "ref_id": "b30",
            "title": "Advanced Topics in Term Rewriting",
            "authors": [
                {
                    "first": "E",
                    "middle": [],
                    "last": "Ohlebusch",
                    "suffix": ""
                }
            ],
            "year": 2002,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1007/978-1-4757-3661-8"
                ]
            }
        },
        "BIBREF31": {
            "ref_id": "b31",
            "title": "Order-sorted termination: the unsorted way",
            "authors": [
                {
                    "first": "P",
                    "middle": [
                        "C"
                    ],
                    "last": "\u00d6lveczky",
                    "suffix": ""
                },
                {
                    "first": "O",
                    "middle": [],
                    "last": "Lysne",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "ALP 1996",
            "volume": "1139",
            "issn": "",
            "pages": "92--106",
            "other_ids": {}
        },
        "BIBREF33": {
            "ref_id": "b33",
            "title": "Termination of term rewriting: interpretation and type elimination",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Zantema",
                    "suffix": ""
                }
            ],
            "year": 1994,
            "venue": "J. Symb. Comput",
            "volume": "17",
            "issn": "1",
            "pages": "23--50",
            "other_ids": {
                "DOI": [
                    "10.1006/jsco.1994.1003"
                ]
            }
        },
        "BIBREF34": {
            "ref_id": "b34",
            "title": "Termination of context-sensitive rewriting",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Zantema",
                    "suffix": ""
                }
            ],
            "year": 1997,
            "venue": "RTA 1997",
            "volume": "1232",
            "issn": "",
            "pages": "172--186",
            "other_ids": {
                "DOI": [
                    "10.1007/3-540-62950-5_69"
                ]
            }
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "Consider the following CTRS R [8, p. 46]:",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "s(0), fact(p(x)) \u00d7 x) and \u03bc given by \u03bc(if) = {1} and \u03bc(f ) = {1, . . . , k} for any other k-ary symbol f [12, Example 1]. DP(R, \u03bc) consists of pairs",
            "latex": null,
            "type": "figure"
        }
    },
    "back_matter": [
        {
            "text": "We thank the anonymous referees for many remarks and suggestions that led to improve the paper.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Acknowledgments."
        }
    ]
}