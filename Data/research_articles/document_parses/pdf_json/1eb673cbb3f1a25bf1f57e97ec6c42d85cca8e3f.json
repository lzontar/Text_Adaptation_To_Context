{"paper_id": "1eb673cbb3f1a25bf1f57e97ec6c42d85cca8e3f", "metadata": {"title": "Formal Distributed Protocol Development for Reservation of Railway Sections", "authors": [{"first": "Paulius", "middle": [], "last": "Stankaitis", "suffix": "", "affiliation": {"laboratory": "", "institution": "Newcastle University", "location": {"settlement": "Newcastle upon Tyne", "country": "UK"}}, "email": "p.stankaitis@newcastle.ac.uk"}, {"first": "Alexei", "middle": [], "last": "Iliasov", "suffix": "", "affiliation": {"laboratory": "", "institution": "Newcastle University", "location": {"settlement": "Newcastle upon Tyne", "country": "UK"}}, "email": ""}, {"first": "Tsutomu", "middle": [], "last": "Kobayashi", "suffix": "", "affiliation": {"laboratory": "", "institution": "National Institute of Informatics", "location": {"settlement": "Tokyo", "country": "Japan"}}, "email": ""}, {"first": "Yamine", "middle": [], "last": "A\u00eft-Ameur", "suffix": "", "affiliation": {"laboratory": "", "institution": "National Institute of Informatics", "location": {"settlement": "Tokyo", "country": "Japan"}}, "email": ""}, {"first": "Alexander", "middle": [], "last": "Romanovsky", "suffix": "", "affiliation": {"laboratory": "", "institution": "Newcastle University", "location": {"settlement": "Newcastle upon Tyne", "country": "UK"}}, "email": ""}]}, "abstract": [{"text": "The decentralisation of railway signalling systems has the potential to increase railway network capacity, availability and reduce maintenance costs. Given the safety-critical nature of railway signalling and the complexity of novel distributed signalling solutions, their safety should be guaranteed by using thorough system validation methods. In this paper, we present a rigorous formal development and verification of a distributed protocol for reservation of railway sections, which we believe could deliver benefits of a decentralised signalling while ensuring safety and liveness properties. For the formal distributed protocol development and verification, we devised a multifaceted framework, which aims to reduce modelling and verification effort, while still providing complementary techniques to study protocol from all relevant perspectives.", "cite_spans": [], "ref_spans": [], "section": "Abstract"}], "body_text": [{"text": "Railway signalling is a safety-critical system whose responsibility is to guarantee a safe and efficient operation of railway networks. In recent decades there have been proposals to utilize distributed system concepts (e.g. [13, 24] ) in railway signalling as a way to increase railway network capacity and reduce maintenance costs. These emerging distributed railway signalling concepts propose using a radio-based communication technology to decentralise contemporaneous signalling systems 1 . Because of their complex concurrent behaviour, distributed systems are notoriously difficult to validate and this could curtail the development and deployment of novel distributed signalling solutions.", "cite_spans": [{"start": 225, "end": 229, "text": "[13,", "ref_id": "BIBREF13"}, {"start": 230, "end": 233, "text": "24]", "ref_id": "BIBREF24"}], "ref_spans": [], "section": "Introduction"}, {"text": "In recent years there has been a push (e.g. [12, 22] ) by the industry with a strong focus on distributed systems to incorporate formal methods into their system development processes to improve system assurance and time-to-market. Yet, despite that for years the railway domain has proved to be a fruitful area for applying various formal methods [3, 7] , considerably less has been done in applying them for distributed railway systems by industry and academia. Therefore, the long-term aim of our research is to lower the effort the barriers to applying formal methods in developing correct-by-construction distributed signalling systems.", "cite_spans": [{"start": 44, "end": 48, "text": "[12,", "ref_id": "BIBREF12"}, {"start": 49, "end": 52, "text": "22]", "ref_id": "BIBREF22"}, {"start": 348, "end": 351, "text": "[3,", "ref_id": "BIBREF2"}, {"start": 352, "end": 354, "text": "7]", "ref_id": "BIBREF6"}], "ref_spans": [], "section": "Introduction"}, {"text": "In order to manage the modelling and verification complexity of distributed protocols we are working towards an integrated multifaceted methodology, which is based on three concepts: stepwise renement, communication modelling patterns and validation through proofs. In spite of advancements in proof automation, it might be too onerous to mathematically prove the model in early development stages. Therefore, it is also desirable that the framework should support model animation and scenario validation. It is also paramount that the framework should support quantitative evaluation; as stated by Fantechi and Haxthausen [10] , distributed signalling solutions will only be adopted in practice if system availability is demonstrated. The authors (as discussed in [10] ) of related researches did not consider liveness and fairness properties, which directly affect system availability. In our proposed multifaceted methodology we integrate stochastic simulators for quantitative analysis.", "cite_spans": [{"start": 623, "end": 627, "text": "[10]", "ref_id": "BIBREF10"}, {"start": 765, "end": 769, "text": "[10]", "ref_id": "BIBREF10"}], "ref_spans": [], "section": "Introduction"}, {"text": "In this paper, we present a research, which uses the proposed methodology to formally develop and verify a distributed railway signalling protocol, which would deliver decentralised signalling benefits, while meeting high safety requirements. The developed distributed signalling protocol is based on serialisability and is inspired by protocols used in transactions processing [4, 8, 11] in centralised and distributed database systems. The main objective of our protocol is to guarantee mutual exclusion of railway sections while ensuring systems liveness. In a nutshell, our key contributions are the formally proved distributed railway section allocation protocol inspired by past protocols for database systems and the formalisation of the multifaceted verification framework.", "cite_spans": [{"start": 378, "end": 381, "text": "[4,", "ref_id": "BIBREF3"}, {"start": 382, "end": 384, "text": "8,", "ref_id": "BIBREF8"}, {"start": 385, "end": 388, "text": "11]", "ref_id": "BIBREF11"}], "ref_spans": [], "section": "Introduction"}, {"text": "Related Work. In Fantechi and Haxthausen [10] the authors formalise the railway interlocking problem as a distributed mutual exclusion problem and discuss the related literature on distributed interlocking (e.g. [9, 13, 24] ). In principle all railway models share similar high-level safety, liveness and fairness requirements, as summarised on page 2 in [10] . One difference between our work and the studies overviewed in [10] is the interlocking engineering concept and the system model (e.g. allowed message delays). Another difference is the formal consideration of liveness and fairness requirements. In our work we not only prove the safety properties of the protocol, but also ensure systems liveness, fairness and analyse performance.", "cite_spans": [{"start": 41, "end": 45, "text": "[10]", "ref_id": "BIBREF10"}, {"start": 212, "end": 215, "text": "[9,", "ref_id": "BIBREF9"}, {"start": 216, "end": 219, "text": "13,", "ref_id": "BIBREF13"}, {"start": 220, "end": 223, "text": "24]", "ref_id": "BIBREF24"}, {"start": 355, "end": 359, "text": "[10]", "ref_id": "BIBREF10"}, {"start": 424, "end": 428, "text": "[10]", "ref_id": "BIBREF10"}], "ref_spans": [], "section": "Introduction"}, {"text": "A similar distributed signalling concept is presented as a case study in [1] . The authors verified their system design via a simulation approach and only considered scenarios with up to two trains. In our verification approach we prove the distributed signalling system mathematically and hence guarantee its safety for any number of trains. In the paper by Morley [21] the author formally proved a distributed protocol, which is used in the real-world railway signalling systems to reserve a route, which is jointly controlled by adjacent signalling systems. Even though, the distributed signalling concepts of our works are different, the effects of message delays to the safety were considered in both works.", "cite_spans": [{"start": 73, "end": 76, "text": "[1]", "ref_id": "BIBREF0"}, {"start": 366, "end": 370, "text": "[21]", "ref_id": "BIBREF21"}], "ref_spans": [], "section": "Introduction"}, {"text": "The rest of the paper is organised as follows. Section 2 outlines the motivation for developing the protocol, semi-formally describes its functionality, elicits the requirements and introduces its specifications and the properties to be proved. Section 3 further discusses the integrated methodology we are proposing. The following section briefly discusses formal model development and also provides technical details on property verication and performance analysis. In the last section we summarise our work and discuss future work directions.", "cite_spans": [], "ref_spans": [], "section": "Introduction"}, {"text": "The distributed railway signalling can increase networks capacity (as trains could run closer), improve systems agility to delays and possibly reduce repair costs. On the other hand, an increased system complexity and a safety-critical (SIL4) nature requires the highest level of safety assurance. In order to apply formal methods one must clearly state system requirements and specifications. In the following subsections we describe an abstract model of the distributed railway system and its requirements as well as the stage 1 of the distributed protocol, which guarantees the safety and liveness of the distributed system.", "cite_spans": [], "ref_spans": [], "section": "Distributed Resource Allocation Model and Protocol"}, {"text": "We abstract the railway model and instead of trains, routes and switches our system model consists of agents and resources (resources controllers). The system model permits message exchanges only between agents and resources, and messages can be delayed. Each resource controller has an associated queue-like memory, where agents allocation order can be stored. A resource also has a promise (ppt) and read pointers (rpt), which respectively indicate the currently available slot in the queue and the reserved slot (with an associated agent) that currently uses the resource. An agent has an objective, which is a collection of resources an agent will attempt to reserve (all at the same time) before using and eventually releasing them. SAF 1 | A resource will not be allocated to different agents at the same time. SAF 2 | An agent will not use a resource until all requested resources are allocated. LIV 1 | An agent must be eventually allocated requested set of resources. LIV 2 | Resource allocation must be guaranteed in the presence of message delays.", "cite_spans": [], "ref_spans": [], "section": "High-Level Distributed System Model and Requirements"}, {"text": "The main objective of the protocol is to enable safe and deadlock-free distributed atomic reservation of collection of resources. Where by a safe resource reservation we mean that no two different agents have reserved the same resource at the same time. The protocol must also guarantee that each agent eventually gets all requested resources -partial request satisfaction is not permitted. The main high-level safety and liveness requirements of the distributed system are expressed in Requirements 1.", "cite_spans": [], "ref_spans": [], "section": "Requirements 1: High-level systems safety and liveness requirements"}, {"text": "The following section attempts to justify the need for an adequate distribute protocol by discussing problematic distributed resource allocation scenarios.", "cite_spans": [], "ref_spans": [], "section": "Requirements 1: High-level systems safety and liveness requirements"}, {"text": "Let us consider Scenarios 1-2 (visualised in Fig. 1 ) to see how requirement LIV 1 could not be guaranteed (while ensuring SAF 2 ) without an adequate distributed resource allocation protocol. Scenario 1. In this scenario, agents a 0 and a 1 are attempting to reserve the same set of resources {r 0 , r 1 }. Agents start by firstly sending request messages to both resources. Once a resource receives a request message, it replies with the current value of the promised pointer (ppt(r k )) and then increments the ppt(r k ). For instance, in this scenario, resource r 0 firstly received a request message from agent a 0 and thus replied with the value ppt(r 0 ) = 0, which was then followed by a message to a 1 with an incremented ppt(r 0 ) value of 1. In Figure, we denote a * n as the ppt(r k ) value sent to a n . Request messages at resource r 1 have been received and replied in the opposite order.", "cite_spans": [], "ref_spans": [{"start": 45, "end": 51, "text": "Fig. 1", "ref_id": "FIGREF0"}, {"start": 756, "end": 763, "text": "Figure,", "ref_id": null}], "section": "Problematic Distributed Resource Allocation Scenarios"}, {"text": "In this preliminary protocol, after an agent receives promised pointer values from all requested resources, it sends messages to requested resources to lock them at the promised queue-slot. In this scenario, agent a 0 was promised queue-slots {(r 0 , 0), (r 1 , 1)} while a 1 queue-slots {(r 0 , 1), (r 1 , 0)}. If agents would lock these exact queue-slots, resource r 0 would allow a 0 to use it first, while r 1 would concurrently allow a 1 . The distributed system would deadlock and fail to satisfy LIV 2 requirement as both agents would wait for the second use message to ensure SAF 2 . In order to prevent the cross-blocking type of deadlocks, an agent should repeatedly re-request the same set of resources (and not lock them) until all received promised queue slot values are the same. We define a process of an agent attempting to receive the same promised queue slots as an agent forming a distributed lane (dl).", "cite_spans": [], "ref_spans": [], "section": "Problematic Distributed Resource Allocation Scenarios"}, {"text": "A distributed lane of agent a n is dl(a n ) = {(r k , s), (r k+1 , s), . . . , (r k+m , s)}, where {r k , r k+1 , . . . , r k+m } are all resources requested by agent a n and s is the queue slot value promised by all requested resources. Important to note, that this solution relies on the assumption, that there is a non-zero probability of distinct messages arriving at the same destination in different orders, even if they are simultaneously sent by different sources.", "cite_spans": [], "ref_spans": [], "section": "Problematic Distributed Resource Allocation Scenarios"}, {"text": "The modified situation is depicted in Scenario 1, where, after agents {a 0 , a 1 } initially receiving {(r 0 , 0), (r 1 , 1)} and {(r 0 , 1), (r 1 , 0)} slots, mutually re-request resources again. This time they receive {(r 0 , 2), (r 1 , 2)} and {(r 0 , 3), (r 1 , 3)} slots, and are able to form distributed lanes dl 0 (a 0 ) and dl 1 (a 1 ).", "cite_spans": [], "ref_spans": [], "section": "Problematic Distributed Resource Allocation Scenarios"}, {"text": "However, simply re-requesting the same resources might result in a different problem. In Scenario 2, agent a 1 has requested and has been allocated a single resource r 1 which in turn modified ppt(r 1 ) to 1 while ppt(r 0 ) remained 0. If another agent a 0 attempts to reserve resources {r 0 , r 1 }, it will never receive the same promised pointer values from both resources, and hence, will not be able to lock them.", "cite_spans": [], "ref_spans": [], "section": "Scenario 2."}, {"text": "To address the two issue described above, we developed a two-stage protocol, where the stage 1 of the distributed protocol specifies how an agent forms a distributed lane. Stage 2 of the protocol, which is out of this paper scope, addresses other deadlock scenarios, which can occur after agents form distributed lanes. In the following subsection we semi-formally describe the stage 1 of the protocol.", "cite_spans": [], "ref_spans": [], "section": "Scenario 2."}, {"text": "An agent, which intends to reserve a set of resources starts by sending request messages to resources. The messages are sent to those resources which are part of agents current objective. In the provided pseudocode excerpt, we first denote relations sent requests and objective where they are mappings from agents to resource collections (ln. 1-3 Algorithm 1). The messages request are sent by an agent a n to a resource r k (r k \u2208 objective[a n ]) until sent requests[a n ] = objective[a n ] (images are equal). When a resource r k receives a request message from an agent a n it responds with a reply message which contains the current promised pointer value of resource ppt(r k ) to that agent and increments the promised pointer (ln. 2-4 Algorithm 2). After sending all request messages an agent waits until reply messages are received from requested resources and then makes a decision. When all received promised pointer values are the same (a distributed lane can be formed) an agent completes the stage 1 by sending write, to all requested resources, messages which contain the negotiated index (ln. 14-17 Algorithm 1). But if one of the received promised pointer values is different an agent will start a renegotiation cycle (ln 5-13 Algorithm 1). By sending a srequest messages which contain a desired slot index to resources. A desired index is computed by taking the maximum of all received promised pointer values and adding a constant (one is sufficient) -ln. 6 Algorithm 1. A resource will reply to srequest message with the higher value of the current ppt(r k ) or received srequest message value and will update the promised pointer (ln. 5-7 Algorithm 2). After sending all srequest messages, an agent waits for reply messages and then restarts the loop if received slot indices are not the same. case request(an) 3:", "cite_spans": [], "ref_spans": [], "section": "Semi-formal Description of the Stage 1"}, {"text": "reply(ppt(r k ), r k ) \u2192 an 4:", "cite_spans": [], "ref_spans": [], "section": "Semi-formal Description of the Stage 1"}, {"text": "ppt(r k ) = ppt(r k ) + 1 5:", "cite_spans": [], "ref_spans": [], "section": "Semi-formal Description of the Stage 1"}, {"text": "case srequest(an, n) 6:", "cite_spans": [], "ref_spans": [], "section": "Semi-formal Description of the Stage 1"}, {"text": "reply(max(ppt(r k ), n), r k ) \u2192 an 7:", "cite_spans": [], "ref_spans": [], "section": "Semi-formal Description of the Stage 1"}, {"text": "ppt(r k ) = max(ppt(r k ), n) + 1 SAF 3 | An agent will not send write (form a distributed lane) messages until all receive promised pointer values are identical. SAF 4 |Agents with overlapping resource objectives will negotiate distributed lanes with different index. LIV 3 | An agent will eventually negotiate a distributed lane. Requirements 2: Low-level protocol stage 1 safety and liveness requirements It is important to note that the stage 1 protocol solution to the described deadlock scenarios has a stochastic nature and one needs to guarantee that a desirable state is probabilistically reachable. In Requirements 2 we summarise requirements for the stage 1 of the protocol.", "cite_spans": [], "ref_spans": [], "section": "Semi-formal Description of the Stage 1"}, {"text": "After an agent completes stage 1 and thus negotiates a distributed lane it will start protocol stage 2 to prevent other deadlock scenarios. Predominantly because of papers verification focus towards properties from stage 1 (all complimentary verification/analysis techniques used) we provide protocol stage 2 description in the online appendix 2 .", "cite_spans": [], "ref_spans": [], "section": "Semi-formal Description of the Stage 1"}, {"text": "As stated before, the long-term objectives of our research are to reduce modelling and verification effort of distributed systems and to have a multifaceted framework to study protocols from all relevant perspectives. In the introduction, we defined key formal concepts the framework should rely on and in the following section we discussed protocol requirements we need to guarantee.", "cite_spans": [], "ref_spans": [], "section": "Multifaceted Modelling and Verification Framework"}, {"text": "The following subsections proposes an engineering process with different formal techniques each of which is efficient to handle parts of above requirements and help to manage modelling and verification complexity.", "cite_spans": [], "ref_spans": [], "section": "Multifaceted Modelling and Verification Framework"}, {"text": "For any adequate formal system development, system requirements should be clearly stated, and so, this is the first step (Step 1 in Fig. 2 ) in the modelling process. Currently, we do not suggest or provide a specific structural approach for defining distributed system requirements. The next step (Step 2) in the process is developing and verifying a pivotal formal model. The purpose of formally modelling a distributed system is to have a formal artefact, which can be animated, analysed and formally verified.", "cite_spans": [], "ref_spans": [{"start": 132, "end": 138, "text": "Fig. 2", "ref_id": "FIGREF1"}], "section": "Formalised Multifaceted Verification Framework"}, {"text": "ATPs PRISM Stochastic Sim.", "cite_spans": [], "ref_spans": [], "section": "Event-B ProB"}, {"text": "Step 2", "cite_spans": [], "ref_spans": [], "section": "Event-B ProB"}, {"text": "Step 1", "cite_spans": [], "ref_spans": [], "section": "Event-B ProB"}, {"text": "Step 3 For the development and verification of pivotal functional system models we selected the Event-B [2] specification language, which has previously been successfully used for modelling and verification of various distributed protocols [5, 15, 16] . The Event-B method provides an expressive modelling language, flexible refinement mechanism and is also proof driven, meaning model correctness is demonstrated by generating and discharging proof obligations with available automated theorem provers [6, 17] . The method is supported by tools such as ProB [19] which enable animating and model-checking a model. On the other hand, the Event-B method does not have an adequate probabilistic reasoning support, which, for example, was essential for verifying the distributed railway section reservation protocol. Therefore, it was decided to integrate the wellknown PRISM [14] stochastic model checker into the framework, so stochastic system's properties can be verified.", "cite_spans": [{"start": 104, "end": 107, "text": "[2]", "ref_id": "BIBREF1"}, {"start": 240, "end": 243, "text": "[5,", "ref_id": "BIBREF4"}, {"start": 244, "end": 247, "text": "15,", "ref_id": "BIBREF15"}, {"start": 248, "end": 251, "text": "16]", "ref_id": "BIBREF16"}, {"start": 503, "end": 506, "text": "[6,", "ref_id": "BIBREF5"}, {"start": 507, "end": 510, "text": "17]", "ref_id": "BIBREF17"}, {"start": 559, "end": 563, "text": "[19]", "ref_id": "BIBREF19"}, {"start": 873, "end": 877, "text": "[14]", "ref_id": "BIBREF14"}], "ref_spans": [], "section": "Event-B ProB"}, {"text": "The last step (Step 3) in the proposed engineering process is analysing a developed distributed system's performance. For that, we have implemented a high-fidelity protocol simulator which could help to evaluate protocols under normal or stressed conditions. Following subsections provide more detail on how each of the formal techniques would be used in the development and verification of a distributed protocol.", "cite_spans": [], "ref_spans": [], "section": "Event-B ProB"}, {"text": "A formal functional Event-B model can have a multitude of uses, but the main application is for formally proving properties about the distributed system. The completed distributed system's model in Step 2 should cover all requirements and specifications, and would be considered correct when all generated proof obligations are proved.", "cite_spans": [], "ref_spans": [], "section": "Step 2: Developing Functional Pivot Models in Event-B"}, {"text": "The model development approach we propose is a rather standard and starts with the abstract model which formally specifies the objective of the distributed protocol. In fact, distributed aspects of the system are ignored at this model level and the abstract model considers a centralised configuration. The abstract model is then iteratively refined by introducing more details about the distributed protocol, primarily by modelling communication aspects. To reduce modelling effort we previously developed communication modelling patterns and described a generic model refinement plan in [23] . A key aspect of our methodology is the scenario validation and analysis. Particularly, in early protocol development stages, it might be too onerous to verify a model only to discover design mistakes. To facilitate design exploration we apply animation and model-checking enabled by ProB. Nonetheless, the final (concrete) model should be proved by adding invariants to the model and proving generated proof obligations with available automated theorem provers.", "cite_spans": [{"start": 589, "end": 593, "text": "[23]", "ref_id": "BIBREF23"}], "ref_spans": [], "section": "Step 2: Developing Functional Pivot Models in Event-B"}, {"text": "As the distributed signalling protocol had a stochastic nature it was important to formally demonstrate that a satisfying state could be reached. Probabilistic or liveness properties are hard to formalise and prove in the Event-B method. Therefore, it was decided to prove progress of the protocol outside of Event-B by redeveloping part of the model (stage 1 ) in the PRISM model checker.", "cite_spans": [], "ref_spans": [], "section": "Step 2: Proving Stochastic Properties with PRISM"}, {"text": "The drawback of using PRISM model checker, if a bounded problem abstraction cannot be found, the verification is limited to bounded models. As we could not find protocol's stage 1 abstraction, we created a skeleton model, which then could be instantiated to model specific scenarios of stage 1 with n agents, m resources and other initial conditions. Additionally, we developed a model generator, which can automatically instantiate the skeleton model to capture a random scenario and run probabilistic verification conditions.", "cite_spans": [], "ref_spans": [], "section": "Step 2: Proving Stochastic Properties with PRISM"}, {"text": "With Event-B and PRISM we aim to demonstrate that the protocol addresses the formulated requirements but it is necessary in our application domain to understand how the protocol is going to perform under various conditions if it were deployed in a real system. To conduct such a simulation we have implemented a high fidelity protocol simulator that can be populated with any number of resources and agents while realising any conceivable agents' goal formation and message delivery policies.", "cite_spans": [], "ref_spans": [], "section": "Step 3: Analysing System's Performance"}, {"text": "The simulator is parametrised with a function of probability of picking a certain message out of a pool of available messages. The probability function is itself parametrised by message source, destination, timestamp and type. The simulation would help to answer how fast, in terms of vital steps such as messages sent, a protocol's stage 1 can be completed and how the performance is affected by messages delays. With function D we can simulate slow agents and resources, fair, arbitrary and unfair delivery policies, agents that operate much faster than others and so on.", "cite_spans": [], "ref_spans": [], "section": "Step 3: Analysing System's Performance"}, {"text": "In this section we present the application of previously introduced modeling and verification framework for developing distributed railway signalling protocol. In Sect. 2 we defined protocol's requirements (Step 1), thus following subsections focuses on formal methodology aspects.", "cite_spans": [], "ref_spans": [], "section": "Formal Protocol Modelling, Verification and Analysis"}, {"text": "We apply the Event-B formalism to develop a high-fidelity functional model and prove the protocol functional correctness requirements. We follow the modelling process presented in Sect. 3.2. Important to note that the protocol model was redeveloped multiple times as various deadlock scenarios were found with ProB animator and model-checker. Below, we overview the final (verified) model.", "cite_spans": [], "ref_spans": [], "section": "Step 2. Formal Protocol Model Development in Event-B"}, {"text": "Modelling was started by creating an abstract model context which contains constants, given sets and uninterpreted functions. In the abstract context, we introduced three (finite) sets, to respectively represent agents (agt), resources (res) and objectives (obj). The context also contains an objective function which is a mapping from objectives to a collection of resources (ob \u2208 obj \u2192 P(res)) and an enumerated set for agents status counter.", "cite_spans": [], "ref_spans": [], "section": "Step 2. Formal Protocol Model Development in Event-B"}, {"text": "The dynamic protocol parts, such as messages exchanges, are modelled as variables and events computing next variable states and contained in a machine.", "cite_spans": [], "ref_spans": [], "section": "Step 2. Formal Protocol Model Development in Event-B"}, {"text": "According to the proposed model development process, the initial machine (abstract) should summarise the objective of protocol, which is an agent completing an objective (locking all necessary resources). To capture that, the abstract protocol machine contains two events, respectively modelling an agent locking and then releasing a free objective (ob \u2208 obj). The abstract model is refined by mostly modelling communication aspects of the distributed signalling protocol and for that we use a backward unfolding style where the next refinement step introduces preceding protocol step. Below, we overview the refinement chain and properties we proved at that modelling stage.", "cite_spans": [], "ref_spans": [], "section": "Step 2. Formal Protocol Model Development in Event-B"}, {"text": "In this refinement we introduce resources into the model and now an agent tries to fulfill the objective by locking resources. Previous two events (lock/release) are now decomposed to two for each and capture iterative locking and releasing of resources.", "cite_spans": [], "ref_spans": [], "section": "Refinement 1 (Abstract ext.)."}, {"text": "The abstract models are firstly refined with stage 2 part of the protocol. In the refinement, r 2, we introduced lock, response and release messages and associated events into the model. In this step we also demonstrated that the protocol stage 2 ensures safe distributed resource reservation by proving an invariant. The invariant states that no two agents will be both at resource consuming stage if both requested intersecting collections of resources.", "cite_spans": [], "ref_spans": [], "section": "Refinement 2."}, {"text": "Model r 3, is the bridge between protocol stages stage 1 and stage 2 and introduces two new messages write and pready into the model.", "cite_spans": [], "ref_spans": [], "section": "Refinement 3."}, {"text": "The final refinement step -r 4 -models stage 1 of the distributed protocol which is responsible for creating distributed lanes. Remaining messages request, reply, srequest and associated events are introduced together with the distributed lane data structure. In this refinement we prove that distributed lanes are correctly formed (req. SAF 3-4 ).", "cite_spans": [], "ref_spans": [], "section": "Refinement 4."}, {"text": "As shown in Sect. 2.2 (Scenarios 1 -2) high-level system's requirements can only be met if an agent invariably and correctly forms a distributed lane. The probabilistic lane forming eventuality (LIV 3 ) is discussed separately while in the following paragraphs we focus on the proof regarding requirements SAF 3-4 . SAF 3 is required to ensure that agent's resource objectives are not satisfied or satisfied on full. The model addresses this via event guards restricting enabling states of the event that generates an outgoing write message. To cross-check this implementation we add an invariant that directly shows that SAF 3 is maintained in the model. For illustrative purposes we focus on details of verifying a slightly more interesting case of SAF 4 and assume that SAF 3 is proven.", "cite_spans": [], "ref_spans": [], "section": "Step 2: Proving Functional Correctness Properties in Event-B"}, {"text": "Requirement SAF 4 addresses potential cross-blocking deadlocks or resource double locking due to distributed lane overriding. The strategy is to prove the requirement is to show that agents that are interested in at least one common resource (related) always form distributed lanes with differing indices. We start by assuming that agents only form distributed lanes if all received indices are the same (proved as SAF 3 ). Then, if a resource (or resources) shared between any two related agents send unique promised pointer values to these agents, these indices will be distributed lane deciders as all other indices from different resources must be the same to form a distributed lane. Hence, to prove SAF 4 it is enough to show that each resource replies to a request or special request message with a unique promised pointer value. To prove that all resources replies to a request or special request message with a unique promised pointer value, we firstly introduced a history variable his ppt of type his ppt \u2208 (res \u2192 (N \u2192 N) ) into our model. The main idea behind the history variable was to chronologically store the promised pointer values sent by a resource. We also introduced a time-stamp variable his wr of the type his wr \u2208 res \u2192 N to chronologically order the promised pointer values stored in the history variable.", "cite_spans": [], "ref_spans": [{"start": 1025, "end": 1032, "text": "(N \u2192 N)", "ref_id": null}], "section": "Step 2: Proving Functional Correctness Properties in Event-B"}, {"text": "After introducing history variables, we modified events resource reply general and resource reply special, which in the protocol update the promised pointer variables, by adding two new actions (see Fig. 3 ). The first action act 4 updates the history variable with the promised pointer value (ppt(res)) that was sent to the agent at the time stamp (his w r(res)). The second action, act 5 , simply increments resource's res time-stamp (his w r(res)) variable.", "cite_spans": [], "ref_spans": [{"start": 199, "end": 205, "text": "Fig. 3", "ref_id": "FIGREF3"}], "section": "Step 2: Proving Functional Correctness Properties in Event-B"}, {"text": "inv saf 4 \u2200r, n 1 , n 2 \u00b7 r \u2208 RES \u2227 n 1 , n 2 \u2208 dom(his ppt (r)) \u2227 n 1 < n 2 \u21d2 his ppt (r)(n1) < his ppt (r)(n2) Action act 4 updates a history variable for a resource res with the current write stamp and promised pointer (ppt(res)) value sent. The next action act 5 simply updates the resource's write stamp. We can then add the main invariant to prove (inv saf 4) which states that if we take any two entries n1, n2 of the history variable for the same resource where one is larger, then that larger entry should have larger promised pointer value. To prove that resource reply {general, special} preserve inv saf 4, the following properties play the key role: (1) the domain of his ppt (i.e., 'indices' of his ppt ) is {0, . . . , his wr \u2212 1}, (2) his ppt (his wr \u2212 1) < his ppt (his wr ). Property (2) holds because his ppt (his wr ) is the maximum of promised pointer (ppt) and special request slot number and promised pointer is incremented as resource reply {general, special} occurs. We also specified these properties as an invariant (inv his ppt) and proved they are preserved by the events which helped to prove inv saf 4. Proof Statistics. In Table 1 we provide an overall proof statistics of the Event-B protocol model which may be used as a metric for models complexity. The majority of the generated proof obligations were automatically discharged with available solvers and even a large fraction of interactive proofs required minimum number of steps. We believe that a high proof automation was due to modelling patterns [23] use and SMT-based verification support [6, 17] . ", "cite_spans": [{"start": 1538, "end": 1542, "text": "[23]", "ref_id": "BIBREF23"}, {"start": 1582, "end": 1585, "text": "[6,", "ref_id": "BIBREF5"}, {"start": 1586, "end": 1589, "text": "17]", "ref_id": "BIBREF17"}], "ref_spans": [{"start": 1155, "end": 1162, "text": "Table 1", "ref_id": "TABREF1"}], "section": "Step 2: Proving Functional Correctness Properties in Event-B"}, {"text": "In this subsection, we discuss stochastic model checking results with which we intend to prove level that LIV 3 requirement is preserved. In particular, we focus on showing that LIV 3 requirement is ensured in Scenario 2 (Sect. 2.2).", "cite_spans": [], "ref_spans": [], "section": "Step 2: Proving Liveness (req. LIV 3 ) with PRISM"}, {"text": "In order to demonstrate that LIV 3 requirement holds in Scenario 2 (Sect. 2.2) we used stage 1 protocol's skeleton PRISM model to replicate Scenario 2. In this experiment we were interested in observing the effects a promised pointer offset has on an probability of agent forming a distributed lane while the upper limit of the promised pointer is increased 3 (n in Scenario 2) . Early experiments showed that verification would not scale well (several hours for a single data-point) if we would increase the number of resources and agents above two resources and three agents (each agent trying to reserve both resources) so we kept these parameters constant.", "cite_spans": [{"start": 366, "end": 377, "text": "Scenario 2)", "ref_id": null}], "ref_spans": [], "section": "Step 2: Proving Liveness (req. LIV 3 ) with PRISM"}, {"text": "For each scenario, we would run a quantitative property: P = ? [F dist 0 > -1] which asks what is the probability of an agent negotiating a distributed lane until the upper promised pointer limit is reached. The three curves (red, green and violet) in Fig. 4 show the effect a promised pointer offset has on negotiation probability as queue depth is increased. Results suggest that increasing the offset reduces the probability of negotiating a distributed lane as queue depth is increased, but the probability still approaches one as the number of rounds is increased (Fig. 4) . To further see the effects of the offset, we considered a different experiment where the same quantitative property would be run when the number of possible renegotiations value is kept constant and offset is increased (light blue plot).", "cite_spans": [], "ref_spans": [{"start": 252, "end": 258, "text": "Fig. 4", "ref_id": "FIGREF5"}, {"start": 569, "end": 577, "text": "(Fig. 4)", "ref_id": "FIGREF5"}], "section": "Step 2: Proving Liveness (req. LIV 3 ) with PRISM"}, {"text": "Results indicate that offset has only effect until a specific threshold and after that the probability of agent negotiating a distributed lane is not affected by the offset. These results suggest that the situation in Scenario 2 does not violate LIV 3 requirement as distributed lanes can be negotiated.", "cite_spans": [], "ref_spans": [], "section": "Step 2: Proving Liveness (req. LIV 3 ) with PRISM"}, {"text": "The goal of this part is to study the protocol performance under various stress conditions and thus provide assurances of its applicability in real life situations. To build simulation, we simply capture protocol's stage 1 behaviour using a program. We are also able to obtain bounds on the number of messages required to form lanes in different setups. This can be directly translated into real-life time bounds on the basis of point to point transmission times.", "cite_spans": [], "ref_spans": [], "section": "Step 3: Analysing Performance"}, {"text": "Simulation Construction. Simulation is setup as a collection of actors of two types -agents and resources -and an orchestration component observing and recording message passing among the actors. A message is said to be in transit as soon as it is created by an actor. Every act of message receipt (and receipt only) advances the simulation (world) clock by one unit. Hence, any number of computations leading to message creation can occur in parallel but message delivery is sequential. To model delays we define a function that probabilistically picks a message to be delivered among all the messages currently in transit. A special message, called skip, is circulated to simulate idle passage of time. This message is resent immediately upon receipt by an implicit idle actor. m.s, m.d, m.c, m.o, t) . Here M is the set of available message, m.s and m.d are the message source and destination agent or resource, m.c is the message type (e.g., WRITE), m.o is the message timestamp (the point of its creation) and t is the world clock. Defining differing probabilities D we are able to address most scenarios of interest.", "cite_spans": [], "ref_spans": [{"start": 780, "end": 802, "text": "m.s, m.d, m.c, m.o, t)", "ref_id": null}], "section": "Step 3: Analysing Performance"}, {"text": "Uniform Distribution. With D(M, m, t) = card(M ) \u22121 the simulator picks a message from M using a uniform distribution. It is an artificial setting as the time in transit bears no influence over the probability of arrival. Counterintuitively, the said probability may decrease with the passage of time when new messages are created quicker than they are delivered. The skip message has equal probability with the rest so the system \"speeds up\" when M is large. The plots in Fig. 5 shows how the protocol performance changes when the number of resources (Resource line), agents (Agent lines), and resources an agent attempts to acquire (Agent goal) increase. We plot separately time to form all lanes and any first lane. The values plotted are averaged over 10000 runs.", "cite_spans": [], "ref_spans": [{"start": 473, "end": 479, "text": "Fig. 5", "ref_id": "FIGREF6"}], "section": "Step 3: Analysing Performance"}, {"text": "In this paper we proposed a multifaceted framework with which we aim to reduce modelling and verification of distributed (railway signalling) systems. The framework was applied in the development of the novel distributed signalling protocol. Starting only with high-level system requirements we developed an early formal protocol prototype which with the help of ProB was refined as subtle deadlock scenarios were discovered. This in part is the advantage of a stepwise development supported by Event-B as complex distributed models can be decomposed into smaller problems and errors found earlier. The stepwise distributed protocol development as also shown before [5, 15, 16] together with adequate tools [6, 17] helped to achieve fairly high verification automation. On the other hand, protocol verification was complicated by the need of stochastic reasoning and not adequate Event-B support for reasoning about probabilistic properties. The current solution relied on a model redevelopment in stochastic model checker PRISM which did not scale well for verification of larger scenarios. As a future direction it is essential to address this problem by most likely improving stochastic reasoning in Event-B. In the future we would also like to a much closer tool integration and support an automatic translation to PRISM and the stochastic simulator.", "cite_spans": [{"start": 666, "end": 669, "text": "[5,", "ref_id": "BIBREF4"}, {"start": 670, "end": 673, "text": "15,", "ref_id": "BIBREF15"}, {"start": 674, "end": 677, "text": "16]", "ref_id": "BIBREF16"}, {"start": 707, "end": 710, "text": "[6,", "ref_id": "BIBREF5"}, {"start": 711, "end": 714, "text": "17]", "ref_id": "BIBREF17"}], "ref_spans": [], "section": "Conclusions and Future Work"}], "bib_entries": {"BIBREF0": {"ref_id": "b0", "title": "Case Studies 2, Deliverable D1.2", "authors": [{"first": "", "middle": [], "last": "Into-Cps", "suffix": ""}, {"first": "", "middle": [], "last": "Project", "suffix": ""}], "year": 2016, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF1": {"ref_id": "b1", "title": "Modeling in Event-B: System and Software Engineering", "authors": [{"first": "J", "middle": ["R"], "last": "Abrial", "suffix": ""}], "year": 2013, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF2": {"ref_id": "b2", "title": "M\u00e9t\u00e9or: a successful application of B in a large project", "authors": [{"first": "P", "middle": [], "last": "Behm", "suffix": ""}, {"first": "P", "middle": [], "last": "Benoit", "suffix": ""}, {"first": "A", "middle": [], "last": "Faivre", "suffix": ""}, {"first": "J.-M", "middle": [], "last": "Meynadier", "suffix": ""}], "year": 1999, "venue": "FM 1999", "volume": "1708", "issn": "", "pages": "369--387", "other_ids": {"DOI": ["10.1007/3-540-48119-2_22"]}}, "BIBREF3": {"ref_id": "b3", "title": "Concurrency control in a System For Distributed Databases (SDD-1)", "authors": [{"first": "P", "middle": ["A"], "last": "Bernstein", "suffix": ""}, {"first": "D", "middle": ["W"], "last": "Shipman", "suffix": ""}, {"first": "J", "middle": ["B"], "last": "Rothnie", "suffix": ""}], "year": 1980, "venue": "ACM Trans. Database Syst", "volume": "5", "issn": "1", "pages": "18--51", "other_ids": {}}, "BIBREF4": {"ref_id": "b4", "title": "Formal and incremental construction of distributed algorithms: on the distributed reference counting algorithm", "authors": [{"first": "D", "middle": [], "last": "Cansell", "suffix": ""}, {"first": "D", "middle": [], "last": "M\u00e9ry", "suffix": ""}], "year": 2006, "venue": "Theor. Comput. Sci", "volume": "364", "issn": "3", "pages": "318--337", "other_ids": {}}, "BIBREF5": {"ref_id": "b5", "title": "Integrating SMT solvers in rodin", "authors": [{"first": "D", "middle": [], "last": "D\u00e9harbe", "suffix": ""}, {"first": "P", "middle": [], "last": "Fontaine", "suffix": ""}, {"first": "Y", "middle": [], "last": "Guyot", "suffix": ""}, {"first": "L", "middle": [], "last": "Voisin", "suffix": ""}], "year": 2014, "venue": "Sci. Comput. Program", "volume": "94", "issn": "P2", "pages": "130--143", "other_ids": {}}, "BIBREF6": {"ref_id": "b6", "title": "B in large-scale projects: the canarsie line CBTC experience", "authors": [{"first": "D", "middle": [], "last": "Essam\u00e9", "suffix": ""}, {"first": "D", "middle": [], "last": "Doll\u00e9", "suffix": ""}], "year": 2007, "venue": "LNCS", "volume": "4355", "issn": "", "pages": "252--254", "other_ids": {}}, "BIBREF8": {"ref_id": "b8", "title": "The notions of consistency and predicate locks in a database system", "authors": [{"first": "K", "middle": ["P"], "last": "Eswaran", "suffix": ""}, {"first": "J", "middle": [], "last": "Gray", "suffix": ""}, {"first": "R", "middle": ["A"], "last": "Lorie", "suffix": ""}, {"first": "I", "middle": ["L"], "last": "Traiger", "suffix": ""}], "year": 1976, "venue": "Commun. ACM", "volume": "19", "issn": "11", "pages": "624--633", "other_ids": {}}, "BIBREF9": {"ref_id": "b9", "title": "Model checking geographically distributed interlocking systems using UMC", "authors": [{"first": "A", "middle": [], "last": "Fantechi", "suffix": ""}, {"first": "A", "middle": ["E"], "last": "Haxthausen", "suffix": ""}, {"first": "M", "middle": ["B R"], "last": "Nielsen", "suffix": ""}], "year": 2017, "venue": "25th Euromicro International Conference on Parallel, Distributed and Network-Based Processing (PDP)", "volume": "", "issn": "", "pages": "278--286", "other_ids": {}}, "BIBREF10": {"ref_id": "b10", "title": "Safety Interlocking as a distributed mutual exclusion problem", "authors": [{"first": "A", "middle": [], "last": "Fantechi", "suffix": ""}, {"first": "A", "middle": ["E"], "last": "Haxthausen", "suffix": ""}], "year": 2018, "venue": "FMICS 2018", "volume": "11119", "issn": "", "pages": "52--66", "other_ids": {"DOI": ["10.1007/978-3-030-00244-2_4"]}}, "BIBREF11": {"ref_id": "b11", "title": "Transaction Processing: Concepts and Techniques, 1st edn", "authors": [{"first": "J", "middle": [], "last": "Gray", "suffix": ""}, {"first": "A", "middle": [], "last": "Reuter", "suffix": ""}], "year": 1992, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF12": {"ref_id": "b12", "title": "IronFleet: proving safety and liveness of practical distributed systems", "authors": [{"first": "C", "middle": [], "last": "Hawblitzel", "suffix": ""}], "year": 2017, "venue": "Commun. ACM", "volume": "60", "issn": "7", "pages": "83--92", "other_ids": {}}, "BIBREF13": {"ref_id": "b13", "title": "Formal development and verification of a distributed railway control system", "authors": [{"first": "A", "middle": ["E"], "last": "Haxthausen", "suffix": ""}, {"first": "J", "middle": [], "last": "Peleska", "suffix": ""}], "year": 2000, "venue": "IEEE Trans. Softw. Eng", "volume": "26", "issn": "8", "pages": "687--701", "other_ids": {}}, "BIBREF14": {"ref_id": "b14", "title": "PRISM: a tool for automatic verification of probabilistic systems", "authors": [{"first": "A", "middle": [], "last": "Hinton", "suffix": ""}, {"first": "M", "middle": [], "last": "Kwiatkowska", "suffix": ""}, {"first": "G", "middle": [], "last": "Norman", "suffix": ""}, {"first": "D", "middle": [], "last": "Parker", "suffix": ""}], "year": 2006, "venue": "TACAS 2006", "volume": "3920", "issn": "", "pages": "441--444", "other_ids": {"DOI": ["10.1007/11691372_29"]}}, "BIBREF15": {"ref_id": "b15", "title": "Developing topology discovery in event-B", "authors": [{"first": "T", "middle": ["S"], "last": "Hoang", "suffix": ""}, {"first": "H", "middle": [], "last": "Kuruma", "suffix": ""}, {"first": "D", "middle": [], "last": "Basin", "suffix": ""}, {"first": "J", "middle": ["R"], "last": "Abrial", "suffix": ""}], "year": 2009, "venue": "Sci. Comput. Program", "volume": "74", "issn": "11", "pages": "879--899", "other_ids": {}}, "BIBREF16": {"ref_id": "b16", "title": "Formal derivation of a distributed program in event B", "authors": [{"first": "A", "middle": [], "last": "Iliasov", "suffix": ""}, {"first": "L", "middle": [], "last": "Laibinis", "suffix": ""}, {"first": "E", "middle": [], "last": "Troubitsyna", "suffix": ""}, {"first": "A", "middle": [], "last": "Romanovsky", "suffix": ""}], "year": 2011, "venue": "ICFEM 2011", "volume": "6991", "issn": "", "pages": "420--436", "other_ids": {"DOI": ["10.1007/978-3-642-24559-6_29"]}}, "BIBREF17": {"ref_id": "b17", "title": "Rodin platform why3 plug-in", "authors": [{"first": "A", "middle": [], "last": "Iliasov", "suffix": ""}, {"first": "P", "middle": [], "last": "Stankaitis", "suffix": ""}, {"first": "D", "middle": [], "last": "Adjepon-Yamoah", "suffix": ""}, {"first": "A", "middle": [], "last": "Romanovsky", "suffix": ""}], "year": 2016, "venue": "ABZ 2016", "volume": "9675", "issn": "", "pages": "275--281", "other_ids": {"DOI": ["10.1007/978-3-319-33600-8_21"]}}, "BIBREF18": {"ref_id": "b18", "title": "Formal verification of signalling programs with SafeCap", "authors": [{"first": "A", "middle": [], "last": "Iliasov", "suffix": ""}, {"first": "D", "middle": [], "last": "Taylor", "suffix": ""}, {"first": "L", "middle": [], "last": "Laibinis", "suffix": ""}, {"first": "A", "middle": [], "last": "Romanovsky", "suffix": ""}], "year": 2018, "venue": "SAFECOMP 2018", "volume": "11093", "issn": "", "pages": "91--106", "other_ids": {"DOI": ["10.1007/978-3-319-99130-6_7"]}}, "BIBREF19": {"ref_id": "b19", "title": "ProB: a model checker for B", "authors": [{"first": "M", "middle": [], "last": "Leuschel", "suffix": ""}, {"first": "M", "middle": [], "last": "Butler", "suffix": ""}], "year": 2003, "venue": "FME 2003", "volume": "2805", "issn": "", "pages": "855--874", "other_ids": {"DOI": ["10.1007/978-3-540-45236-2_46"]}}, "BIBREF20": {"ref_id": "b20", "title": "Verification of railway interlocking -compositional approach with OCRA", "authors": [{"first": "C", "middle": [], "last": "Limbr\u00e9e", "suffix": ""}, {"first": "Q", "middle": [], "last": "Cappart", "suffix": ""}, {"first": "C", "middle": [], "last": "Pecheur", "suffix": ""}, {"first": "S", "middle": [], "last": "Tonetta", "suffix": ""}], "year": 2016, "venue": "RSSRail 2016", "volume": "9707", "issn": "", "pages": "134--149", "other_ids": {"DOI": ["10.1007/978-3-319-33951-1_10"]}}, "BIBREF21": {"ref_id": "b21", "title": "Safety assurance in interlocking design", "authors": [{"first": "M", "middle": [], "last": "Morley", "suffix": ""}], "year": 1996, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF22": {"ref_id": "b22", "title": "Why Amazon chose TLA +", "authors": [{"first": "C", "middle": [], "last": "Newcombe", "suffix": ""}], "year": 2014, "venue": "ABZ 2014", "volume": "8477", "issn": "", "pages": "25--39", "other_ids": {"DOI": ["10.1007/978-3-662-43652-3_3"]}}, "BIBREF23": {"ref_id": "b23", "title": "A refinement based method for developing distributed protocols", "authors": [{"first": "P", "middle": [], "last": "Stankaitis", "suffix": ""}, {"first": "A", "middle": [], "last": "Iliasov", "suffix": ""}, {"first": "Y", "middle": [], "last": "Ait-Ameur", "suffix": ""}, {"first": "T", "middle": [], "last": "Kobayashi", "suffix": ""}, {"first": "F", "middle": [], "last": "Ishikawa", "suffix": ""}, {"first": "A", "middle": [], "last": "Romanovsky", "suffix": ""}], "year": 2019, "venue": "IEEE 19th International Symposium on High Assurance Systems Engineering (HASE)", "volume": "", "issn": "", "pages": "90--97", "other_ids": {}}, "BIBREF24": {"ref_id": "b24", "title": "Control of automatic guided vehicles without wayside interlocking. Patent US", "authors": [{"first": "F", "middle": [], "last": "Whitwam", "suffix": ""}, {"first": "A", "middle": [], "last": "Kanner", "suffix": ""}], "year": 2012, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}}, "ref_entries": {"FIGREF0": {"text": "Problematic scenarios: Scenario 1 (left) and Scenario 2 (right)", "latex": null, "type": "figure"}, "FIGREF1": {"text": "Resource stage 1 communication algorithm 1: switch received message do 2:", "latex": null, "type": "figure"}, "FIGREF2": {"text": "Multifaceted modelling and verification framework 2 A complete protocol description and formal models can be found at http://stankaitis. uk/2019/02/.", "latex": null, "type": "figure"}, "FIGREF3": {"text": "resource reply general = ANY rq, rp WHERE grd1 rq \u2208 req take a sent request message grd2 rp \u2208 REQ \\ rep create a new reply message grd3 repd(rp) = reqs(rq) destination of reply message is source of request message grd4 reps(rp) = reqd(rq) source of reply message is destination of request message grd5 repn(rp) = ppt(reps(rp)) reply message contains promised pointer THEN act1 rep := rep \u222a {rp} add new message to reply channel act2 req := req \\ {rq} remove request message from request channel act3 ppt(res) := ppt(res) + 1 increment promised pointer act4 hisppt(res) := hisppt(res) \u2212 {(hiswr(res)) \u2192 ppt(res)} act5 hiswr(res) := hiswr(res) + 1 END Event-B model excerpt of a resource sending a reply message (Color figure online)", "latex": null, "type": "figure"}, "FIGREF4": {"text": "inv his ppt \u2200res\u00b7 (his wr (res) = 0 \u2227 his ppt (res) = \u2205) \u2228( dom(his ppt (res)) = 0 .. his wr (res) \u2212 1 \u2227 his ppt (res)(his wr (res) \u2212 1) = ppt(res) \u2212 1)", "latex": null, "type": "figure"}, "FIGREF5": {"text": "Scenario 2 with varied resource promised pointer offset and queue depth.", "latex": null, "type": "figure"}, "FIGREF6": {"text": "Time to form all or first lanes, logarithmic scale. Let M be set of all messages that can be generated by agents and resources. Also, let skip / \u2208 M denote the skip message and M = M \u222a {skip}. By its structure, set M is countable (each message identified by unique integer) and one can define a measure space over M . Let D signify the probability that some message m \u2208 M \u2286 M from message pool M is selected for reception. We shall define D via the current message pool, the attributes of m such its source, destination, time stamp and protocol stage, and the world time: D = D(M, m, t) = D(M,", "latex": null, "type": "figure"}, "TABREF0": {"text": "Algorithm 1 Agent stage 1 communication algorithm 1: while sent requests[an] = objective[an] do 2: request(an) \u2192 r k sending request message from agent an to resource r k 3: end 4: wait until received replies[an] = objective[an] 5: while |replies[an]| = 1 do cardinality of agents received slot indices end The end of stage1 of the protocol.", "latex": null, "type": "table"}, "TABREF1": {"text": "Event-B protocol model proof statistics", "latex": null, "type": "table", "html": "<html><body><table><tr><td>Model </td><td>No. of POs </td><td>Aut. discharged </td><td>Int. discharged\n</td></tr><tr><td>context c0 </td><td>0 </td><td>0 </td><td>0\n</td></tr><tr><td>context mes. </td><td>9 </td><td>9 </td><td>0\n</td></tr><tr><td>machine m0 </td><td>12 </td><td>12 </td><td>0\n</td></tr><tr><td>machine m1 </td><td>23 </td><td>21 </td><td>2\n</td></tr><tr><td>machine m2 </td><td>59 </td><td>43 </td><td>16\n</td></tr><tr><td>machine m3 </td><td>43 </td><td>32 </td><td>11\n</td></tr><tr><td>machine m4 </td><td>103 </td><td>57 </td><td>46\n</td></tr><tr><td>Total </td><td>249 </td><td>174 </td><td>75\n</td></tr></table></body></html>"}}, "back_matter": []}