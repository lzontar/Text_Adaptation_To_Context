{"paper_id": "1dc5f4134b0dc426e32e1afb035767dfeb954ca8", "metadata": {"title": "A New Encoding Algorithm for a Multidimensional Version of the Montgomery Ladder", "authors": [{"first": "Aaron", "middle": [], "last": "Hutchinson", "suffix": "", "affiliation": {"laboratory": "", "institution": "University of Waterloo", "location": {"settlement": "Waterloo", "country": "Canada"}}, "email": "a5hutchinson@uwaterloo.ca"}, {"first": "(", "middle": ["B"], "last": "", "suffix": "", "affiliation": {}, "email": ""}, {"first": "Koray", "middle": [], "last": "Karabina", "suffix": "", "affiliation": {"laboratory": "", "institution": "Florida Atlantic University", "location": {"settlement": "Boca Raton", "country": "USA"}}, "email": "kkarabina@fau.edu"}]}, "abstract": [{"text": "We propose a new encoding algorithm for the simultaneous differential multidimensional scalar point multiplication algorithm d-MUL. Previous encoding algorithms are known to have major drawbacks in their efficient and secure implementation. Some of these drawbacks have been avoided in a recent paper in 2018 at a cost of losing the general functionality of the point multiplication algorithm. In this paper, we address these issues. Our new encoding algorithm takes the binary representations of scalars as input, and constructs a compact binary sequence and a permutation, which explicitly determines a regular sequence of group operations to be performed in d-MUL. Our algorithm simply slides windows of size two over the scalars and it is very efficient. As a result, while preserving the full generality of d-MUL, we successfully eliminate the recursive integer matrix computations in the originally proposed encoding algorithms. We also expect that our new encoding algorithm will make it easier to implement d-MUL in constant time. Our results can be seen as the efficient and full generalization of the one dimensional Montgomery ladder to arbitrary dimension.", "cite_spans": [], "ref_spans": [], "section": "Abstract"}], "body_text": [{"text": "Efficient and secure scalar multiplication algorithms are essential in modern cryptography. A (single dimensional) scalar multiplication algorithm for a group G is one which takes an integer \u03b1 and group element P \u2208 G as input and produces the element \u03b1P as output. Such an algorithm is required in numerous protocols such as Diffie-Hellman key exchange, and digital signature generation and verification.", "cite_spans": [], "ref_spans": [], "section": "Introduction"}, {"text": "In such group based cryptographic schemes, scalar multiplication dominate the run time of the system, and therefore it is crucial to minimize its cost. Some cryptographic applications can further make use of multidimensional scalar multiplication algorithms, which take vectors (\u03b1 1 , . . . , \u03b1 d ) of integers and (P 1 , . . . , P d ) of group elements as input and produces the element \u03b1 1 P 1 + \u00b7 \u00b7 \u00b7 + \u03b1 d P d as output. For example, verifying a signature in the Elliptic Curve Digital Signature Algorithm (ECDSA) requires computing a point uP + vQ, where P and Q are public parameters and u and v are derived from the given signature. Multidimensional scalar multiplication can also speed up single scalar multiplication with a fixed base P . For \u03bb = |G| 1/d and \u03bb i = \u03bb i\u22121 , one can write \u03b1 = d i=1 \u03b1 i \u03bb i for 0 \u2264 \u03b1 i < \u03bb, precompute P i = \u03bb i P , and compute", "cite_spans": [], "ref_spans": [], "section": "Introduction"}, {"text": "through multiscalar multiplication with input \u03b1 i , P i , i = 1, ..., d. If the group G is equipped with efficiently computable endomorphisms, one can use similar techniques to speed up single scalar multiplication with variable base P because the cost of precomputating P i becomes negligible compared to the overall cost; see [3, 4] . Scalar multiplication algorithms have been studied heavily in the past. One very interesting single dimensional algorithm is the Montgomery ladder [7] . A key difference between the Montgomery ladder and the double-and-add algorithm is that the Montgomery ladder is regular in the sense that every iteration of the main loop performs the same operations. It is known that irregularity of algorithms can be exploited through side-channel analysis and underlying scalars may be recovered by attackers; see [9] . Therefore, regularity is essential for security when the scalar \u03b1 must be kept secret, such as in Diffie-Hellman public key derivation. Another interesting key feature of the Montgomery ladder is that it allows the use of differential point addition (P, Q, P \u2212 Q \u2192 P + Q), where the knowledge of the difference of the points helps to write more efficient formulas [8] . As and so performing one addition and one doubling at each step; see Table 1 . Note that the difference of the points to be added is always known (0 or P ).", "cite_spans": [{"start": 328, "end": 331, "text": "[3,", "ref_id": "BIBREF2"}, {"start": 332, "end": 334, "text": "4]", "ref_id": "BIBREF3"}, {"start": 484, "end": 487, "text": "[7]", "ref_id": "BIBREF7"}, {"start": 841, "end": 844, "text": "[9]", "ref_id": "BIBREF9"}, {"start": 1211, "end": 1214, "text": "[8]", "ref_id": "BIBREF8"}, {"start": 1217, "end": 1219, "text": "As", "ref_id": null}], "ref_spans": [{"start": 1286, "end": 1293, "text": "Table 1", "ref_id": "TABREF0"}], "section": "Introduction"}, {"text": "Bernstein [1] proposed a regular two dimensional differential addition chain (the DJB algorithm). The DJB algorithm computes \u03b1 1 P 1 +\u03b1 2 P 2 for -bit scalars in steps, performing two additions and one doubling at each step. In particular, the DJB algorithm initiates T [1] \u2190 0, T [2] \u2190 P 1 , T [3] \u2190 P 2 , and at each step, [T [1] , T [2] , T [3] ] is updated by doubling one T [i] and adding two distinct pairs of points. Given the bit sequence of \u03b1 1 and \u03b1 2 , a recursive formula was presented in [1] to encode a sequence for the update rules. Table 2 shows an example for computing 73P + 59Q in seven steps, performing 1 doubling and 2 additions per step. Note that the difference of the points to be added is always known (0, P , Q, or P \u00b1 Q).", "cite_spans": [{"start": 10, "end": 13, "text": "[1]", "ref_id": "BIBREF0"}, {"start": 270, "end": 273, "text": "[1]", "ref_id": "BIBREF0"}, {"start": 281, "end": 284, "text": "[2]", "ref_id": "BIBREF1"}, {"start": 295, "end": 298, "text": "[3]", "ref_id": "BIBREF2"}, {"start": 328, "end": 331, "text": "[1]", "ref_id": "BIBREF0"}, {"start": 336, "end": 339, "text": "[2]", "ref_id": "BIBREF1"}, {"start": 344, "end": 347, "text": "[3]", "ref_id": "BIBREF2"}, {"start": 501, "end": 504, "text": "[1]", "ref_id": "BIBREF0"}], "ref_spans": [{"start": 548, "end": 555, "text": "Table 2", "ref_id": "TABREF6"}], "section": "Introduction"}, {"text": "In 2017, a generalization of the Montgomery ladder to d dimensions was made in [6] by means of an algorithm called d-MUL, originally based on an algorithm of Brown from 2006 in [2] . d-MUL uses a sequence of state matrices (defined in Sect. 2.1) to derive an encoding of the scalar vector (\u03b1 1 , . . . , \u03b1 d ), which is used to perform the scalar multiplication. For -bit scalars \u03b1 i , the encoding algorithm in [6] requires dealing with (d + 1) \u00d7 d integer matrices with -bit integers. Even though the underlying matrix arithmetic is simple, it introduces non-trivial overhead cost, and makes it harder to resist against side-channel attacks. For example, a constant time implementation of d-MUL at the 128bit security level in [5] reported about 10, 000 cycle counts for the encoding phase. After encoding, d-MUL loops through steps, where one doubling and d (differential) addition are performed per step in a regular fashion.", "cite_spans": [{"start": 79, "end": 82, "text": "[6]", "ref_id": "BIBREF6"}, {"start": 177, "end": 180, "text": "[2]", "ref_id": "BIBREF1"}, {"start": 412, "end": 415, "text": "[6]", "ref_id": "BIBREF6"}, {"start": 729, "end": 732, "text": "[5]", "ref_id": "BIBREF4"}], "ref_spans": [], "section": "Introduction"}, {"text": "A second paper [5] further explored d-MUL. The motivation in [5] is to bypass the encoding step, and immediately start scalar multiplication by a carefully chosen sequence of group operations: d additions and 1 doubling per step, for a total number of steps. In particular, a bijection was established between 2 d d! different choices of (r, \u03c3), where r is a length-d bitstring and \u03c3 is a permutation on {1, 2, ..., d}, and the set of all state matrices containing (at most) -bit odd scalars [\u03b1 1 , ..., \u03b1 d ]. In short, by sampling r and \u03c3 at random, one can compute a point \u03b1 1 P 1 + \u00b7 \u00b7 \u00b7 + \u03b1 d P d , for some \u03b1 i sampled at random among -bit odd integers without explicitly constructing \u03b1 i , or their binary representation.", "cite_spans": [{"start": 15, "end": 18, "text": "[5]", "ref_id": "BIBREF4"}, {"start": 61, "end": 64, "text": "[5]", "ref_id": "BIBREF4"}], "ref_spans": [], "section": "Introduction"}, {"text": "When d = 1 and d = 2, the algorithms in [5] , which we call randomized d-MUL, greatly simplify. When d = 1, there is only one choice of \u03c3 = [1] , and given r, the scalar multiplication algorithm starts with", "cite_spans": [{"start": 40, "end": 43, "text": "[5]", "ref_id": "BIBREF4"}, {"start": 140, "end": 143, "text": "[1]", "ref_id": "BIBREF0"}], "ref_spans": [], "section": "Introduction"}, {"text": "bits r i of r are traced from left to right, and T [1] and T [2] are updated as follows Table 3 gives an example with r = [1 1 0 1 1 0 1], which in the end computes 73P . Note that the relation between the scalar and the r-sequence is not obvious. This may be compared to the Montgomery ladder computation in Table 1 . ", "cite_spans": [{"start": 51, "end": 54, "text": "[1]", "ref_id": "BIBREF0"}, {"start": 61, "end": 64, "text": "[2]", "ref_id": "BIBREF1"}], "ref_spans": [{"start": 88, "end": 95, "text": "Table 3", "ref_id": "TABREF1"}, {"start": 309, "end": 316, "text": "Table 1", "ref_id": "TABREF0"}], "section": "Introduction"}, {"text": "bits r i of r are traced from left to right, and T [1] and T [2] are updated such that Table 4 gives an example with \u03c3 = [1, 2] and r = [01 11 00 10 11 01 01], which in the end computes 73P + 59Q. As in the case of d = 1, the relation between the scalars and the r-sequence is not obvious. One may compare this computation to the DJB algorithm example in Table 2 . The randomized d-MUL method [5] may be useful for some applications where one is interested in computing \u03b1 i P i for some random scalars \u03b1 i , but not for some specific (priori-fixed) values \u03b1 i . Therefore, applications of this method are limited despite it being very efficient. Deriving \u03b1 i from a given (r, \u03c3) was made explicit but the connection between (r, \u03c3) and the corresponding \u03b1 i in the other direction was not entirely clear in [5] . In particular, it is not known how to derive (r, \u03c3) from given \u03b1 i other than running the original d-MUL encoding as mentioned before, which has its own efficiency and potential security drawbacks.", "cite_spans": [{"start": 51, "end": 54, "text": "[1]", "ref_id": "BIBREF0"}, {"start": 61, "end": 64, "text": "[2]", "ref_id": "BIBREF1"}, {"start": 121, "end": 124, "text": "[1,", "ref_id": "BIBREF0"}, {"start": 125, "end": 127, "text": "2]", "ref_id": "BIBREF1"}, {"start": 393, "end": 396, "text": "[5]", "ref_id": "BIBREF4"}, {"start": 806, "end": 809, "text": "[5]", "ref_id": "BIBREF4"}], "ref_spans": [{"start": 87, "end": 94, "text": "Table 4", "ref_id": "TABREF2"}, {"start": 355, "end": 362, "text": "Table 2", "ref_id": "TABREF6"}], "section": "Introduction"}, {"text": "In this paper, we derive many theoretical results which explore the connection between (r, \u03c3) and the scalars (\u03b1 1 , . . . , \u03b1 d ) appearing in the output of the d-MUL algorithm from [5] . We use these theoretical results to derive an efficient and compact encoding of an integer vector (\u03b1 1 , . . . , \u03b1 d ) as a bitstring, which we use to build a regular scalar multiplication algorithm similar to that of [5] . In particular, our new encoding algorithm takes the bitstring representations of \u03b1 i 's and constructs a pair (r, \u03c3) by simply sliding windows of size two from right to left. As a result, while preserving the full generality of d-MUL, we successfully eliminate the recursive integer matrix computations in the original encoding algorithm as proposed in [6] . Therefore, we expect significant time and memory savings in the encoding phase of d-MUL. We also expect that our new encoding algorithm will make it easier to implement d-MUL in constant time.", "cite_spans": [{"start": 183, "end": 186, "text": "[5]", "ref_id": "BIBREF4"}, {"start": 407, "end": 410, "text": "[5]", "ref_id": "BIBREF4"}, {"start": 766, "end": 769, "text": "[6]", "ref_id": "BIBREF6"}], "ref_spans": [], "section": "Preliminaries and Our Contributions"}, {"text": "When \u03b1 i are -bit odd positive integers for i = 1, ..., d, our encoding algorithm simplifies to Algorithm 1. Note that Algorithm 1 processes two bits at a time and uses small tables, large integer matrices are not required, and there is no if/else branch in the algorithm. These are some desired features for an efficient and secure implementation of an algorithm. As an example, running Algorithm 1 with \u03b1 = 73 yields the r-sequence as in Table 3 , and running it with [\u03b1 1 , \u03b1 2 ] = [73, 59] yields the r-sequence as in Table 4 and the permutation \u03c3 = [1, 2] . We should emphasize again that previous encoding algorithms do not offer such an efficient algorithm to construct the r-sequence from a given scalar sequence for general d \u2265 1. Given the r-sequence and \u03c3, point multiplication can be performed using the same rules as described above, or more generally, as described in [5] . Our algorithm in its full generalization to -bit scalars, including the point multiplication part, is presented later in this paper in Algorithm 4.", "cite_spans": [{"start": 554, "end": 557, "text": "[1,", "ref_id": "BIBREF0"}, {"start": 558, "end": 560, "text": "2]", "ref_id": "BIBREF1"}, {"start": 882, "end": 885, "text": "[5]", "ref_id": "BIBREF4"}], "ref_spans": [{"start": 440, "end": 447, "text": "Table 3", "ref_id": "TABREF1"}, {"start": 522, "end": 529, "text": "Table 4", "ref_id": "TABREF2"}], "section": "Preliminaries and Our Contributions"}, {"text": "Below we give some preliminaries before formally stating the contributions and organization of this paper in Subsect. 2.2.", "cite_spans": [], "ref_spans": [], "section": "Preliminaries and Our Contributions"}, {"text": "In this subsection we summarize some key definitions and results from [6] and [5] as points of reference. Details can be found in the respective papers. We point out that d-dimensional scalar multiplication algorithms in a group G correspond to those in Z d by identifying combinations \u03b1 1 P 1 + \u00b7 \u00b7 \u00b7 + \u03b1 d P d with the vector (\u03b1 1 , . . . , \u03b1 d ); this identification is a group isomorphism modulo the order of P i in component i, and so we restrict to studying algorithms in Z d .", "cite_spans": [{"start": 70, "end": 73, "text": "[6]", "ref_id": "BIBREF6"}, {"start": 78, "end": 81, "text": "[5]", "ref_id": "BIBREF4"}], "ref_spans": [], "section": "Preliminaries"}, {"text": "Notation. Throughout this paper, we will write (b 1 b 2 \u00b7 \u00b7 \u00b7 b n ) 2 for the binary representation of an integer, where b 1 is the most significant digit and b n is the parity digit. For binary strings r 1 and r 2 we use r 1 ||r 2 to denote their concatenation. As usual for a matrix A, we write A i for the i th row of A, and A i,j for the entry in the i th row and j th column. Matrix indices always begin at 1. We use e j to denote the unit basis row vector with a 1 in the j th column and 0 s elsewhere.", "cite_spans": [], "ref_spans": [], "section": "Preliminaries"}, {"text": "The primary structure that the d-MUL algorithm is built on is a state matrix. ", "cite_spans": [], "ref_spans": [], "section": "Preliminaries"}, {"text": "By \"matrix\" we will always mean a state matrix unless otherwise stated. All state matrices considered in this paper will have a common size of (d + 1) \u00d7 d for some dimension d; we will never consider matrices of different sizes simultaneously. We mostly consider matrices with non-negative values. Our interest will lie in pairs of state matrices having special properties, which we introduce shortly in Definition 3. We first state a few necessary results which were proved in [5] . ", "cite_spans": [{"start": 478, "end": 481, "text": "[5]", "ref_id": "BIBREF4"}], "ref_spans": [], "section": "Preliminaries"}, {"text": "A m + A n has |m \u2212 n| odd entries.", "cite_spans": [], "ref_spans": [], "section": "Lemma 1. For a state matrix A, the row sum"}, {"text": "As it turns out, there are exactly 2 d many addition sequences corresponding to a (d + 1) \u00d7 d matrix B which each yield a different matrix A. The following definition gives a bijection between binary strings and additions sequences, which we use to encode the sequence as a binary string.", "cite_spans": [], "ref_spans": [], "section": "Corollary 1. Let A and B be state matrices such that every row in A is the sum of two rows from B. Then for every k there is some m such that"}, {"text": "The extension matrix of B corresponding to r is the (d + 1) \u00d7 d state matrix A having addition sequence a k with respect to the matrix B. Figure 1 gives an example of an extension matrix. Iterating the construction in Definition 3 allows us to built a sequence of matrices given a long binary string.", "cite_spans": [], "ref_spans": [{"start": 138, "end": 146, "text": "Figure 1", "ref_id": "FIGREF2"}], "section": "Definition 3. Let B be a (d +1)\u00d7 d state matrix and r a binary string of length"}, {"text": "Let B be a (d + 1) \u00d7 d state matrix. Let r 1 , . . . , r be binary strings of length d, and r = r 1 || \u00b7 \u00b7 \u00b7 ||r . The extension sequence with base B corresponding to r is a sequence", "cite_spans": [], "ref_spans": [], "section": "Definition 4."}, {"text": "This definition gives us a way of encoding an entire sequence of matrices", "cite_spans": [], "ref_spans": [], "section": "Definition 4."}, {"text": "i=1 as a simple pair (B, r). Note also that by Theorem 1 the entire sequence is uniquely determined by the final matrix A . The idea of the randomized d-MUL algorithm in [5] is to randomly choose a {0, 1}-valued state matrix B and binary string of length d, and output the last row of the last matrix of the corresponding extension sequence. The group version of the algorithm can these operations without constructing the matrix sequence explicitly by using the encoding given in Definition 4. ", "cite_spans": [{"start": 170, "end": 173, "text": "[5]", "ref_id": "BIBREF4"}], "ref_spans": [], "section": "Definition 4."}, {"text": "The main contributions of this paper are:", "cite_spans": [], "ref_spans": [], "section": "Contributions and Organization"}, {"text": "1. We derive many theoretical results on state matrices and extension sequences.", "cite_spans": [], "ref_spans": [], "section": "Contributions and Organization"}, {"text": "In particular, we determine the exact relationship between the pair (B, r) and the last row of the last matrix of the corresponding extension sequence {A (i) }. This relationship is stated precisely in Theorem 4, which details how the sequence of matrices built in the algorithm of [6] can be modeled and encoded using the efficient framework of [5] . 2. Using the results of Theorem 4 we detail a new version of d-MUL, a ddimensional scalar multiplication algorithm which is a full generalization of the Montgomery ladder to d dimensions. This version of d-MUL recodes the -bit input scalars (\u03b1 1 , . . . , \u03b1 d ) very efficiently into a d-length bitstring r, a process only involving permuting the XOR of consecutive bits of the \u03b1 i . After recoding the scalars, we use the algorithm of [5] to perform the scalar multiplication with the careful choice of the bitstring r. In particular, this version retains the pattern of 1 point doubling D and d point additions A for each bit of the input scalars, giving an operation cost of D + dA for the point addition stage. Furthermore, every addition can be performed as a differential addition. Our algorithm does not require storage of any precomputed points, unless differential additions are employed.", "cite_spans": [{"start": 282, "end": 285, "text": "[6]", "ref_id": "BIBREF6"}, {"start": 346, "end": 349, "text": "[5]", "ref_id": "BIBREF4"}, {"start": 788, "end": 791, "text": "[5]", "ref_id": "BIBREF4"}], "ref_spans": [], "section": "Contributions and Organization"}, {"text": "In Sect. 3 we state and prove many theoretical results on extension sequences of state matrices with the aim of optimizing the d-MUL algorithm. In Sect. 4 we apply the results of Sect. 3 to construct a new version of the d-MUL algorithm.", "cite_spans": [], "ref_spans": [], "section": "Contributions and Organization"}, {"text": "In this section we solve the following two problems: (2) we can determine all column sequences \u03c3 k for each matrix A (k) as well as the bitstring r for the entire sequence {A (k) } k=1 . This allows us to determine (r, \u03c3 1 ) without ever having to construct any matrices. Furthermore A (1) is completely determined by \u03c3 1 since |A (1) | = 1. This entire process can then be turned into a method for constructing an efficient addition chain algorithm which uses only the bits of the \u03b1 i and the initial choice of column sequence \u03c3 , and which has very small storage costs and encoding phase.", "cite_spans": [{"start": 286, "end": 289, "text": "(1)", "ref_id": "BIBREF0"}], "ref_spans": [], "section": "Theoretical Results"}, {"text": "This section will solve problems (1) and (2) above, whose solutions yield Theorem 4 giving an equivalence of two extension sequence constructions. Section 4 will use the solutions to these problems to detail an efficient scalar multiplication algorithm similar to the original d-MUL algorithm of [6] .", "cite_spans": [{"start": 296, "end": 299, "text": "[6]", "ref_id": "BIBREF6"}], "ref_spans": [], "section": "Theoretical Results"}, {"text": "The output of the addition chain constructed in Theorem 4 of [5] is always determined by the last row of the final matrix, and so it makes sense to analyze how these final rows change throughout the sequence of state matrices. Our first result of this section finds the connection between the last rows of successive matrices. Proof. We consider two cases.", "cite_spans": [{"start": 61, "end": 64, "text": "[5]", "ref_id": "BIBREF4"}], "ref_spans": [], "section": "Determining the Bits of an Extension Sequence"}, {"text": "B. Let B d+1,i = B 1,i + c i and B 1,i + B d+1,i = (b 1 b 2 \u00b7 \u00b7 \u00b7 b n\u22121 1) 2 . If A 1 = 2B h+1 , then A 1,i + A d+1,i = \u23a7 \u23aa \u23aa \u23a8 \u23aa \u23aa \u23a9 (b 1 b 2 \u00b7 \u00b7 \u00b7 b n\u22121 11) 2 if (B h+1,i is even and c i = \u22121) or (B h+1,i is odd and c i = 1) (b 1 b 2 \u00b7 \u00b7 \u00b7 b n\u22121 01) 2 if (B h+1,", "cite_spans": [], "ref_spans": [], "section": "Theorem 2. Let A be an extension matrix of"}, {"text": "The result follows when considering c i = 1 and c i = \u22121 in both cases.", "cite_spans": [], "ref_spans": [], "section": "Suppose B h+1,i is even. Then"}, {"text": "With this theorem we can relate the top and bottom rows in a sequence of matrices with the bits of the final matrix, as described in the following corollary.", "cite_spans": [], "ref_spans": [], "section": "Suppose B h+1,i is even. Then"}, {"text": "Proof. Note that (2) and (3) follow immediately from (1) since any odd integer a with binary representation (b 1 b 2 \u00b7 \u00b7 \u00b7 b k\u22121 1) 2 can be written as a = t + (t + 1) for some unique integer t, with the even integer in {t, t + 1} expressible as", "cite_spans": [], "ref_spans": [], "section": "Suppose B h+1,i is even. Then"}, {"text": "To prove (1), we use backwards induction on k. The base case k = is given by assumption. Assume that A", "cite_spans": [], "ref_spans": [], "section": "Suppose B h+1,i is even. Then"}, {"text": "with a single bit inserted between the final two bits, and so A (k)", "cite_spans": [], "ref_spans": [], "section": "Suppose B h+1,i is even. Then"}, {"text": "The above corollary solves problem (1) posed at the beginning of this section.", "cite_spans": [], "ref_spans": [], "section": "Suppose B h+1,i is even. Then"}, {"text": "In this subsection we solve problem (2) detailed at the introduction to this section. The following theorem provides an alternative method for describing the addition sequence for a given extension matrix, which will be needed in the results to come.", "cite_spans": [], "ref_spans": [], "section": "Determining the Column Sequence and Bitstring from an Extension Matrix"}, {"text": "A be an extension matrix of B. Let A 1 = 2\u03b1 1 2\u03b1 2 \u00b7 \u00b7 \u00b7 2\u03b1 d , let \u03c3 A be the column sequence for A, and let a k = (x k , y k ) be the addition sequence for A corresponding to B. Then for k \u2265 1 we have", "cite_spans": [], "ref_spans": [], "section": "Theorem 3. Let"}, {"text": "and so we have", "cite_spans": [], "ref_spans": [], "section": "Theorem 3. Let"}, {"text": "and similarly a k+1 = (x k , y k + 1) \u21d0\u21d2 B y k ,\u03c3A(k+1) \u2261 0 mod 2 and B y k+1 ,\u03c3A(k+1) \u2261 1 mod 2 (since y k+1 > y k ) \u21d0\u21d2 \u03b1 \u03c3A(k+1) is even.", "cite_spans": [], "ref_spans": [], "section": "Theorem 3. Let"}, {"text": "We can now derive an expression for the binary string giving the addition sequence for two state matrices A and B using only the column sequence for A and the row which was doubled from B.", "cite_spans": [], "ref_spans": [], "section": "Theorem 3. Let"}, {"text": "Let A 1 = 2\u03b1 1 2\u03b1 2 \u00b7 \u00b7 \u00b7 2\u03b1 d and let \u03c3 A be the column sequence for A. Then r = (\u03b1 \u03c3A (2) mod 2)|| \u00b7 \u00b7 \u00b7 ||(\u03b1 \u03c3A(d+1) mod 2)", "cite_spans": [{"start": 88, "end": 91, "text": "(2)", "ref_id": "BIBREF1"}], "ref_spans": [], "section": "Corollary 3. Let A be an extension matrix of B."}, {"text": "is the binary string giving the addition sequence for A corresponding to B, where || denotes concatenation of bits.", "cite_spans": [], "ref_spans": [], "section": "Corollary 3. Let A be an extension matrix of B."}, {"text": "Proof. Let a k = (x k , y k ) be the addition sequence for A corresponding to B, and let\u00e2 k = (x k ,\u0177 k ) be the recursive sequence obtained from r using Definition 3. We show that a k =\u00e2 k for every k by induction on k. For k = 1, we have A 1 = 2\u03b1 1 2\u03b1 2 \u00b7 \u00b7 \u00b7 2\u03b1 d = 2B h+1 by Corollary 1, where h is the number of odds in \u03b1 1 \u03b1 2 \u00b7 \u00b7 \u00b7 \u03b1 d , and so a 1 = (h + 1, h + 1). By the definition of an extension matrix, we havex 1 ", "cite_spans": [{"start": 425, "end": 426, "text": "1", "ref_id": "BIBREF0"}], "ref_spans": [], "section": "Corollary 3. Let A be an extension matrix of B."}, {"text": "(\u03b1 i mod 2) = 1 + h since \u03c3 is a bijection. Therefore a 1 =\u00e2 1 .", "cite_spans": [], "ref_spans": [], "section": "Corollary 3. Let A be an extension matrix of B."}, {"text": "Let r i be the ith bit in r. If k \u2265 1, we hav\u00ea", "cite_spans": [], "ref_spans": [], "section": "Corollary 3. Let A be an extension matrix of B."}, {"text": "is even by inductive hypothesis = a k+1 by Theorem 3.", "cite_spans": [], "ref_spans": [], "section": "Corollary 3. Let A be an extension matrix of B."}, {"text": "We can now relate the column sequences of the two state matrices A and B through the following definition. Lemma 2 to follow shows this relationship explicitly. Define \u03a8 as the function giving \u03c4 from \u03c3 and b 1 , . . . , b d ; that is,", "cite_spans": [], "ref_spans": [], "section": "Corollary 3. Let A be an extension matrix of B."}, {"text": "When given a list as input, the function reverse returns the list in reverse order. Note that \u03c4 is a bijection since L contains each of the values \u03c3(2), \u03c3(3), . . . , \u03c3(d + 1) exactly once. A and B , respectively, and let A 1 = 2\u03b1 1 \u00b7 \u00b7 \u00b7 2\u03b1 d . Then", "cite_spans": [], "ref_spans": [{"start": 190, "end": 197, "text": "A and B", "ref_id": null}], "section": "Corollary 3. Let A be an extension matrix of B."}, {"text": "Proof. Let \u03c4 = \u03a8 \u03c3 A , (\u03b1 \u03c3A(2) mod 2, . . . , \u03b1 \u03c3A(d+1) mod 2) . We begin by noting that at step 3 in defining \u03c4 we have that the size of L 1 is |{i : \u03b1 i = 1 mod 2}| = h. Let 1 \u2264 k \u2264 d. We examine two cases.", "cite_spans": [], "ref_spans": [], "section": "Lemma 2. Let A be an extension matrix of B. Let \u03c3 A and \u03c3 B be the column sequences for"}, {"text": "and by Theorem 3 we have a k+1 = (x k+1 , y k+1 ) = (x k \u2212 1, y k ) and", "cite_spans": [], "ref_spans": [], "section": "Suppose \u03b1 \u03c3A(k+1) is odd. Then"}, {"text": "Equating these two expressions for A k+1 gives \u03c3 B (x k ) = \u03c3 A (k + 1). We point out that |{\u03b1 \u03c3A(i) : 2 \u2264 i \u2264 k + 1, \u03b1 \u03c3A(i) odd}| = h + 1 \u2212 x k+1 since x 1 = h + 1 and x i decreases exactly when an odd \u03b1 j is found. In defining \u03c4 , step 2 would put \u03c3 A (k + 1) into L \u03b1 \u03c3 A (k+1) mod 2 = L 1 and we would have", "cite_spans": [], "ref_spans": [], "section": "Suppose \u03b1 \u03c3A(k+1) is odd. Then"}, {"text": "e \u03c3A(k+1) as before, and by Theorem 3 we have a k+1 = (x k+1 , y k+1 ) = (x k , y k + 1) and so", "cite_spans": [], "ref_spans": [], "section": "Suppose \u03b1 \u03c3A(k+1) is odd. Then"}, {"text": "Equating these two expressions for A k+1 gives \u03c3 B (y k + 1) = \u03c3 A (k + 1). Similarly to the first case we have |{\u03b1 \u03c3A(i) : 2 \u2264 i \u2264 k + 1, \u03b1 \u03c3A(i) even}| = y k+1 \u2212 (h + 1) since y 1 = h + 1 and y i increases exactly when an even \u03b1 j is found.", "cite_spans": [], "ref_spans": [], "section": "Suppose \u03b1 \u03c3A(k+1) is odd. Then"}, {"text": "Step 2 in \u03c4 's definition would put \u03c3 A (k + 1) into L \u03b1 \u03c3 A (k+1) mod 2 = L 0 and we would have With Corollary 3 and Lemma 2, we have solved problem (2).", "cite_spans": [], "ref_spans": [], "section": "Suppose \u03b1 \u03c3A(k+1) is odd. Then"}, {"text": "We now arrive at our primary result of this section, which uses the results from the previous subsections to directly construct the binary string for an extension sequence yielding a given d-tuple. Theorem 4. Suppose the following are given: \u03b1 2 , . . . , \u03b1 d ) , where each \u03b1 i is an odd positive integer with bits or less -\u03c3 : {2, 3, . . . , d + 1} \u2192 {1, 2, . . . , d} a bijection. ", "cite_spans": [], "ref_spans": [{"start": 242, "end": 261, "text": "\u03b1 2 , . . . , \u03b1 d )", "ref_id": "FIGREF7"}, {"start": 327, "end": 361, "text": ": {2, 3, . . . , d + 1} \u2192 {1, 2, .", "ref_id": "FIGREF2"}], "section": "Alternative Construction of an Extension Sequence"}, {"text": "be the unique (Theorem 1) sequence of state matrices such that every row from A (i) is the sum of two rows from A (i\u22121) for 1 < i \u2264 , and let \u03c3 i be the column sequence for A (i) .", "cite_spans": [], "ref_spans": [], "section": "From this information, let"}, {"text": "(i) 0 := 0 and \"\u2295\"es of this difference vecto denotes XOR of bits. Let", "cite_spans": [], "ref_spans": [], "section": "Define a recursive sequence by\u03c3 = \u03c3 and"}, {"text": "Then \u03c3 k =\u03c3 k for 1 \u2264 k \u2264 and {A (i) } i=1 is the extension sequence corresponding to r = r (1) ||r (2) || \u00b7 \u00b7 \u00b7 ||r ( \u22121) and having a base given by a matrix having magnitude 1 and column sequence\u03c3 1 .", "cite_spans": [{"start": 100, "end": 103, "text": "(2)", "ref_id": "BIBREF1"}], "ref_spans": [], "section": "Define a recursive sequence by\u03c3 = \u03c3 and"}, {"text": "Proof. We first note that for any 0 \u2264 k < and 1 \u2264 i \u2264 d,", "cite_spans": [], "ref_spans": [], "section": "Define a recursive sequence by\u03c3 = \u03c3 and"}, {"text": "j := 0 for j < 1. We show \u03c3 k =\u03c3 k for all k by backwards induction on k. When k = we have \u03c3 =\u03c3 by definition. Suppose \u03c3 k+1 =\u03c3 k+1 for some k. Taking A = A (k+1) and B = A (k) in the supposition of Lemma 2, we conclude that", "cite_spans": [], "ref_spans": [], "section": "Define a recursive sequence by\u03c3 = \u03c3 and"}, {"text": "is the extension matrix of A (k) corresponding to r (k) for a fixed k. Taking A = A (k+1) and B = A (k) in the supposition of Corollary 3, we have that the binary string giving the addition sequence for", "cite_spans": [], "ref_spans": [], "section": "Define a recursive sequence by\u03c3 = \u03c3 and"}, {"text": "since we've already shown \u03c3 k =\u03c3 k for all k.", "cite_spans": [], "ref_spans": [], "section": "Define a recursive sequence by\u03c3 = \u03c3 and"}, {"text": "By definition we now have that {A (i) } i=1 is the extension sequence with base A (1) corresponding to r. By Theorem 4.4 of [6] , A (1) has magnitude 1 and by definition has column sequence \u03c3 1 =\u03c3 1 . This concludes the proof of the theorem.", "cite_spans": [{"start": 124, "end": 127, "text": "[6]", "ref_id": "BIBREF6"}, {"start": 132, "end": 135, "text": "(1)", "ref_id": "BIBREF0"}], "ref_spans": [], "section": "Define a recursive sequence by\u03c3 = \u03c3 and"}, {"text": "In the context of Theorem 4, note that", "cite_spans": [], "ref_spans": [], "section": "Define a recursive sequence by\u03c3 = \u03c3 and"}, {"text": "The significance of Theorem 4 is the following. The d-MUL algorithm, Algorithm 3 in [6] , is performed using the method of item (1) in Theorem 4; that is, it computes the sequence {A (i) } i=1 explicitly and stores the addition sequence information for each matrix. This is a very costly operation in terms of clock cycles and storage. Theorem 4 shows that the algorithm can be performed instead using item (2) by only computing the sequence {\u03c3 i } i=1 (given by \u03a8 ) and the bit string r, therefore bypassing any matrix or integer arithmetic and allowing us to begin computing points immediately after r has been constructed. An algorithm similar to that of Algorithm 2 of [5] can then be used to compute the same output as running the original d-MUL with the input (a 1 , . . . , a d ) and a choice for \u03c3 .", "cite_spans": [{"start": 84, "end": 87, "text": "[6]", "ref_id": "BIBREF6"}, {"start": 673, "end": 676, "text": "[5]", "ref_id": "BIBREF4"}], "ref_spans": [], "section": "Define a recursive sequence by\u03c3 = \u03c3 and"}, {"text": "In this section we present Algorithm 4, which is essentially Algorithm 3.2 of [5] in which the bitstring r is constructed through the method of item (2) in Theorem 4 to give a desired set of output scalars. This is in contrast to choosing r uniformly at random as in [5] .", "cite_spans": [{"start": 78, "end": 81, "text": "[5]", "ref_id": "BIBREF4"}, {"start": 149, "end": 152, "text": "(2)", "ref_id": "BIBREF1"}, {"start": 267, "end": 270, "text": "[5]", "ref_id": "BIBREF4"}], "ref_spans": [], "section": "Optimized d-MUL"}, {"text": "In addition to using the alternative method of computation given by Theorem 4, we address a potential security issue when formulating Algorithm 4. The algorithm in [5] and many of the results in this paper have produced an integer vector with odd entries, and with the intention of subtracting off a binary vector v to yield an output vector with entries of arbitrary parity. How exactly the point corresponding to this vector v is subtracted off has not yet been discussed.", "cite_spans": [{"start": 164, "end": 167, "text": "[5]", "ref_id": "BIBREF4"}], "ref_spans": [], "section": "Optimized d-MUL"}, {"text": "Let P i be the points of a desired linear combination. If all 3 d elements of the set {c 1 P 1 + \u00b7 \u00b7 \u00b7 + c d P d : c i \u2208 {0, 1}} are stored, such as when using differential additions, then the point corresponding to the binary vector v is one such point; this point may then be looked up and a single addition can be performed to complete the scalar multiplication.", "cite_spans": [], "ref_spans": [], "section": "Optimized d-MUL"}, {"text": "If these 3 d points are not stored, then more care should be taken. If each P i satisfying v i = 1 is to be subtracted off from the output in succession, then this may leak information about the scalars of the desired linear combination (or at the very least the number of even scalars). One solution is to simply not perform the subtraction by v at all and settle for an output in which all scalars are odd. This would cut down the size of the output space by a factor of 2 d . This may or may not be acceptable for a given application of the algorithm.", "cite_spans": [], "ref_spans": [], "section": "Optimized d-MUL"}, {"text": "We give an alternative solution to this problem now, which essentially just adds another iteration in the state matrix sequence. That is, we make the sacrifice of an additional d additions and 1 doubling for added security and a uniform output. Suppose we wish to compute the point \u03b1 1 P 1 + \u00b7 \u00b7 \u00b7 + \u03b1 d P d for arbitrary -bit \u03b1 i (not necessarily odd or positive). If any \u03b1 i is negative, we may negate \u03b1 i and P i and treat \u03b1 i P i as (\u2212\u03b1 i )(\u2212P i ). With negligible preprocessing we may therefore assume every \u03b1 i is positive. Let (b", "cite_spans": [], "ref_spans": [], "section": "Optimized d-MUL"}, {"text": "2 \u00b7 \u00b7 \u00b7 b (i) ) 2 be the binary representation of \u03b1 i , and define\u03b1 i as (b", "cite_spans": [], "ref_spans": [], "section": "Optimized d-MUL"}, {"text": "and 2\u03b1 i + 1 has + 1 bits. We then apply Theorem 4 to the odd integers 2\u03b1 i + 1 for 1 \u2264 i \u2264 d and some column sequence \u03c3. By item (1) of the same theorem, we get a state matrix A ( +1) satisfying:", "cite_spans": [], "ref_spans": [], "section": "Optimized d-MUL"}, {"text": "The matrix A ( +1) therefore contains all of the original values \u03b1 1 , . . . , \u03b1 d . If \u03c3 is chosen carefully, then this matrix will contain the row \u03b1 1 \u03b1 2 \u00b7 \u00b7 \u00b7 \u03b1 d . Specifically, we may choose \u03c3 as any bijection in which the indices for all odd \u03b1 i come before those which are even. The index corresponding to this row will be exactly h := 1 + (\u03b1 i mod 2). We note that Theorem 4 doesn't use the last parity bits of the \u03b1 i , but in this context we are applying the theorem to the integers 2\u03b1 i + 1. Therefore the final \"1\" bit of 2\u03b1 i + 1 will be ignored, but the rest will be used to construct a bitstring r of length d. That is, we use exactly the bits of\u03b1 i with an extra leading \"0\" bit.", "cite_spans": [], "ref_spans": [], "section": "Optimized d-MUL"}, {"text": "Here we give some details regarding Algorithm 4. The notation Ai(j) refers to line j of Algorithm i.", "cite_spans": [], "ref_spans": [], "section": "Details of Algorithm 4:"}, {"text": "To simplify the presentation we deal with negative integer inputs by calling Algorithm 3, Sanitize, using the method described at the beginning of this section. This is, if \u03b1 i is negative we replace \u03b1 i by \u2212\u03b1 i and P i by \u2212P i . If working in a setting such as a Montgomery curve using XZ-coordinates, this step isn't necessary since P i is identified with \u2212P i . 14) is essentially the same as that seen in the Randomized d-MUL algorithm of [5] . The conditional seen in [5] has been replaced in favor of a much simpler, compact, and equivalent assignment for both x and y. A special case is when all scalars \u03b1 i are positive and odd. In this case, the Sanitize step has no effect, and ChooseSeq amounts to choosing any permutation on d elements. Furthermore, the\u03b1 i calculated in Algorithm 4 are equal to the input \u03b1 i . This special case leads to an encoding given by the implementationoriented Algorithm 1, where we skip sanitization and always make the same choice of initial \u03c3. In addition, the construction of the array L is done without an if/else branch for side-channel resistance.", "cite_spans": [{"start": 443, "end": 446, "text": "[5]", "ref_id": "BIBREF4"}, {"start": 473, "end": 476, "text": "[5]", "ref_id": "BIBREF4"}], "ref_spans": [], "section": "1."}, {"text": "A basic Magma implementation of Algorithm 4 can be found here:", "cite_spans": [], "ref_spans": [], "section": "1."}, {"text": "https://github.com/AaronHutchinson/d-MUL-Optimized-2020-", "cite_spans": [], "ref_spans": [], "section": "1."}, {"text": "This subsection aims to outline an alternate version of Algorithm 4 which utilizes differential additions. Our only sacrifice to gain knowledge of point differences is storing each column sequence \u03c3 generated in the loop on line 6 of Algorithm 4. We can compute point differences using the following theorem. ", "cite_spans": [], "ref_spans": [], "section": "Differential Additions"}, {"text": "Proof. We use induction on k. When k = 1 we have x 1 = y 1 by definition of an addition sequence, and so B y1 \u2212 B x1 is zero. Assume that B y k \u2212 B x k = y k i=x k +1 c \u03c3(i) e \u03c3(i) for some k with 1 \u2264 k \u2264 d. We have either that a k+1 = (x k \u2212 1, y k ) or a k+1 = (x k , y k + 1).", "cite_spans": [], "ref_spans": [], "section": "Differential Additions"}, {"text": "Suppose that a k+1 = (x k \u2212 1, y k ) so that y k+1 = y k and x k+1 = x k \u2212 1. Then", "cite_spans": [], "ref_spans": [], "section": "Differential Additions"}, {"text": "If a k+1 = (x k , y k + 1) then y k+1 = y k + 1 and x k+1 = x k , and so", "cite_spans": [], "ref_spans": [], "section": "Differential Additions"}, {"text": "This concludes the proof.", "cite_spans": [], "ref_spans": [], "section": "Differential Additions"}, {"text": "Suppose that all rows in the set S = {[t 1 , . . . , t d ] : t i \u2208 {0, 1, \u22121}} are stored. Then the above theorem tells us exactly how to find the proper element of S for the difference which corresponds to a sum B i + B j . The only knowledge required to compute this row is the column sequence \u03c3 and the difference vector c. We will now show that only a slight modification of Algorithm 4 will allow us to perform differential additions.", "cite_spans": [], "ref_spans": [], "section": "Differential Additions"}, {"text": "Let \u03b1 i and\u03b1 i for i = 1, . . . , d be as in Sect. 4, and let \u03c3 be any column sequence. Again by Theorem 4 we may derive a sequence {A (k) } +1 k=1 of state matrices where each row in A (k+1) is the sum of two rows from A (k) and the final matrix A ( +1) satisfies:", "cite_spans": [], "ref_spans": [], "section": "Differential Additions"}, {"text": "2 \u00b7 \u00b7 \u00b7 b (i) ) 2 is the binary representation of \u03b1 i . We recall that the difference vector c for any state matrix A is defined to be A d+1 \u2212 A 1 . Applying Corollary 2 to our current scenario, we find that the i th entry of the difference vector for A (k) is exactly", "cite_spans": [], "ref_spans": [], "section": "Differential Additions"}, {"text": "Input: Integers \u03b11, . . . , \u03b1 d \u2208 (\u22122 , 2 ), points P1, . . . , P d \u2208 G, G abelian Output: Group element \u03b11P1 + \u00b7 \u00b7 \u00b7 + \u03b1 d P d 1 \u03b1, P \u2190 Sanitize(\u03b1, P ). 2 \u03c3 \u2190 ChooseSeq(\u03b1). 3\u03b1 \u2190 (\u03b11 + (\u03b11 mod 2) \u2212 1, . . . , \u03b1 d + (\u03b1 d mod 2) \u2212 1)", "cite_spans": [], "ref_spans": [], "section": "Algorithm 4: Optimized d-MUL"}, {"text": ")2 be the binary form of\u03b1i, with extra leading 0. 5 Initialize an empty binary array r of length d. 6 for k = down to 1 do 7 For i = 1 to d, assign r (k\u22121)d+i \u2190 b (\u03c3(i)) k \u2295 b (\u03c3(i)) k+1 . 8 Initialize empty lists L0 and L1 of length d. 9 For i = 1 to d, append \u03c3(i) to the end of L b (\u03c3(i)) k \u2295b (\u03c3(i)) k+1", "cite_spans": [{"start": 100, "end": 101, "text": "6", "ref_id": "BIBREF6"}, {"start": 123, "end": 124, "text": "7", "ref_id": "BIBREF7"}, {"start": 189, "end": 190, "text": "8", "ref_id": "BIBREF8"}, {"start": 237, "end": 238, "text": "9", "ref_id": "BIBREF9"}], "ref_spans": [], "section": "Algorithm 4: Optimized d-MUL"}, {"text": ".", "cite_spans": [], "ref_spans": [], "section": "Algorithm 4: Optimized d-MUL"}, {"text": "Overwrite \u03c3 \u2190 Reverse(L1)||L0, where || denotes concatenation. 11 end 12 Initialize group elements Q1, . . . , Q d+1 , R1, . . . R d+1 as id(G). 13 For i = 1 to d, assign Qi+1 \u2190 Qi + P \u03c3(i) . 14 for k = 1 to do 15 h, x, y \u2190 r (k\u22121)d+1 + \u00b7 \u00b7 \u00b7 + r kd + 1 16 R1 \u2190 2Q h 17 for i = 1 to d do 18 x \u2190 x \u2212 r (k\u22121)d+i , y \u2190 y + 1 \u2212 r (k\u22121)d+i", "cite_spans": [{"start": 145, "end": 147, "text": "13", "ref_id": null}, {"start": 211, "end": 213, "text": "15", "ref_id": null}, {"start": 288, "end": 290, "text": "18", "ref_id": null}], "ref_spans": [], "section": "10"}, {"text": "Ri+1 \u2190 Qx + Qy 20 end 21 Q \u2190 R 22 end 23 h \u2190 (\u03b11 mod 2) + \u00b7 \u00b7 \u00b7 + (\u03b1 d mod 2) + 1 24 return Q h Therefore the entries of this difference vector are given \"for free\", as they only depend on the bits in position k \u2212 1 of the \u03b1 i .", "cite_spans": [], "ref_spans": [], "section": "19"}, {"text": "With this discussion in mind, Algorithm 4 may be altered so that each \u03c3 derived in the loop beginning on line 6 is saved in a table so that the column sequence for matrix A (i) is stored as \u03c3 i . One may then use Theorem 5 to find the difference corresponding to each sum; it is exactly", "cite_spans": [], "ref_spans": [], "section": "19"}, {"text": ")e \u03c3i(k) .", "cite_spans": [], "ref_spans": [], "section": "19"}, {"text": "There We believe that Randomized d-MUL may still be preferable over Optimized d-MUL in certain special situations. If a given application only calls for a random linear combination, then it would be more efficient to employ Randomized d-MUL over Optimized d-MUL since in the former case we need only generate a random bit string rather than derive it from random scalars as in the latter case. The efficiency gain is slightly more dramatic when the scalars of the combination need not be known, since the derivation of the scalars in Randomized d-MUL is split off into an independent algorithm. On the other hand, if the setting calls for a specific linear combination to be computed from given points, we see no way to use Randomized d-MUL in such a setting and so Optimized d-MUL seems to be the best option out of these three algorithms.", "cite_spans": [], "ref_spans": [], "section": "Conclusions"}], "bib_entries": {"BIBREF0": {"ref_id": "b0", "title": "Differential addition chains", "authors": [{"first": "D", "middle": [], "last": "Bernstein", "suffix": ""}], "year": 2006, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF1": {"ref_id": "b1", "title": "Multi-dimensional montgomery ladders for elliptic curves", "authors": [{"first": "D", "middle": [], "last": "Brown", "suffix": ""}], "year": null, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF2": {"ref_id": "b2", "title": "Endomorphisms for faster elliptic curve cryptography on a large class of curves", "authors": [{"first": "S", "middle": ["D"], "last": "Galbraith", "suffix": ""}, {"first": "X", "middle": [], "last": "Lin", "suffix": ""}, {"first": "M", "middle": [], "last": "Scott", "suffix": ""}], "year": 2010, "venue": "J. Cryptol", "volume": "24", "issn": "3", "pages": "446--469", "other_ids": {"DOI": ["10.1007/s00145-010-9065-y"]}}, "BIBREF3": {"ref_id": "b3", "title": "Faster point multiplication on elliptic curves with efficient endomorphisms", "authors": [{"first": "R", "middle": ["P"], "last": "Gallant", "suffix": ""}, {"first": "R", "middle": ["J"], "last": "Lambert", "suffix": ""}, {"first": "S", "middle": ["A"], "last": "Vanstone", "suffix": ""}], "year": 2001, "venue": "CRYPTO 2001", "volume": "2139", "issn": "", "pages": "190--200", "other_ids": {"DOI": ["10.1007/3-540-44647-8_11"]}}, "BIBREF4": {"ref_id": "b4", "title": "d -MUL: optimizing and implementing a multidimensional scalar multiplication algorithm over elliptic curves", "authors": [{"first": "H", "middle": [], "last": "Hisil", "suffix": ""}, {"first": "A", "middle": [], "last": "Hutchinson", "suffix": ""}, {"first": "K", "middle": [], "last": "Karabina", "suffix": ""}], "year": null, "venue": "SPACE 2018", "volume": "11348", "issn": "", "pages": "198--217", "other_ids": {}}, "BIBREF6": {"ref_id": "b6", "title": "Constructing multidimensional differential addition chains and their applications", "authors": [{"first": "A", "middle": [], "last": "Hutchinson", "suffix": ""}, {"first": "K", "middle": [], "last": "Karabina", "suffix": ""}], "year": 2017, "venue": "J. Cryptogr. Eng", "volume": "9", "issn": "1", "pages": "1--19", "other_ids": {"DOI": ["10.1007/s13389-017-0177-2"]}}, "BIBREF7": {"ref_id": "b7", "title": "Evaluating Recurrences of the Form Xm+n = f (Xm, Xn, Xm\u2212n) via Lucas Chains", "authors": [{"first": "P", "middle": ["L"], "last": "Montgomery", "suffix": ""}], "year": 1983, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF8": {"ref_id": "b8", "title": "Speeding the pollard and elliptic curve methods of factorization", "authors": [{"first": "P", "middle": ["L"], "last": "Montgomery", "suffix": ""}], "year": 1987, "venue": "Math. Comput", "volume": "48", "issn": "", "pages": "243--264", "other_ids": {}}, "BIBREF9": {"ref_id": "b9", "title": "Differential power analysis", "authors": [{"first": "P", "middle": [], "last": "Kocher", "suffix": ""}, {"first": "J", "middle": [], "last": "Jaffe", "suffix": ""}, {"first": "B", "middle": [], "last": "Jun", "suffix": ""}], "year": 1999, "venue": "CRYPTO 1999", "volume": "1666", "issn": "", "pages": "388--397", "other_ids": {"DOI": ["10.1007/3-540-48405-1_25"]}}}, "ref_entries": {"FIGREF0": {"text": "an example, 73P can be computed in seven steps by setting [T, B] = [0, P ], tracing the bits b i of 73 from left to right, updating [T, B] \u2190 [2T, T + B] if b i = 0, [T, B] \u2190 [T + B, 2B] if b i = 1,", "latex": null, "type": "figure"}, "FIGREF2": {"text": "Two state matrices A and B of dimension d = 4, along with their column sequences and difference vectors. A is the extension matrix of B corresponding to the bitstring r = 1001.", "latex": null, "type": "figure"}, "FIGREF3": {"text": "be an extension sequence with |A (1) | = 1. Given only the binary representation of the entries in the row vector A k = 1, . . . , . 2. Let A be an extension matrix of B corresponding to the bitstring r, and let \u03c3 A and \u03c3 B be the column sequences for A and B, respectively. Find a simple method for determining (\u03c3 B , r) given only(A 1 , \u03c3 A ).We make use of the solution to these two problems in the following manner. For a vector (\u03b1 1 , . . . , \u03b1 d ) of positive odd bit integers, choose a matrix A ( ) such that A = \u03b1 1 \u00b7 \u00b7 \u00b7 \u03b1 d and let {A (k) } k=1 be the derived extension sequence. Then using the solution to (1) we can determine A (k) 1 for every k, and by iterating the solution to", "latex": null, "type": "figure"}, "FIGREF4": {"text": "i is even and c i = 1) or (B h+1,i is odd and c i = \u22121)", "latex": null, "type": "figure"}, "FIGREF5": {"text": "Let \u03c3: {2, 3, . . . , d + 1} \u2192 {1, 2, . . . , d} be a bijection and let b 1 , . . . , b d be bits. Define the bijection \u03c4 : {2, 3, . . . , d + 1} \u2192 {1, 2, . . . , d} as follows: 1. Initialize two empty lists L 0 and L 1 . 2. For i = 1 to d, append \u03c3(i + 1) to the end of L bi . 3. Let L = reverse(L 1 )||L 0 , where || denotes concatenation. 4. Define \u03c4 (i + 1) = L(i) for 1 \u2264 i \u2264 d.", "latex": null, "type": "figure"}, "FIGREF6": {"text": "Let A ( ) be the state matrix having i) A ( )", "latex": null, "type": "figure"}, "FIGREF7": {"text": "Similarly, we separate the process of choosing an initial column sequence \u03c3 into a different algorithm, Algorithm 2: ChooseSeq. We choose any permutation for which the indices of the odd \u03b1 i are placed before the indices for the even \u03b1 i . The RandomPermutation function seen in Algorithm 2 returns a permutation of the input set chosen uniformly at random, represented in list form. The lists \u03c3 E and \u03c3 O are concatenated to form a single permutation. 3. The binary representation in line Algorithm 4(4) is computed with the most significant bit of\u03b1 i being b Definition 5 while also constructing the bitstring r simultaneously. 5. The loop Algorithm 4(", "latex": null, "type": "figure"}, "FIGREF8": {"text": "are now three versions of the d-MUL algorithm: Original d-MUL (Algorithm 3 of [6]), Randomized d-MUL (Algorithm 2 of [5]), and Optimized d-MUL (Algorithm 4 in this paper). Optimized d-MUL seems to be a direct improvement over Original d-MUL, since the storage of two (d + 1) \u00d7 d matrices with large entries, many arrays D, and large integer arithmetic is exchanged for the storage of a single d length bitstring and the computation of many simple permutations. We therefore see no reason to use Original d-MUL over Optimized d-MUL.", "latex": null, "type": "figure"}, "TABREF0": {"text": "Montgomery ladder for \u03b1 = 73", "latex": null, "type": "table", "html": "<html><body><table><tr><td>i </td><td>\u00a0</td><td>1 </td><td>2 </td><td>3 </td><td>4 </td><td>5 </td><td>6 </td><td>7\n</td></tr><tr><td>bi </td><td>\u00a0</td><td>1 </td><td>0 </td><td>0 </td><td>1 </td><td>0 </td><td>0 </td><td>1\n</td></tr><tr><td>T </td><td>0 </td><td>P </td><td>2P </td><td>4P </td><td>9P </td><td>18P </td><td>36P </td><td>73P\n</td></tr><tr><td>B </td><td>P </td><td>2P </td><td>3P </td><td>5P </td><td>10P </td><td>19P </td><td>37P </td><td>74P\n</td></tr></table></body></html>"}, "TABREF1": {"text": "Randomized d-MUL with r = [1 1 0 1 1 0 1]", "latex": null, "type": "table"}, "TABREF2": {"text": "Randomized d-MUL with \u03c3 = [1, 2] and r = [01 11 00 10 11 01 01]", "latex": null, "type": "table"}, "TABREF3": {"text": "A binary sequence r of length d bits and a permutation \u03c3 on {1, ..., d} 1 Let B[i] be the binary representation of \u03b1i, with extra leading 0. 2", "latex": null, "type": "table"}, "TABREF4": {"text": "where h is the number of odd entries in the integer row vector1 2 A 1 .", "latex": null, "type": "table"}, "TABREF6": {"text": "ChooseSeq Input: Integers \u03b11, . . . , \u03b1 d Output: Permutation on {1, 2, . . . , d} 1 Evens \u2190 {i : \u03b1i \u2261 0 mod 2} 2 Odds \u2190 {i : \u03b1i \u2261 1 mod 2} 3 \u03c3E \u2190 RandomPermutation(Evens) 4 \u03c3O \u2190 RandomPermutation(Odds) 5 return \u03c3O||\u03c3E Algorithm 3: Sanitize Input: Integers \u03b11, . . . , \u03b1 d , points P1, . . . , P d \u2208 G, G abelian Output: Positive integers \u03b11, . . . , \u03b1 d , points P1, . . . , P d \u2208 G, G abelian 1 for i = 1 to d do if \u03b1i < 0 then \u03b1i \u2190 \u2212\u03b1i Pi \u2190 \u2212Pi", "latex": null, "type": "table"}, "TABREF7": {"text": "Let A be an extension matrix of B with addition sequence {a k } d+1 k=1 . If \u03c3 is the column sequence for B and c is the difference vector for B, then B y1 \u2212 B x1 is the zero row matrix and for 2 \u2264 k \u2264 d + 1 we have", "latex": null, "type": "table"}}, "back_matter": [{"text": "Acknowledgment. This research has been partially supported by the U.S. Army Research Office (ARO) under the award number W911NF-17-1-0311. The content is solely the responsibility of the authors and does not necessarily represent the official views of the ARO. The authors thank reviewers for their comments.", "cite_spans": [], "ref_spans": [], "section": "acknowledgement"}]}