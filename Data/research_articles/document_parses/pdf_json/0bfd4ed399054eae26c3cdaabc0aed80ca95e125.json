{"paper_id": "0bfd4ed399054eae26c3cdaabc0aed80ca95e125", "metadata": {"title": "Neural Power Units", "authors": [{"first": "Niklas", "middle": [], "last": "Heim", "suffix": "", "affiliation": {"laboratory": "", "institution": "Czech Technical University", "location": {"postCode": "120 00", "settlement": "Prague", "region": "CZ"}}, "email": "niklas.heim@aic.fel.cvut.cz"}, {"first": "Tom\u00e1\u0161", "middle": [], "last": "Pevn\u00fd", "suffix": "", "affiliation": {"laboratory": "", "institution": "Czech Technical University", "location": {"postCode": "120 00", "settlement": "Prague", "region": "CZ"}}, "email": "tomas.pevny@aic.fel.cvut.cz"}, {"first": "V\u00e1clav", "middle": [], "last": "\u0160m\u00eddl", "suffix": "", "affiliation": {"laboratory": "", "institution": "Czech Technical University", "location": {"postCode": "120 00", "settlement": "Prague", "region": "CZ"}}, "email": ""}]}, "abstract": [{"text": "Conventional Neural Networks can approximate simple arithmetic operations, but fail to generalize beyond the range of numbers that were seen during training. Neural Arithmetic Units aim to overcome this difficulty, but current arithmetic units are either limited to operate on positive numbers or can only represent a subset of arithmetic operations. We introduce the Neural Power Unit (NPU 1 ) that operates on the full domain of real numbers and is capable of learning arbitrary power functions in a single layer. The NPU thus fixes the shortcomings of existing arithmetic units and extends their expressivity. We achieve this by using complex arithmetic without requiring a conversion of the network to complex numbers. A simplification of the unit to the RealNPU yields a highly interpretable model. We show that the NPUs outperform their competitors in terms of accuracy and sparsity on artificial arithmetic datasets, and that the RealNPU can discover the governing equations of a dynamical systems only from data.", "cite_spans": [], "ref_spans": [], "section": "Abstract"}], "body_text": [{"text": "Numbers and simple algebra are essential not only to human intelligence but also to the survival of many other species [Dehaene, 2011 , Gallistel, 2018 . A successful, intelligent agent should, therefore, be able to perform simple arithmetic. State of the art neural networks are capable of learning arithmetic, but they fail to extrapolate beyond the ranges seen during training [Suzgun et al., 2018, Lake and Baroni, 2018] . The inability to generalize to unseen inputs is a fundamental problem that hints at a lack of understanding of the given task. The model merely memorizes the seen inputs and fails to abstract the true learning task. The failure of numerical extrapolation on simple arithmetic tasks has been shown by Trask et al. [2018] , who also introduced a new class of Neural Arithmetic Units with good extrapolation performance on some arithmetic tasks.", "cite_spans": [{"start": 119, "end": 133, "text": "[Dehaene, 2011", "ref_id": "BIBREF3"}, {"start": 134, "end": 151, "text": ", Gallistel, 2018", "ref_id": "BIBREF5"}, {"start": 380, "end": 410, "text": "[Suzgun et al., 2018, Lake and", "ref_id": null}, {"start": 411, "end": 424, "text": "Baroni, 2018]", "ref_id": "BIBREF11"}, {"start": 727, "end": 746, "text": "Trask et al. [2018]", "ref_id": "BIBREF22"}], "ref_spans": [], "section": "Introduction"}, {"text": "Including Neural Arithmetic Units in standard neural networks, promises to significantly increase their extrapolation capabilities due to their inductive bias towards numerical computation. This is especially important for tasks in which the data generating process contains mathematical relationships. They also promise to reduce the number of parameters needed for a given task, which can improve the explainability of the model. We demonstrate this in a Neural Ordinary Differential Equation (NODE, Chen et al. [2019] ), where a handful of neural arithmetic units can outperform a much bigger network built from dense layers (Sec. 4.1). Moreover, our new unit can be used to directly read out the correct generating ODE from the fitted model. This is in line with recent efforts to build interpretable models instead of explaining black-box models [Rudin, 2019] , like conventional neural networks.", "cite_spans": [{"start": 502, "end": 520, "text": "Chen et al. [2019]", "ref_id": "BIBREF2"}, {"start": 851, "end": 864, "text": "[Rudin, 2019]", "ref_id": "BIBREF17"}], "ref_spans": [], "section": "Introduction"}, {"text": "The currently available arithmetic units all have different strengths and weaknesses, but none of them solve simple arithmetic completely. The Neural Arithmetic Logic Unit (NALU) by Trask et al. [2018] , chronologically, was the first arithmetic unit. It can solve addition (+, including subtraction), multiplication (\u00d7), and division (\u00f7), but is limited to positive inputs. The convergence of the NALU is quite fragile due to an internal gating mechanism between addition and multiplication paths as well as the use of a logarithm which is problematic for small inputs. Recently, Schl\u00f6r et al. [2020] introduced the improved NALU (iNALU, to fix the NALU's shortcomings. It significantly increases its complexity, and we observe only a slight improvement in performance. Madsen and Johansen [2020] solve (+, \u00d7) with two new units: the Neural Addition Unit (NAU), and the Neural Multiplication Unit (NMU). Instead of gating between addition and multiplication paths, they are separate units that can be stacked. They can work with the full range of real numbers, converge much more reliably, but cannot represent division.", "cite_spans": [{"start": 182, "end": 201, "text": "Trask et al. [2018]", "ref_id": "BIBREF22"}, {"start": 581, "end": 601, "text": "Schl\u00f6r et al. [2020]", "ref_id": "BIBREF19"}, {"start": 771, "end": 797, "text": "Madsen and Johansen [2020]", "ref_id": "BIBREF14"}], "ref_spans": [], "section": "Introduction"}, {"text": "Neural Power Unit. We introduce a new arithmetic layer (NPU, Sec. 3) which is capable of learning products of power functions ( x wi i ) of arbitrary real inputs x i and power w i , thus including multiplication (x 1 \u00d7 x 2 = x 1 1 x 1 2 ) as well as division (x 1 \u00f7 x 2 = x 1 1 x \u22121 2 ). This is achieved by using formulas from complex arithmetic (Sec. 3.1). Stacks of NAUs and NPUs can thus learn the full spectrum of simple arithmetic operations.", "cite_spans": [], "ref_spans": [], "section": "Our Contributions"}, {"text": "Convergence improvement. We address the known convergence issues of neural arithmetic units by introducing a relevance gate that smooths out the loss surface of the NPU (Sec. 3.2). With the relevance gate, which helps to learn to ignore variables, the NPU reaches extrapolation error and sparsity that is on par with the NMU on (\u00d7) and outperform NALU on (\u00f7, \u221a \u00b7).", "cite_spans": [], "ref_spans": [], "section": "Our Contributions"}, {"text": "Interpretability. We show how a power unit can be used as a highly interpretable model for equation discovery of dynamical systems. Specifically, we demonstrate its ability to identify a model that can be interpreted as a SIR model with fractional powers (Sec. 4.1) that was used to fit the COVID-19 outbreak in various countries [Taghvaei et al., 2020 ].", "cite_spans": [{"start": 330, "end": 352, "text": "[Taghvaei et al., 2020", "ref_id": null}], "ref_spans": [], "section": "Our Contributions"}, {"text": "Several different approaches to automatically solve arithmetic tasks have been studied in recent years. Approaches include Neural GPUs [Kaiser and Sutskever, 2016] , Grid LSTMs [Kalchbrenner et al., 2016] , Neural Turing Machines [Graves et al., 2014] , and Neural Random Access Machines [Kurach et al., 2016] . They solve tasks like binary addition and multiplication, or single-digit arithmetic. The Neural Status Register [Faber and Wattenhofer, 2020] focusses on control flow. The Neural Arithmetic Expression Calculator [Chen et al., 2018] , a hierarchical reinforcement learner, is the only method that solves the division problem, but it operates on character sequences of arithmetic expressions. Related is symbolic integration with transformers [Lample and Charton, 2019] . Unfortunately, most of the named models have severe problems with extrapolation Johansen, 2019, Saxton et al., 2019] . A solution to the extrapolation problem could be Neural Arithmetic Units. They are designed with an inductive bias towards systematic, arithmetic computation. However, currently, they are limited in their capabilities of expressing the full range of simple arithmetic operations (+, \u00d7, \u00f7). In the following two sections, we briefly describe the currently available arithmetic layers, including their advantages and drawbacks. Trask et al. [2018] have demonstrated the severity of the extrapolation problem of dense networks for even the simplest arithmetic operations, such as summing or multiplying two numbers. In order to increase the power of abstraction for arithmetic tasks, they propose the Neural Arithmetic Logic Unit (NALU), which is capable of learning (+, \u00d7, \u00f7). However, the NALU cannot handle negative inputs correctly due to the logarithm in Eq. 2:", "cite_spans": [{"start": 135, "end": 163, "text": "[Kaiser and Sutskever, 2016]", "ref_id": null}, {"start": 177, "end": 204, "text": "[Kalchbrenner et al., 2016]", "ref_id": "BIBREF9"}, {"start": 230, "end": 251, "text": "[Graves et al., 2014]", "ref_id": "BIBREF6"}, {"start": 288, "end": 309, "text": "[Kurach et al., 2016]", "ref_id": "BIBREF10"}, {"start": 425, "end": 454, "text": "[Faber and Wattenhofer, 2020]", "ref_id": "BIBREF4"}, {"start": 525, "end": 544, "text": "[Chen et al., 2018]", "ref_id": "BIBREF1"}, {"start": 754, "end": 780, "text": "[Lample and Charton, 2019]", "ref_id": "BIBREF12"}, {"start": 863, "end": 899, "text": "Johansen, 2019, Saxton et al., 2019]", "ref_id": null}, {"start": 1328, "end": 1347, "text": "Trask et al. [2018]", "ref_id": "BIBREF22"}], "ref_spans": [], "section": "Related Work"}, {"text": "Definition (NALU). The NALU consits of a (+) and a (\u00d7) path that share their weights\u0174 andM .", "cite_spans": [], "ref_spans": [], "section": "Neural Arithmetic Logic Units"}, {"text": "Multiplication: m = exp\u0174 (log(|x| + )) (2) Output: y = a g + m (1 \u2212 g) g = \u03c3(Gx)", "cite_spans": [], "ref_spans": [], "section": "Neural Arithmetic Logic Units"}, {"text": "Additionally, the logarithm destabilizes training to the extent that the chance of success can drop below 20% for (+, \u00d7), it becomes practically impossible to learn (\u00f7) and difficult to learn from small inputs in general [Madsen and Johansen, 2019] . Schl\u00f6r et al. [2020] provide a detailed description of the shortcomings of the NALU, and they suggest an improved NALU (iNALU). The iNALU addresses the NALU's problems through several mechanisms. It has independent addition and multiplication weights for Eq. 1 and Eq. 2, clips weights and gradients to improve training stability, regularizes the weights to push them away from zero, and, most importantly, introduces a mechanism to recover the sign that is lost due to the absolute value in the logarithm. Additionally, the authors propose to reinitialize the network if its loss is not improving during training. We include the iNALU in one of our experiments and find that it only slightly improves the NALU's performance (Sec. 4 .2) at the cost of a significantly more complicated unit. Our NPU avoids all these mechanisms by internally using complex arithmetics.", "cite_spans": [{"start": 221, "end": 248, "text": "[Madsen and Johansen, 2019]", "ref_id": "BIBREF13"}, {"start": 251, "end": 271, "text": "Schl\u00f6r et al. [2020]", "ref_id": "BIBREF19"}, {"start": 976, "end": 983, "text": "(Sec. 4", "ref_id": null}], "ref_spans": [], "section": "Neural Arithmetic Logic Units"}, {"text": "Instead of trying to fix the NALU's convergence issues, Madsen and Johansen [2020] propose a new unit for (\u00d7) only. The Neural Multiplication Unit (NMU) uses explicit multiplications and learns to gate between identity and (\u00d7) of inputs. The NMU is defined by Eq. 4 and is typically used in conjunction with the so-called Neural Addition Unit (NAU) in Eq. 5.", "cite_spans": [{"start": 56, "end": 82, "text": "Madsen and Johansen [2020]", "ref_id": "BIBREF14"}], "ref_spans": [], "section": "Neural Multiplication Unit & Neural Addition Unit"}, {"text": "Definition (NMU & NAU). NMU and NAU are two units that can be stacked to model (+, \u00d7).", "cite_spans": [], "ref_spans": [], "section": "Neural Multiplication Unit & Neural Addition Unit"}, {"text": "Both NMU and NAU are regularized with R = ij min(|W ij |, |1 \u2212 W ij |), and their weights are clipped, which biases them towards learning an operation or pruning it completely. The combination of NAU and NMU can thus learn (+, \u00d7) for both positive and negative inputs. Training NAU and NMU is stable and succeeds much more frequently than with the NALU, but they cannot represent (\u00f7), which we address with our NPU.", "cite_spans": [], "ref_spans": [], "section": "Neural Multiplication Unit & Neural Addition Unit"}, {"text": "To fix the deficiencies of current arithmetic units, we propose a new arithmetic unit (inspired by NALU) that can learn arbitrary products of power functions ( x wi i ) (including \u00d7, \u00f7) for positive and negative numbers, and still train well. Combined with the NAU, we solve the full range of arithmetic operations. This is possible through a simple modification of the (\u00d7)-path of the NALU (Eq. 6). We suggest to replace the logarithm of the absolute value by the complex logarithm and to allow W to be complex as well. Since the complex logarithm is defined for negative inputs, the NPU does not have a problem with negative numbers. A complex W improves convergence at the expense of explainability (see Sec. 4.1). The improvement during training might be explained by the additional imaginary parameters that make it possible to avoid regions with an uninformative gradient signal.", "cite_spans": [], "ref_spans": [], "section": "Neural Power Units"}, {"text": "With the modifications introduced above we can extend the multiplication path of the NALU from", "cite_spans": [], "ref_spans": [], "section": "Naive Neural Power Unit -NaiveNPU"}, {"text": "to use the complex logarithm (log := log complex ) and a complex weight W to", "cite_spans": [], "ref_spans": [], "section": "Naive Neural Power Unit -NaiveNPU"}, {"text": "The complex log in Eq. 7 lifts the positivity constraint on x resulting in a layer that can process both positive and negative numbers correctly. A complex weight matrix W somewhere in a larger network would result in complex gradients in other layers. This would effectively result in doubling the number of parameters of the whole network. As we are only interested in real networks outputs, we can avoid this doubling by considering only the real part of the output z:", "cite_spans": [], "ref_spans": [], "section": "Naive Neural Power Unit -NaiveNPU"}, {"text": "Above we have used Euler's formula 2 and the fact that the complex logarithm for real valued inputs is", "cite_spans": [], "ref_spans": [], "section": "Naive Neural Power Unit -NaiveNPU"}, {"text": "where k = 0 if r \u2265 0 and k = 1 if r < 0. A diagram of the NaiveNPU is shown in Fig. 1 .", "cite_spans": [], "ref_spans": [{"start": 79, "end": 85, "text": "Fig. 1", "ref_id": null}], "section": "Naive Neural Power Unit -NaiveNPU"}, {"text": "Definition (NaiveNPU). The Naive Neural Power Unit with matrices W r and W i representing real and imaginary part of the complex numbers defined as", "cite_spans": [], "ref_spans": [], "section": "Naive Neural Power Unit -NaiveNPU"}, {"text": "The NaiveNPU has difficulties to converge on large scale tasks, and to reach sparse results in cases where the input to a given row is small. We demonstrate this on a toy example of learning the identity on one of two inputs and neglecting the second one, f (x 1 , x 2 ) = x 1 :", "cite_spans": [], "ref_spans": [], "section": "Naive Neural Power Unit -NaiveNPU"}, {"text": "The left plot in Fig. 3 depicts the gradient norm of NPU and NaiveNPU for a batch of two-dimensional inputs. One input is small and irrelevant. Even in this simple example, gradient of the NaiveNPU is close to zero in large parts of the parameter space This can be explained as follows. One row of NaiveNPU weights effectively raises each input to a power and multiplies them: x w1 1 x w2 2 . . . x wn n . If a single input x i is constantly close to zero (i.e. irrelevant), the whole row will be zero, no matter what its weights are and the gradient information on all other weights is lost. Therefore, we introduce a gate on the input of the NPU that can turn irrelevant inputs into 1s. A diagram of the NPU is shown in Fig. 2 . Definition (NPU). The NPU extends the NaiveNPU by the relevance gate g on the input x.", "cite_spans": [], "ref_spans": [{"start": 17, "end": 23, "text": "Fig. 3", "ref_id": null}, {"start": 722, "end": 728, "text": "Fig. 2", "ref_id": null}], "section": "Naive Neural Power Unit -NaiveNPU"}, {"text": "The central plot of Fig. 3 shows the gradient of the NPU on the identity task with its initial gate setting of g 1 = g 2 = 0.5. The large zero-gradient region of the NaiveNPU is gone. The last plot shows the same loss for g 1 = 1 and g 2 = 0, which corresponds to the correct gates at the end of NPU training. The gradient is independent of w 2 , which means that it can easily be pruned by a simple regularization such as L1. In Sec. 4.3 we show how important the relevance gating mechanism is for the convergence and sparsity of large models. Sparsity is especially important in order to use the NPU as an interpretable model.", "cite_spans": [], "ref_spans": [{"start": 20, "end": 26, "text": "Fig. 3", "ref_id": null}], "section": "Naive Neural Power Unit -NaiveNPU"}, {"text": "We recommend initializing the NPU with a Glorot Uniform distribution on the real weights W r . The imaginary weights W i can be initialized to zeros, so they will only be used where necessary, and the gate g with 0.5, so the NPU can choose to output 1. Figure 3 : Norm of the gradient of NaiveNPU and NPU for the task of learning the identity on x 1 . Inputs and loss are defined on the right, gradient surfaces on the left (black areas are beyond the color scale). The correct solution is w 1 = 1 and w 2 = 0. The NaiveNPU has a large zero gradient region for w 2 > 0.75, while the NPU's surface is much more informative. The gates for central plot are fixed at g 1 = g 2 = 0.5 which corresponds to the initial gate parameters. During training they will adjust as needed, in this case to g 1 = 1 and g 2 = 0. W i is set to zero in all plots.", "cite_spans": [], "ref_spans": [{"start": 253, "end": 261, "text": "Figure 3", "ref_id": null}], "section": "Initialization"}, {"text": "Definition (RealNPU). In many practical tasks, such as multiplication or division, the final value of W i should be equal to zero. We will denote NPU with removed parameters for the imaginary part as RealNPU and study the impact of this change on convergence in Sec. 4.", "cite_spans": [], "ref_spans": [], "section": "Initialization"}, {"text": "In ", "cite_spans": [], "ref_spans": [], "section": "Experiments"}, {"text": "Data-driven models such as SINDy [Champion et al., 2019] or Neural Ordinary Differential Equations (NODE, Chen et al. [2019] ) are used more and more in scientific applications. Recently, Universal Differential Equations (UDEs, Rackauckas et al. [2020] ) were introduced which aim to combine data-driven models with physically informed differential equations to maximize interpretability/explainability of the resulting models.", "cite_spans": [{"start": 33, "end": 56, "text": "[Champion et al., 2019]", "ref_id": "BIBREF0"}, {"start": 106, "end": 124, "text": "Chen et al. [2019]", "ref_id": "BIBREF2"}, {"start": 228, "end": 252, "text": "Rackauckas et al. [2020]", "ref_id": "BIBREF16"}], "ref_spans": [], "section": "Equation Discovery of an Epidemiological Model"}, {"text": "If an ODE model is composed of dense layers, its direct interpretation is problematic and has to be performed retrospectively. The class of models based on SINDy is interpretable by design, however it can only provide explanation within a linear combination of predefined set of basis functions. Thus, it cannot learn models with unknown fractional powers. We will demonstrate that the NPU is capable of doing so. An example of an ODE that contains powers is a modification of the classical epidemiological SIR model [?] to fractional powers (fSIR, Taghvaei et al. [2020] ), which was shown to be a beneficial modification for modelling the COVID-19 outbreak. The classical SIR model is built from three variables: S (susceptible), I (infectious), and R (recovered/removed). Arguably the most important part of the model is the transmission rate r, which is typically taken to be proportional to the product of S and I. Taghvaei et al. [2020] argue that, especially in the initial phase of an epidemic, the boundary areas of infected and susceptible cells scale with a fractional power, which leads to Eq. 15: L with L1 regularization. L = MSE(X, NODE \u03b8 (u 0 )) + \u03b2||\u03b8|| 1 .", "cite_spans": [{"start": 549, "end": 571, "text": "Taghvaei et al. [2020]", "ref_id": null}, {"start": 920, "end": 942, "text": "Taghvaei et al. [2020]", "ref_id": null}], "ref_spans": [], "section": "Equation Discovery of an Epidemiological Model"}, {"text": "We train each model for 3000 steps with the ADAM optimizer and a learning rate of 0.005, and subsequently with LBFGS until convergence (or for maximum 1000 steps). For each model type, we run a small grid search to build a Pareto front with h \u2208 {6, 9, 12, 15, 20} and \u03b2 \u2208 {0, 0.01, 0.1, 1}, where each hyper-parameter pair is run five times. The resulting Pareto front is shown on the left of Fig. 4 . The NPU reaches much sparser and better solutions than the dense network. The RealNPU has problems to converge in the majority of cases, however, there are a few models in the bottom left that reach a very low MSE and have very few parameters. The best of these models is shown in Fig. 5 . It looks strikingly similar to the fSIR model in matrix form:", "cite_spans": [], "ref_spans": [{"start": 393, "end": 399, "text": "Fig. 4", "ref_id": null}, {"start": 683, "end": 689, "text": "Fig. 5", "ref_id": null}], "section": "Equation Discovery of an Epidemiological Model"}, {"text": "Reading Fig. 5 from right to left, we can extract the ODE that the RealNPU represents. The first hidden variable correctly identified the transmission rate as a product of two fractional powers r = I \u03b3 S \u03ba with \u03ba = 0.57 and \u03b3 = 0.62, which is close to the true values \u03b3 = \u03ba = 0.5. The second, third and the last hidden variable were found to be irrelevant (the relevance gate returns 1). The fourth hidden variable is a selector of the second input I, and the fifth hidden variable is selector of a power of R, R 0.64 In the second layer, the NAU combines the correct hidden outputs from the NPU such that\u1e60 is composed of the negative transmission rate r and positive R.\u0130 and\u1e58 are also composed of the correct hidden variables, with the parameters \u03b1, \u03b2, \u03b7 being not far off from the truth. We conclude that even with this very naive approach, the RealNPU can recover a SIR model that contains fractional powers. In summary, the NPU can work well in sequential tasks, and we have shown that we can reach highly interpretable results with the RealNPU, but in practice, using the RealNPU might be difficult due to its lower success rate. With a more elaborate analysis, it should be possible to reach the same solutions with the full NPU and e.g. a strong regularization of its imaginary parameters, because Figure 6 : Comparison of extrapolation quality of different models learning Eq. 18. Each column represents the best model of 20 runs that were trained on the range U(0.1, 2). Lighter color implies lower error.", "cite_spans": [], "ref_spans": [{"start": 8, "end": 14, "text": "Fig. 5", "ref_id": null}, {"start": 1305, "end": 1313, "text": "Figure 6", "ref_id": null}], "section": "Equation Discovery of an Epidemiological Model"}, {"text": "In this experiment we compare six different layers (NPU, RealNPU, NMU, NALU, iNALU, Dense) on a small problem with two inputs and four outputs. The objective is to learn the function f : R 2 \u2192 R 4 with a standard MSE loss:", "cite_spans": [], "ref_spans": [], "section": "Simple Arithmetic Task"}, {"text": "f (x, y) = (x + y, xy, x/y,", "cite_spans": [], "ref_spans": [], "section": "Simple Arithmetic Task"}, {"text": "Each model has two layers with a hidden dimension h. E.g. the NPU model is defined by NPU = Chain(NPU(2, h = 6), NAU(b = 6, 4)). The remaining models that are used in the tables and plots are given in Tab. A3. To obtain valid results in case of division we train on positive, non-zero inputs, but test on negative, non-zero numbers (except for test inputs to the square-root): (x train , y train ) \u223c U(0.1, 2) (x test , y test ) \u223c R(-4.1:0.2:4) (x test, sqrt , y test, sqrt ) \u223c R(0.1:0.1:4) (20) where R denotes a range with start, step, and end. We train each model for 20 000 steps with the ADAM optimizer, a learning rate of 0.001, and a batch size of 100. The input samples are generated on the fly during training. Fig. 6 shows the error surface of the best of 20 models on each task. Tab. A2 lists the corresponding averaged testing errors of all 20 models.", "cite_spans": [], "ref_spans": [{"start": 720, "end": 726, "text": "Fig. 6", "ref_id": null}], "section": "Simple Arithmetic Task"}, {"text": "Both NPUs successfully learn (+, \u00d7, \u00f7, \u221a \u00b7) and clearly outperform NALU and iNALU on all tasks. The NPUs are on par with the NMU for (+), but the NMU is better at (\u00d7) due to its inductive bias. The NMU cannot learn (\u00f7, \u221a \u00b7). The fact that the RealNPU performs slightly better than the NPU indicates that the task is easy enough to not require the imaginary parameters to help convergence. In such a case, the RealNPU generalizes better because it corresponds to the task it is trying to learn.", "cite_spans": [], "ref_spans": [], "section": "Simple Arithmetic Task"}, {"text": "One of the most important properties of a layer in a neural network is its ability to scale. With the large scale arithmetic task we show that the NPU works reliably on many-input tasks that are heavily over-parametrized. In this section we compare NALU, NMU, NPU, RealNPU, and the NaiveNPU on a task that is identical to the 'arithmetic task' that Madsen and Johansen [2020] and Trask et al. [2018] analyse as well. The goal is to sum two subsets of a 100 dimensional vector and apply an operation (like \u00d7) to the two summed subsets. The dataset generation is defined in the set of Eq. 21, with the parameters from Tab. A5. a = s1,end i=s1,start Figure 7 : Testing MSE over number of non-zero parameters (w i > 0.001) of the large scale arithmetic task. Again, the NMU outperforms the NPU on its native tasks, addition and multiplication. The NPU is the best at division and square-root. The NaiveNPU without the relevance gate is far off, because it does not have the necessary gradient signal to converge, as discussed in Sec. 3.2 where starting and ending values s i,start , s i,end of the summations are chosen such that a and b come from subsets of the input vector x with a given overlap. The training objective is standard MSE, regularized with L1:", "cite_spans": [{"start": 349, "end": 375, "text": "Madsen and Johansen [2020]", "ref_id": "BIBREF14"}, {"start": 380, "end": 399, "text": "Trask et al. [2018]", "ref_id": "BIBREF22"}], "ref_spans": [{"start": 647, "end": 655, "text": "Figure 7", "ref_id": null}], "section": "Large Scale Arithmetic Task"}, {"text": "where \u03b2 is scheduled to be low in the beginning of training and stronger towards the end. Specifics of the used models and their hyper-parameters are defined in Tab. A4 & A6. Madsen and Johansen [2020] perform an extensive analysis of this task with different subset and overlap ratios, varying model and input sizes, and much more, establishing that the combination of NAU/NMU outperforms the NALU. We focus on the comparison of NPU, RealNPU, NMU, and NALU on the default parameters of Madsen and Johansen [2020] which sets the subset ratio to 0.5 and the overlap ratio to 0.25 (details in Tab. A5). We include the NaiveNPU (without the relevance gate) to show how important the gating mechanism is for both sparsity and overall performance. Fig. 7 plots testing errors over the number of non-zero parameters for all models and tasks. The addition plot shows that NMU, NPU, and RealNPU successfully learn and extrapolate on (+) with the NMU converging to the sparsest and most accurate models. On (\u00d7), the best NMU models outperform the NPU and RealNPU, but some NMUs do not converge at all. The testing MSE of the NALU is so large that it is excluded from the plot. On (\u00f7, \u221a \u00b7) the NPU clearly outperforms all other layers in MSE and sparsity. Generally, the difference between the NaiveNPU and the other NPUs is huge and demonstrates how important the relevance gate is both for convergence and sparsity. The NPUs with relevance gates effectively convert irrelevant inputs to 1s, while the NaiveNPU is stuck on the zero gradient plateau.", "cite_spans": [{"start": 175, "end": 201, "text": "Madsen and Johansen [2020]", "ref_id": "BIBREF14"}, {"start": 487, "end": 513, "text": "Madsen and Johansen [2020]", "ref_id": "BIBREF14"}], "ref_spans": [{"start": 743, "end": 749, "text": "Fig. 7", "ref_id": null}], "section": "Large Scale Arithmetic Task"}, {"text": "We introduced the Neural Power Unit that addresses the deficiencies of current arithmetic units: it can learn arbitrary power functions for positive, negative, and small numbers. We showed that the NPU outperforms its main competitor (NALU) and reaches performance that is on par with the multiplication specialist NMU (Sec. 4.2 & 4.3) . Additionally, we have demonstrated that the NPU converges consistently, even on sequential tasks. The RealNPU can be used as a highly interpretable model that is capable of recovering the governing equations of dynamical systems purely from the data (Sec. 4.1).", "cite_spans": [], "ref_spans": [{"start": 325, "end": 335, "text": "4.2 & 4.3)", "ref_id": null}], "section": "Conclusion"}, {"text": "Current neural network architectures are often perceived as black box models that are difficult to explain or interpret. This becomes highly problematic if ML models are involved in high stakes decisions in e.g. criminal justice, healthcare, or control systems. With the NPU, we hope to contribute to the broad topic of interpretable machine learning, with a focus on scientific applications.", "cite_spans": [], "ref_spans": [], "section": "Statement of Broader Impact"}, {"text": "Additionally, learning to abstract (mathematical) ideas and extrapolate is a fundamental goal that might contribute to more reliable machine learning systems. Table A2 : Testing error on the simple arithmetic task for the different models (i.e. mean of each heatmap in Fig. 6 ). Each value is obtained by computing median (and median absolute deviation) of the error of 20 models. NPU NAU(2, 6) NPU(6, 2) -RealNPU NAU(2, 6) RealNPU(6, 2) -NMU NAU(2, 6) NMU(6, 2) -NALU NALU(2, 6) NALU(6, 2) -iNALU iNALU(2, 6) iNALU(6, 2) -Dense", "cite_spans": [], "ref_spans": [{"start": 159, "end": 167, "text": "Table A2", "ref_id": null}, {"start": 269, "end": 275, "text": "Fig. 6", "ref_id": null}], "section": "Statement of Broader Impact"}, {"text": "Dense(2, 10, \u03c3) Dense(10, 10, \u03c3) Dense(10, 2) Table A6 : Training parameters for the large scale arithmetic task. The \u03b2-parameters define the stepwise exponential growth of the L1 regularization with start, step, growth, and end.", "cite_spans": [], "ref_spans": [{"start": 46, "end": 54, "text": "Table A6", "ref_id": null}], "section": "Statement of Broader Impact"}, {"text": "Task Learning rate Iterations \u03b2 start \u03b2 end \u03b2 step \u03b2 growth Add 1e-2 1e5 1e-5 1e-4 10 000 10 Mult 5e-3 1e5 1e-5 1e-7 10 000 10 Div 5e-3 1e5 1e-9 1e-7 10 000 10 Sqrt 5e-3 1e5 1e-6 1e-4 10 000 10", "cite_spans": [], "ref_spans": [], "section": "Statement of Broader Impact"}], "bib_entries": {"BIBREF0": {"ref_id": "b0", "title": "Data-driven discovery of coordinates and governing equations", "authors": [{"first": "Kathleen", "middle": [], "last": "Champion", "suffix": ""}, {"first": "Bethany", "middle": [], "last": "Lusch", "suffix": ""}, {"first": "J", "middle": ["Nathan"], "last": "Kutz", "suffix": ""}, {"first": "Steven", "middle": ["L"], "last": "Brunton", "suffix": ""}], "year": 2019, "venue": "Proceedings of the National Academy of Sciences", "volume": "116", "issn": "", "pages": "22445--22451", "other_ids": {"DOI": ["http:/www.pnas.org/lookup/doi/10.1073/pnas.1906995116"]}}, "BIBREF1": {"ref_id": "b1", "title": "Neural Arithmetic Expression Calculator", "authors": [{"first": "Kaiyu", "middle": [], "last": "Chen", "suffix": ""}, {"first": "Yihan", "middle": [], "last": "Dong", "suffix": ""}, {"first": "Xipeng", "middle": [], "last": "Qiu", "suffix": ""}, {"first": "Zitian", "middle": [], "last": "Chen", "suffix": ""}], "year": 2018, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {"arXiv": ["arXiv:1809.08590"]}}, "BIBREF2": {"ref_id": "b2", "title": "Neural Ordinary Differential Equations", "authors": [{"first": "T", "middle": ["Q"], "last": "Ricky", "suffix": ""}, {"first": "Yulia", "middle": [], "last": "Chen", "suffix": ""}, {"first": "Jesse", "middle": [], "last": "Rubanova", "suffix": ""}, {"first": "David", "middle": [], "last": "Bettencourt", "suffix": ""}, {"first": "", "middle": [], "last": "Duvenaud", "suffix": ""}], "year": 2019, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {"arXiv": ["arXiv:1806.07366"]}}, "BIBREF3": {"ref_id": "b3", "title": "The Number Sense: How the Mind Creates Mathematics, Revised and Updated Edition", "authors": [{"first": "Stanislas", "middle": [], "last": "Dehaene", "suffix": ""}], "year": 2011, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF4": {"ref_id": "b4", "title": "Neural Status Registers", "authors": [{"first": "Lukas", "middle": [], "last": "Faber", "suffix": ""}, {"first": "Roger", "middle": [], "last": "Wattenhofer", "suffix": ""}], "year": 2020, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {"arXiv": ["arXiv:2004.07085"]}}, "BIBREF5": {"ref_id": "b5", "title": "Finding numbers in the brain", "authors": [{"first": "C", "middle": ["R"], "last": "Gallistel", "suffix": ""}], "year": null, "venue": "Philosophical Transactions of the Royal Society B: Biological Sciences", "volume": "373", "issn": "", "pages": "", "other_ids": {"DOI": ["https:/royalsocietypublishing.org/doi/10.1098/rstb.2017.0119"]}}, "BIBREF6": {"ref_id": "b6", "title": "Neural Turing Machines", "authors": [{"first": "Alex", "middle": [], "last": "Graves", "suffix": ""}, {"first": "Greg", "middle": [], "last": "Wayne", "suffix": ""}, {"first": "Ivo", "middle": [], "last": "Danihelka", "suffix": ""}], "year": 2014, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {"arXiv": ["arXiv:1410.5401"]}}, "BIBREF7": {"ref_id": "b7", "title": "Avik Pal, and Viral Shah. Fashionable Modelling with Flux", "authors": [{"first": "Michael", "middle": [], "last": "Innes", "suffix": ""}, {"first": "Elliot", "middle": [], "last": "Saba", "suffix": ""}, {"first": "Keno", "middle": [], "last": "Fischer", "suffix": ""}, {"first": "Dhairya", "middle": [], "last": "Gandhi", "suffix": ""}, {"first": "Marco", "middle": [], "last": "Concetto Rudilosso", "suffix": ""}, {"first": "Neethu", "middle": ["Mariya"], "last": "Joy", "suffix": ""}, {"first": "Tejan", "middle": [], "last": "Karmali", "suffix": ""}], "year": 2018, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {"arXiv": ["arXiv:1811.01457"]}}, "BIBREF9": {"ref_id": "b9", "title": "Grid Long Short-Term Memory", "authors": [{"first": "Nal", "middle": [], "last": "Kalchbrenner", "suffix": ""}, {"first": "Ivo", "middle": [], "last": "Danihelka", "suffix": ""}, {"first": "Alex", "middle": [], "last": "Graves", "suffix": ""}], "year": 2016, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {"arXiv": ["arXiv:1507.01526"]}}, "BIBREF10": {"ref_id": "b10", "title": "Neural Random-Access Machines", "authors": [{"first": "Karol", "middle": [], "last": "Kurach", "suffix": ""}, {"first": "Marcin", "middle": [], "last": "Andrychowicz", "suffix": ""}, {"first": "Ilya", "middle": [], "last": "Sutskever", "suffix": ""}], "year": 2016, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {"arXiv": ["arXiv:1511.06392"]}}, "BIBREF11": {"ref_id": "b11", "title": "Generalization without systematicity: On the compositional skills of sequence-to-sequence recurrent networks", "authors": [{"first": "M", "middle": [], "last": "Brenden", "suffix": ""}, {"first": "Marco", "middle": [], "last": "Lake", "suffix": ""}, {"first": "", "middle": [], "last": "Baroni", "suffix": ""}], "year": 2018, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {"arXiv": ["arXiv:1711.00350"]}}, "BIBREF12": {"ref_id": "b12", "title": "Deep Learning for Symbolic Mathematics", "authors": [{"first": "Guillaume", "middle": [], "last": "Lample", "suffix": ""}, {"first": "Fran\u00e7ois", "middle": [], "last": "Charton", "suffix": ""}], "year": 2019, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {"arXiv": ["arXiv:1912.01412"]}}, "BIBREF13": {"ref_id": "b13", "title": "Measuring Arithmetic Extrapolation Performance", "authors": [{"first": "Andreas", "middle": [], "last": "Madsen", "suffix": ""}, {"first": "Alexander Rosenberg Johansen", "middle": [], "last": "", "suffix": ""}], "year": 2019, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {"arXiv": ["arXiv:1910.01888"]}}, "BIBREF14": {"ref_id": "b14", "title": "Neural Arithmetic Units", "authors": [{"first": "Andreas", "middle": [], "last": "Madsen", "suffix": ""}, {"first": "Alexander Rosenberg Johansen", "middle": [], "last": "", "suffix": ""}], "year": 2020, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF15": {"ref_id": "b15", "title": "DifferentialEquations.jl -A Performant and Feature-Rich Ecosystem for Solving Differential Equations in Julia", "authors": [{"first": "Christopher", "middle": [], "last": "Rackauckas", "suffix": ""}, {"first": "Qing", "middle": [], "last": "Nie", "suffix": ""}], "year": 2017, "venue": "Journal of Open Research Software", "volume": "5", "issn": "", "pages": "", "other_ids": {"DOI": ["http:/openresearchsoftware.metajnl.com/articles/10.5334/jors.151/"]}}, "BIBREF16": {"ref_id": "b16", "title": "Universal Differential Equations for Scientific Machine Learning", "authors": [{"first": "Christopher", "middle": [], "last": "Rackauckas", "suffix": ""}, {"first": "Yingbo", "middle": [], "last": "Ma", "suffix": ""}, {"first": "Julius", "middle": [], "last": "Martensen", "suffix": ""}, {"first": "Collin", "middle": [], "last": "Warner", "suffix": ""}, {"first": "Kirill", "middle": [], "last": "Zubov", "suffix": ""}, {"first": "Rohit", "middle": [], "last": "Supekar", "suffix": ""}, {"first": "Dominic", "middle": [], "last": "Skinner", "suffix": ""}, {"first": "Ali", "middle": [], "last": "Ramadhan", "suffix": ""}], "year": 2020, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {"arXiv": ["arXiv:2001.04385"]}}, "BIBREF17": {"ref_id": "b17", "title": "Stop Explaining Black Box Machine Learning Models for High Stakes Decisions and Use Interpretable Models Instead", "authors": [{"first": "Cynthia", "middle": [], "last": "Rudin", "suffix": ""}], "year": 2019, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {"arXiv": ["arXiv:1811.10154"]}}, "BIBREF18": {"ref_id": "b18", "title": "Analysing Mathematical Reasoning Abilities of Neural Models", "authors": [{"first": "David", "middle": [], "last": "Saxton", "suffix": ""}, {"first": "Edward", "middle": [], "last": "Grefenstette", "suffix": ""}, {"first": "Felix", "middle": [], "last": "Hill", "suffix": ""}, {"first": "Pushmeet", "middle": [], "last": "Kohli", "suffix": ""}], "year": 2019, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {"arXiv": ["arXiv:1904.01557"]}}, "BIBREF19": {"ref_id": "b19", "title": "iNALU: Improved Neural Arithmetic Logic Unit", "authors": [{"first": "Daniel", "middle": [], "last": "Schl\u00f6r", "suffix": ""}, {"first": "Markus", "middle": [], "last": "Ring", "suffix": ""}, {"first": "Andreas", "middle": [], "last": "Hotho", "suffix": ""}], "year": 2020, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {"arXiv": ["arXiv:2003.07629"]}}, "BIBREF20": {"ref_id": "b20", "title": "On Evaluating the Generalization of LSTM Models in Formal Languages", "authors": [{"first": "Mirac", "middle": [], "last": "Suzgun", "suffix": ""}, {"first": "Yonatan", "middle": [], "last": "Belinkov", "suffix": ""}, {"first": "Stuart", "middle": ["M"], "last": "Shieber", "suffix": ""}], "year": 2018, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF22": {"ref_id": "b22", "title": "Neural Arithmetic Logic Units", "authors": [{"first": "Andrew", "middle": [], "last": "Trask", "suffix": ""}, {"first": "Felix", "middle": [], "last": "Hill", "suffix": ""}, {"first": "Scott", "middle": [], "last": "Reed", "suffix": ""}, {"first": "Jack", "middle": [], "last": "Rae", "suffix": ""}, {"first": "Chris", "middle": [], "last": "Dyer", "suffix": ""}, {"first": "Phil", "middle": [], "last": "Blunsom", "suffix": ""}], "year": 2018, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {"arXiv": ["arXiv:1808.00508"]}}}, "ref_entries": {"FIGREF0": {"text": "NaiveNPU diagram, with input x and output y. Vectors in green, trainables in orange, functions in blue. NPU diagram. The NPU has a relevance gate g (hatched background) in front of the input to the actual unit to prevent zero gradients.", "latex": null, "type": "figure"}, "FIGREF2": {"text": "We have numerically simulated one realization of the fSIR model with the parameters \u03b1 = 0.05, \u03b2 = 0.06, \u03b7 = 0.01, \u03b3 = \u03ba = 0.5, in 40 time steps that are equally spaced in the time interval T = (0, 200), such that the training data X = [S t , I t , R t ] 40 t=1 contains one time series each for S, I, and R. The initial conditions u 0 = [S 0 , I 0 , R 0 ] are set to S 0 = 100, I 0 = 0.01, and R 0 = 0,Figure 4right. We fit the data with three different NODEs composed of different model types: a dense network, the NPU, and the RealNPU. An exemplary model is: NPU = Chain(NPU(3, h), NAU(h, 3)) with variable hidden size h. The detailed models are defined in Tab. A1. The training objective is the loss Pareto fronts of the dense network, the NPU, and the RealNPU. The NPU reaches solutions with lower MSE and fewer parameters than the dense net. The RealNPU mostly yields worse results than the NPU, just in a few cases it converges to very sparse models with good MSE. Visualization of the best RealNPU. Reading from right to left, it takes the SIR variables as an input, then applies the NPU and the NAU. It correctly identifies r as a fractional product in the NPU, and gets the rest of the fSIR parameters almost right in the NAU.", "latex": null, "type": "figure"}, "TABREF1": {"text": "Sec. 4.1, we show how the NPU can help to build better NODE models. Additionally, we use the RealNPU as a highly interpretable model, from which we can directly recover the generating equation of an ODE containing fractional powers. Subsequent Secs. 4.2 & 4.3 compare the NPU to prior art (NALU and NMU) on arithmetic tasks typically used to benchmark arithmetic units.", "latex": null, "type": "table"}, "TABREF3": {"text": "", "latex": null, "type": "table"}, "TABREF4": {"text": "Model definitions for the fSIR task. , h, \u03c3) Dense(h, h, \u03c3) Dense(h, 3)", "latex": null, "type": "table"}, "TABREF6": {"text": "Model definitions for the simple arithmetic task.", "latex": null, "type": "table", "html": "<html><body><table><tr><td>Model </td><td>Layer 1 </td><td>Layer 2 </td><td>Layer 3\n</td></tr><tr><td>NPU </td><td>NAU(2, 6) </td><td>NPU(6, 2) </td><td>-\n</td></tr><tr><td>RealNPU </td><td>NAU(2, 6) </td><td>RealNPU(6, 2) </td><td>-\n</td></tr><tr><td>NMU </td><td>NAU(2, 6) </td><td>NMU(6, 2) </td><td>-\n</td></tr><tr><td>NALU </td><td>NALU(2, 6) </td><td>NALU(6, 2) </td><td>-\n</td></tr><tr><td>iNALU </td><td>iNALU(2, 6) </td><td>iNALU(6, 2) </td><td>-\n</td></tr><tr><td>Dense </td><td>Dense(2, 10,\u03c3) </td><td>Dense(10, 10,\u03c3) </td><td>Dense(10, 2)\n</td></tr></table></body></html>"}, "TABREF7": {"text": "Model definitions for the large scale arithmetic task.", "latex": null, "type": "table", "html": "<html><body><table><tr><td>Model </td><td>Layer 1 </td><td>Layer 2\n</td></tr><tr><td>NPU </td><td>NAU(100, 100) </td><td>NPU(100, 1)\n</td></tr><tr><td>NPU </td><td>NAU(100, 100) </td><td>NPU(100, 1)\n</td></tr><tr><td>NMU </td><td>NAU(100, 100) </td><td>NMU(100, 1)\n</td></tr><tr><td>NALU </td><td>NALU(100, 100) </td><td>NALU(100, 1)\n</td></tr></table></body></html>"}, "TABREF8": {"text": "Dataset parameters for the large scale arithmetic task.Task Input size Subset ratio Overlap ratio Training range Validation range", "latex": null, "type": "table"}}, "back_matter": [{"text": "We thank the authors of the Julia packages Flux.jl [Innes et al., 2018] and DifferentialEquations.jl [Rackauckas and Nie, 2017] ).", "cite_spans": [{"start": 51, "end": 71, "text": "[Innes et al., 2018]", "ref_id": "BIBREF7"}, {"start": 101, "end": 127, "text": "[Rackauckas and Nie, 2017]", "ref_id": "BIBREF15"}], "ref_spans": [], "section": "Acknowledgements"}]}