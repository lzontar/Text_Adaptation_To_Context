{"paper_id": "2aa4efa617a2ed9b62eecb177462d5609ca87aff", "metadata": {"title": "Layered Clause Selection for Theory Reasoning (Short Paper)", "authors": [{"first": "Bernhard", "middle": [], "last": "Gleiss", "suffix": "", "affiliation": {"laboratory": "", "institution": "TU Wien", "location": {"settlement": "Vienna", "country": "Austria"}}, "email": "bgleiss@forsyte.at"}, {"first": "(", "middle": ["B"], "last": "", "suffix": "", "affiliation": {}, "email": ""}, {"first": "Martin", "middle": [], "last": "Suda", "suffix": "", "affiliation": {"laboratory": "", "institution": "Czech Technical University", "location": {"settlement": "Prague, Prague", "country": "Czech Republic"}}, "email": ""}]}, "abstract": [{"text": "Explicit theory axioms are added by a saturation-based theorem prover as one of the techniques for supporting theory reasoning. While simple and effective, adding theory axioms can also pollute the search space with many irrelevant consequences. As a result, the prover often gets lost in parts of the search space where the chance to find a proof is low. In this paper, we describe a new strategy for controlling the amount of reasoning with explicit theory axioms. The strategy refines a recently proposed two-layer-queue clause selection and combines it with a heuristic measure of the amount of theory reasoning in the derivation of a clause. We implemented the new strategy in the automatic theorem prover Vampire and present an evaluation showing that our work dramatically improves the state-of-the-art clause-selection strategy in the presence of theory axioms.", "cite_spans": [], "ref_spans": [], "section": "Abstract"}], "body_text": [{"text": "Thanks to recent advances, saturation-based theorem provers are increasingly used to reason about problems requiring quantified theory-reasoning [4, 6] . One of the standard techniques to enable such reasoning is to automatically add first-order axiomatisations of theories detected in the input [14, 18] . For example, (incomplete) axiomatisations of integer and real arithmetic or McCarthy's axioms of the theory of arrays [15] are routinely used. While this simple technique is often effective, we observed (see also [21] ) two problems inherent to the solution: First, explicit axioms blow up the search space in the sense that a huge amount of consequences can additionally be generated. This happens since theory axioms are often repeatedly combined with certain clauses or among themselves, effectively creating cyclic patterns in the derivation. Most of these consequences would immediately be classified as practically useless by humans. Second, many of the resulting consequences have small weight. This has the unfortunate effect that the age-weight clause selection heuristic [16] , predominantly used by saturation-based theorem provers for guiding the exploration of the search-space, often selects these theory-focused consequences. This way the prover is getting lost in parts of the search space where the chance of finding a proof is low.", "cite_spans": [{"start": 145, "end": 148, "text": "[4,", "ref_id": "BIBREF3"}, {"start": 149, "end": 151, "text": "6]", "ref_id": "BIBREF5"}, {"start": 296, "end": 300, "text": "[14,", "ref_id": "BIBREF13"}, {"start": 301, "end": 304, "text": "18]", "ref_id": "BIBREF17"}, {"start": 425, "end": 429, "text": "[15]", "ref_id": "BIBREF14"}, {"start": 520, "end": 524, "text": "[21]", "ref_id": "BIBREF20"}, {"start": 1088, "end": 1092, "text": "[16]", "ref_id": "BIBREF15"}], "ref_spans": [], "section": "Introduction"}, {"text": "In this paper, we propose to limit the exploration of theory-focused consequences by extending clause selection to take into account the amount of theory reasoning in the derivation of a clause. Our solution consists of two parts. First, we propose an efficiently computable feature of clauses, which we call thdistance, that measures the amount of theory reasoning in the derivation of a clause (Sect. 3). Second, we turn to the general problem of incorporating a feature to a clause selection strategy. There has been an ongoing interest in this problem [24, 25, 28] . We take inspiration from the layered clause selection approach presented in [28] and introduce the refined notion of multi-split queues, which present a principled solution to the incorporation problem (Sect. 2). We finally obtain a clause selection strategy for theory reasoning by instantiating multisplit queues with the feature th-distance. We implemented the resulting clause selection in the state-of-the-art saturation-based theorem prover Vampire [14] , and evaluate its benefits on a relevant subset of the smt-lib benchmark (Sect. 4).", "cite_spans": [{"start": 556, "end": 560, "text": "[24,", "ref_id": null}, {"start": 561, "end": 564, "text": "25,", "ref_id": "BIBREF24"}, {"start": 565, "end": 568, "text": "28]", "ref_id": "BIBREF27"}, {"start": 647, "end": 651, "text": "[28]", "ref_id": "BIBREF27"}, {"start": 1026, "end": 1030, "text": "[14]", "ref_id": "BIBREF13"}], "ref_spans": [], "section": "Introduction"}, {"text": "There are different approaches to adding support for theory reasoning to saturation-based theorem provers, either by extending the prover's inference system with dedicated inference rules [2, 10, 12, 13] or using even more fundamental design changes [1, 7, 20, 22] . While such solutions can result in very efficient reasoning procedures, their development is incredibly challenging and their implementation is a huge effort. As a result, only a few theories are covered by such approaches, in contrast to our technique, which applies to arbitrary theories. In particular, our technique can be used by non-experts on custom theorydomains coming from applications for which no dedicated solution exists. Our work has similar motivation to [21] , where the authors use the set-of-support strategy [30] to limit the amount of reasoning performed with pure theory consequences. However, unlike our technique, they do not impose any limit on clauses whose derivation contains at least one non-theory-axiom.", "cite_spans": [{"start": 188, "end": 191, "text": "[2,", "ref_id": "BIBREF1"}, {"start": 192, "end": 195, "text": "10,", "ref_id": "BIBREF9"}, {"start": 196, "end": 199, "text": "12,", "ref_id": "BIBREF11"}, {"start": 200, "end": 203, "text": "13]", "ref_id": "BIBREF12"}, {"start": 250, "end": 253, "text": "[1,", "ref_id": "BIBREF0"}, {"start": 254, "end": 256, "text": "7,", "ref_id": "BIBREF6"}, {"start": 257, "end": 260, "text": "20,", "ref_id": "BIBREF19"}, {"start": 261, "end": 264, "text": "22]", "ref_id": "BIBREF21"}, {"start": 738, "end": 742, "text": "[21]", "ref_id": "BIBREF20"}, {"start": 795, "end": 799, "text": "[30]", "ref_id": "BIBREF29"}], "ref_spans": [], "section": "Related Work."}, {"text": "The summarized contributions of this paper are: -A new approach for building clause selection strategies from clause features, based on multi-split queues. -A new clause selection strategy for theory reasoning based on the instantiation of multi-split queues with the th-distance-feature measuring the amount of theory reasoning in the derivation of a clause. Our solution applies to arbitrary theories and does not require fundamental changes to the implementation of clause selection. -An implementation of the introduced clause selection strategy in the stateof-the-art theorem prover Vampire. -An experimental evaluation confirming the effectiveness of the technique, by improving on the existing heuristics by up to 37 % on a relevant set of benchmarks.", "cite_spans": [], "ref_spans": [], "section": "Contributions."}, {"text": "We assume the reader to be familiar with the saturation-based theorem proving technology (see, e.g. [3, 17] ) and, in particular, with clause selection, the procedure for deciding, at each iteration of a saturation algorithm, which of the currently passive clauses to next select for activation, i.e. for participation in inferences with the previously activated clauses. To agree on terminology, we start this section by recalling clause selection by age and weight. We then move on to explaining layered clause selection.", "cite_spans": [{"start": 100, "end": 103, "text": "[3,", "ref_id": "BIBREF2"}, {"start": 104, "end": 107, "text": "17]", "ref_id": "BIBREF16"}], "ref_spans": [], "section": "Layered Clause Selection"}, {"text": "The two most important features of a clause for clause selection are 1) its age, typically implemented using an ever-increasing \"date of birth\" timestamp, and 2) weight, which refers to the number of symbols occurring in the clause. A theorem prover prefers to select clauses that are old, which implicitly corresponds to a breadth-first search strategy, and clauses that are light, which is a form of best-first search (clauses with few symbols are cheaper to process, tend to be stronger simplifiers, and are intuitively closer to the ultimate target, the empty clause). In practice, the best performance is achieved by combining these two criteria [16, 25] . This is achieved by storing the passive clauses in two queues, one sorted by age and the other by weight, and setting a ratio to specify how the selection alternates between picking from these two queues.", "cite_spans": [{"start": 651, "end": 655, "text": "[16,", "ref_id": "BIBREF15"}, {"start": 656, "end": 659, "text": "25]", "ref_id": "BIBREF24"}], "ref_spans": [], "section": "Layered Clause Selection"}, {"text": "Layered Selection. In the system description of GKC [28] , Tammet describes an idea of using two layers of queues to organise clause selection. The first layer relies on the just-described combination of selection by age and weight. In the second layer, clauses are split into disjoint groups using a certain property (e.g., \"being derived from the goal or not\" could define two groups), each group is represented by two sub-queues of the first layer, and the decision from which group to select the next clause is dictated by a new second-layer ratio. Although Tammet does not expand much on the insights behind using the layered approach, he reports it highly beneficial for the performance of GKC. In our understanding, the additional layer (in principle, there could be more than two) provides a clean way of incorporating into clause selection a new notion of what a preferred clause should be, without a priori disturbing the already established and tuned primary approach, such as selection by age and weight. 1 Our preliminary experiments with the idea (instantiated with the derivedfrom-the-goal property) found it useful, but not as powerful as other goaldirected heuristics in Vampire. In particular, finding a universally good ratio between the \"good\" clauses and the \"bad\" ones seemed hard. What we propose here instead (and what also led in our experiment to a greater performance gain) is to instead organise the clauses into groups with \"good\" ones and \"all\". Here the second group contains all the passive clauses and essentially represents a fallback to the original single-layer strategy. The advantage of this new take on layered selection is that a bad clause is only selected if 1) it is time to try a bad clause according to the second-layer ratio and 2) the best bad clause is also the current overall best according to the age-weight perspective. This makes picking a good second-layer ratio much easier. In particular, one can \"smoothly\" move (by changing the second-layer ratio) from a high preference for the \"all\" secondlayer queue towards selecting more \"good\" clauses without necessarily having to select any \"bad\" ones.", "cite_spans": [{"start": 52, "end": 56, "text": "[28]", "ref_id": "BIBREF27"}, {"start": 1017, "end": 1018, "text": "1", "ref_id": "BIBREF0"}], "ref_spans": [], "section": "Layered Clause Selection"}, {"text": "Multi-split Queues. We propose multi-split queues to realize layered selection with second layer groups defined by a real-valued clause feature. Let the cutoffs c 1 , . . . , c k be monotonically increasing real numbers with c k = \u221e, and let the ratio r 1 : . . . : r k be a list of positive integer values. These together determine a layered selection scheme with k groups C i = {C|\u03bc(C) \u2264 c i } for i = 1, . . . , k, such that we select from the i-th group with a frequency r i /(\u03a3 k j=1 r j ). It is easy to see that multi-split queues generalise the binary \"good\" vs \"all\" arrangement, since, thanks to monotonicity of the cutoffs, we have C i \u2286 C i+1 . Moreover, since c k = \u221e, C k will contain all the passive clauses.", "cite_spans": [], "ref_spans": [{"start": 145, "end": 168, "text": "Let the cutoffs c 1 , .", "ref_id": null}], "section": "Layered Clause Selection"}, {"text": "In this section, we instantiate the idea of multi-split queues from Sect. 2 with a concrete clause evaluation feature, which measures the amount of theory reasoning in the derivation of a clause. We assume that the initial clauses given to the saturation algorithm, which we simply refer to as axioms, consists of non-theory axioms obtained by classifying the input problem and theory axioms added to facilitate theory reasoning.", "cite_spans": [], "ref_spans": [], "section": "Theory Part"}, {"text": "We start by defining the fraction of theory reasoning in the derivation of a general clause. This relies on counting the number of theory axioms, resp. the number of all axioms, in the derivation-tree using running sums.", "cite_spans": [], "ref_spans": [], "section": "Theory Part"}, {"text": "For a theory axiom C, define both thAx (C) and allAx (C) as 1. For a non-theory axiom C, define thAx (C) as 0 and allAx (C) as 1. For a derived clause C with parent clauses C 1 , . . . , C n , define thAx (C) as i thAx (C i ) and allAx (C) as i allAx (C i ). Finally, we set frac(C) := thAx (C)/allAx (C).", "cite_spans": [], "ref_spans": [], "section": "Definition 2."}, {"text": "Assume now that for a given problem we expect (based on domain knowledge and experience) the fraction of theory reasoning in the final refutation frac(\u22a5) to be at most 1/d, for a positive integer d. Our clause evaluation feature th-distance measures how much frac(C) exceeds the expected \"maximally allowed\" fraction 1/d. More precisely, th-distance counts the number of non-theory axioms which the derivation of C would additionally need to contain to achieve a ratio 1/d. Our heuristic is based on the idea that a clause with small th-distance is more likely to contribute to the refutation than a clause with high th-distance. We therefore want to ensure that clause selection focuses on selecting clauses C with a low value th-distance(C). We realize this with the multi-split queues (see Sect. 2), instantiating the clause evaluation feature \u03bc by th-distance, resulting in a second layer clause selection strategy with parameters d, c 1 , . . . , c k and r 1 : . . . : r k .", "cite_spans": [], "ref_spans": [], "section": "Definition 2."}, {"text": "We implemented the heuristic described in Sect. 3 in Vampire (version 4.4). Our newly added implementation consists of about 900 lines of C++ code and is compatible with both the LRS saturation algorithm [23] and Avatar [29] .", "cite_spans": [{"start": 204, "end": 208, "text": "[23]", "ref_id": "BIBREF22"}, {"start": 220, "end": 224, "text": "[29]", "ref_id": "BIBREF28"}], "ref_spans": [], "section": "Experiments"}, {"text": "For evaluation, we used the following subset of the most recent version (as of January 2020) of SMTLIB [5] : We took all the problems from the sub-logics that contain quantification and theories, such as LIA, LRA, NRA, ALIA, UFDT, . . . except for those requiring bit-vector (BV) or floating-point (FP) reasoning, currently not supported by Vampire. Subsequently, we excluded problems known to be satisfiable and those that were provable using Vampire's default strategy in 10 s either without adding theory axioms or while performing clause selection by age only. This way, we obtained 20 795 problems. 2 As a first experiment, we compared the number of problems solved in 10 s by the default strategy 3 and its various extensions by multi-split queues defined in Sect. 3. 4 The d-value, cutoffs and ratio values for the heuristic were selected by educated guessing and randomised hill-climbing. Table 1 lists results of the best obtained configurations. It can be seen that already with two second layer queues a substantial improvement of 25.5% over the default is achieved. Moreover, while it is increasingly more difficult to choose good values for the many parameters defining a configuration with multiple queues, their use further significantly improves the number of problems solved. In a second experiment, 5 we ran Vampire's strategy schedule for SMTCOMP 2019 [11] on our problems and also the same schedule additionally imposing the most successful second-layer clause selection scheme layered4 from the first experiment. The time limit was 500 s per problem. Table 2 shows the results.", "cite_spans": [{"start": 103, "end": 106, "text": "[5]", "ref_id": "BIBREF4"}, {"start": 771, "end": 775, "text": "3. 4", "ref_id": null}, {"start": 1317, "end": 1318, "text": "5", "ref_id": "BIBREF4"}, {"start": 1371, "end": 1375, "text": "[11]", "ref_id": "BIBREF10"}], "ref_spans": [{"start": 897, "end": 904, "text": "Table 1", "ref_id": "TABREF0"}, {"start": 1572, "end": 1579, "text": "Table 2", "ref_id": "TABREF1"}], "section": "Experiments"}, {"text": "We can see that the version with second-layer queues improved over the standard schedule by 150 solved problems. This is a very significant result, suggesting the achieved control of theory reasoning is incredibly helpful. Moreover, one should keep in mind that strategies in a schedule are carefully selected to complement each other and even locally good changes in the strategies often destroy this complementarity (cf., e.g., [19, 21] ). In our case, however, we achieve an improvement despite this looming negative effect. Finally, it is very likely that a new schedule, constructed while taking our new technique into account, will be able to additionally cover some of the 194 problems currently only solved by the unaltered schedule.", "cite_spans": [{"start": 430, "end": 434, "text": "[19,", "ref_id": "BIBREF18"}, {"start": 435, "end": 438, "text": "21]", "ref_id": "BIBREF20"}], "ref_spans": [], "section": "Experiments"}, {"text": "We introduced a new clause selection heuristic for reasoning in the presence of explicit theory axioms. The heuristic is based on the combination of multi-split queues and a new clause-feature measuring the amount of theory reasoning in the derivation of a clause. Our experiments show that the new heuristic significantly improves the existing state-of-the-art clause selection strategy. As future work, we want to extend layered clause selection with new clause-features and combine it with the machine-learning-based approach in the style of ENIGMA [8] .", "cite_spans": [{"start": 552, "end": 555, "text": "[8]", "ref_id": "BIBREF7"}], "ref_spans": [], "section": "Conclusion"}], "bib_entries": {"BIBREF0": {"ref_id": "b0", "title": "Superposition modulo linear arithmetic SUP(LA)", "authors": [{"first": "E", "middle": [], "last": "Althaus", "suffix": ""}, {"first": "E", "middle": [], "last": "Kruglov", "suffix": ""}, {"first": "C", "middle": [], "last": "Weidenbach", "suffix": ""}], "year": 2009, "venue": "FroCoS 2009", "volume": "5749", "issn": "", "pages": "84--99", "other_ids": {"DOI": ["10.1007/978-3-642-04222-5_5"]}}, "BIBREF1": {"ref_id": "b1", "title": "Ordered chaining calculi for first-order theories of transitive relations", "authors": [{"first": "L", "middle": [], "last": "Bachmair", "suffix": ""}, {"first": "H", "middle": [], "last": "Ganzinger", "suffix": ""}], "year": 1998, "venue": "J. ACM", "volume": "45", "issn": "6", "pages": "1007--1049", "other_ids": {}}, "BIBREF2": {"ref_id": "b2", "title": "Resolution theorem proving", "authors": [{"first": "L", "middle": [], "last": "Bachmair", "suffix": ""}, {"first": "H", "middle": [], "last": "Ganzinger", "suffix": ""}, {"first": "D", "middle": ["A"], "last": "Mcallester", "suffix": ""}, {"first": "C", "middle": [], "last": "Lynch", "suffix": ""}], "year": 2001, "venue": "Handbook of Automated Reasoning", "volume": "2", "issn": "", "pages": "19--99", "other_ids": {}}, "BIBREF3": {"ref_id": "b3", "title": "Reachability analysis for AWS-based networks", "authors": [{"first": "J", "middle": [], "last": "Backes", "suffix": ""}], "year": 2019, "venue": "CAV 2019", "volume": "11562", "issn": "", "pages": "231--241", "other_ids": {"DOI": ["10.1007/978-3-030-25543-5_14"]}}, "BIBREF4": {"ref_id": "b4", "title": "The Satisfiability Modulo Theories Library", "authors": [{"first": "C", "middle": [], "last": "Barrett", "suffix": ""}, {"first": "P", "middle": [], "last": "Fontaine", "suffix": ""}, {"first": "C", "middle": [], "last": "Tinelli", "suffix": ""}], "year": 2016, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF5": {"ref_id": "b5", "title": "Verifying relational properties using trace logic", "authors": [{"first": "G", "middle": [], "last": "Barthe", "suffix": ""}, {"first": "R", "middle": [], "last": "Eilers", "suffix": ""}, {"first": "P", "middle": [], "last": "Georgiou", "suffix": ""}, {"first": "B", "middle": [], "last": "Gleiss", "suffix": ""}, {"first": "L", "middle": [], "last": "Kovcs", "suffix": ""}, {"first": "M", "middle": [], "last": "Maffei", "suffix": ""}], "year": 2019, "venue": "Formal Methods in Computer Aided Design", "volume": "", "issn": "", "pages": "170--178", "other_ids": {}}, "BIBREF6": {"ref_id": "b6", "title": "Hierarchic superposition with weak abstraction", "authors": [{"first": "P", "middle": [], "last": "Baumgartner", "suffix": ""}, {"first": "U", "middle": [], "last": "Waldmann", "suffix": ""}], "year": 2013, "venue": "CADE 2013", "volume": "7898", "issn": "", "pages": "39--57", "other_ids": {"DOI": ["10.1007/978-3-642-38574-2_3"]}}, "BIBREF7": {"ref_id": "b7", "title": "ENIGMA-NG: efficient neural and gradient-boosted inference guidance for E", "authors": [{"first": "K", "middle": [], "last": "Chvalovsk\u00fd", "suffix": ""}, {"first": "J", "middle": [], "last": "Jakubuv", "suffix": ""}, {"first": "M", "middle": [], "last": "Suda", "suffix": ""}, {"first": "J", "middle": [], "last": "Urban", "suffix": ""}], "year": null, "venue": "", "volume": "", "issn": "", "pages": "197--215", "other_ids": {}}, "BIBREF8": {"ref_id": "b8", "title": "CADE 2019", "authors": [{"first": "P", "middle": [], "last": "Fontaine", "suffix": ""}], "year": 2019, "venue": "", "volume": "11716", "issn": "", "pages": "", "other_ids": {"DOI": ["10.1007/978-3-030-29436-6"]}}, "BIBREF9": {"ref_id": "b9", "title": "Extensional crisis and proving identity", "authors": [{"first": "A", "middle": [], "last": "Gupta", "suffix": ""}, {"first": "L", "middle": [], "last": "Kov\u00e1cs", "suffix": ""}, {"first": "B", "middle": [], "last": "Kragl", "suffix": ""}, {"first": "A", "middle": [], "last": "Voronkov", "suffix": ""}], "year": 2014, "venue": "ATVA 2014", "volume": "8837", "issn": "", "pages": "185--200", "other_ids": {"DOI": ["10.1007/978-3-319-11936-6_14"]}}, "BIBREF10": {"ref_id": "b10", "title": "14th International Satisfiability Modulo Theories Competition", "authors": [{"first": "L", "middle": [], "last": "Hadarean", "suffix": ""}, {"first": "A", "middle": [], "last": "Hyvarinen", "suffix": ""}, {"first": "A", "middle": [], "last": "Niemetz", "suffix": ""}, {"first": "G", "middle": [], "last": "Reger", "suffix": ""}], "year": 2019, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF11": {"ref_id": "b11", "title": "The vampire and the FOOL", "authors": [{"first": "E", "middle": [], "last": "Kotelnikov", "suffix": ""}, {"first": "L", "middle": [], "last": "Kov\u00e1cs", "suffix": ""}, {"first": "G", "middle": [], "last": "Reger", "suffix": ""}, {"first": "A", "middle": [], "last": "Voronkov", "suffix": ""}], "year": 2016, "venue": "Proceedings of the 5th ACM SIGPLAN Conference on Certified Programs and Proofs", "volume": "", "issn": "", "pages": "37--48", "other_ids": {}}, "BIBREF12": {"ref_id": "b12", "title": "Coming to terms with quantified reasoning", "authors": [{"first": "L", "middle": [], "last": "Kov\u00e1cs", "suffix": ""}, {"first": "S", "middle": [], "last": "Robillard", "suffix": ""}, {"first": "A", "middle": [], "last": "Voronkov", "suffix": ""}], "year": 2017, "venue": "Proceedings of the 44th ACM SIGPLAN Symposium on Principles of Programming Languages", "volume": "", "issn": "", "pages": "260--270", "other_ids": {}}, "BIBREF13": {"ref_id": "b13", "title": "First-order theorem proving and Vampire", "authors": [{"first": "L", "middle": [], "last": "Kov\u00e1cs", "suffix": ""}, {"first": "A", "middle": [], "last": "Voronkov", "suffix": ""}], "year": 2013, "venue": "CAV 2013", "volume": "8044", "issn": "", "pages": "1--35", "other_ids": {"DOI": ["10.1007/978-3-642-39799-8_1"]}}, "BIBREF14": {"ref_id": "b14", "title": "Towards a mathematical science of computation", "authors": [{"first": "J", "middle": [], "last": "Mccarthy", "suffix": ""}], "year": 1962, "venue": "", "volume": "", "issn": "", "pages": "21--28", "other_ids": {}}, "BIBREF15": {"ref_id": "b15", "title": "Otter 3.0 reference manual and guide", "authors": [{"first": "W", "middle": [], "last": "Mccune", "suffix": ""}], "year": 1994, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF16": {"ref_id": "b16", "title": "A new class of automated theorem-proving algorithms", "authors": [{"first": "R", "middle": ["A"], "last": "Overbeek", "suffix": ""}], "year": 1974, "venue": "J. ACM", "volume": "21", "issn": "2", "pages": "191--200", "other_ids": {}}, "BIBREF17": {"ref_id": "b17", "title": "SPASS+T", "authors": [{"first": "V", "middle": [], "last": "Prevosto", "suffix": ""}, {"first": "U", "middle": [], "last": "Waldmann", "suffix": ""}], "year": 2006, "venue": "Proceedings of the FLoC 2006 Workshop on Empirically Successful Computerized Reasoning, 3rd International Joint Conference on Automated Reasoning, number 192 in CEUR Workshop Proceedings", "volume": "", "issn": "", "pages": "19--33", "other_ids": {}}, "BIBREF18": {"ref_id": "b18", "title": "Old or heavy? Decaying gracefully with age/weight shapes", "authors": [{"first": "M", "middle": [], "last": "Rawson", "suffix": ""}, {"first": "G", "middle": [], "last": "Reger", "suffix": ""}], "year": null, "venue": "", "volume": "", "issn": "", "pages": "462--476", "other_ids": {}}, "BIBREF19": {"ref_id": "b19", "title": "AVATAR modulo theories", "authors": [{"first": "G", "middle": [], "last": "Reger", "suffix": ""}, {"first": "N", "middle": [], "last": "Bjorner", "suffix": ""}, {"first": "M", "middle": [], "last": "Suda", "suffix": ""}, {"first": "A", "middle": [], "last": "Voronkov", "suffix": ""}], "year": 2016, "venue": "GCAI 2016. 2nd Global Conference on Artificial Intelligence", "volume": "41", "issn": "", "pages": "39--52", "other_ids": {}}, "BIBREF20": {"ref_id": "b20", "title": "Set of support for theory reasoning", "authors": [{"first": "G", "middle": [], "last": "Reger", "suffix": ""}, {"first": "M", "middle": [], "last": "Suda", "suffix": ""}], "year": 2017, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF21": {"ref_id": "b21", "title": "Unification with abstraction and theory instantiation in saturation-based reasoning", "authors": [{"first": "G", "middle": [], "last": "Reger", "suffix": ""}, {"first": "M", "middle": [], "last": "Suda", "suffix": ""}, {"first": "A", "middle": [], "last": "Voronkov", "suffix": ""}], "year": 2018, "venue": "TACAS 2018", "volume": "10805", "issn": "", "pages": "3--22", "other_ids": {"DOI": ["10.1007/978-3-319-89960-2_1"]}}, "BIBREF22": {"ref_id": "b22", "title": "Limited resource strategy in resolution theorem proving", "authors": [{"first": "A", "middle": [], "last": "Riazanov", "suffix": ""}, {"first": "A", "middle": [], "last": "Voronkov", "suffix": ""}], "year": 2003, "venue": "J. Symb. Comput", "volume": "36", "issn": "1-2", "pages": "101--115", "other_ids": {}}, "BIBREF24": {"ref_id": "b24", "title": "Performance of clause selection heuristics for saturationbased theorem proving", "authors": [{"first": "S", "middle": [], "last": "Schulz", "suffix": ""}, {"first": "M", "middle": [], "last": "M\u00f6hrmann", "suffix": ""}], "year": 2016, "venue": "IJCAR 2016", "volume": "9706", "issn": "", "pages": "330--345", "other_ids": {"DOI": ["10.1007/978-3-319-40229-1_23"]}}, "BIBREF25": {"ref_id": "b25", "title": "StarExec, a cross community logic solving service", "authors": [{"first": "A", "middle": [], "last": "Stump", "suffix": ""}, {"first": "G", "middle": [], "last": "Sutcliffe", "suffix": ""}, {"first": "C", "middle": [], "last": "Tinelli", "suffix": ""}], "year": 2012, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF26": {"ref_id": "b26", "title": "The 5th and 6th Vampire Workshops", "authors": [{"first": "M", "middle": [], "last": "Suda", "suffix": ""}], "year": 2019, "venue": "Vampire 2018 and Vampire", "volume": "71", "issn": "", "pages": "38--44", "other_ids": {}}, "BIBREF27": {"ref_id": "b27", "title": "GKC: a reasoning system for large knowledge bases", "authors": [{"first": "T", "middle": [], "last": "Tammet", "suffix": ""}], "year": null, "venue": "", "volume": "", "issn": "", "pages": "538--549", "other_ids": {}}, "BIBREF28": {"ref_id": "b28", "title": "AVATAR: the architecture for first-order theorem provers", "authors": [{"first": "A", "middle": [], "last": "Voronkov", "suffix": ""}], "year": 2014, "venue": "CAV 2014", "volume": "8559", "issn": "", "pages": "696--710", "other_ids": {"DOI": ["10.1007/978-3-319-08867-9_46"]}}, "BIBREF29": {"ref_id": "b29", "title": "Efficiency and completeness of the set of support strategy in theorem proving", "authors": [{"first": "L", "middle": [], "last": "Wos", "suffix": ""}, {"first": "G", "middle": ["A"], "last": "Robinson", "suffix": ""}, {"first": "D", "middle": ["F"], "last": "Carson", "suffix": ""}], "year": 1965, "venue": "J. ACM", "volume": "12", "issn": "4", "pages": "536--541", "other_ids": {}}}, "ref_entries": {"FIGREF0": {"text": "The th-distance : Clauses \u2192 N is defined asth \u2212 distance(C) := max(thAx (C) \u00b7 d \u2212 allAx (C), 0).", "latex": null, "type": "figure"}, "TABREF0": {"text": "Comparing clause selection strategies on Vampire's default configuration.", "latex": null, "type": "table"}, "TABREF1": {"text": "Comparing clause selection strategies on Vampire's portfolio configuration.", "latex": null, "type": "table"}}, "back_matter": []}