{"paper_id": "1bfae1e164e0d86da90256dae4a4560ae7ebeaa2", "metadata": {"title": "Foundations for Workflow Application Scheduling on D-Wave System", "authors": [{"first": "Dawid", "middle": [], "last": "Tomasiewicz", "suffix": "", "affiliation": {}, "email": "tomasiewicz.dawid@gmail.com"}, {"first": "Maciej", "middle": [], "last": "Pawlik", "suffix": "", "affiliation": {}, "email": ""}, {"first": "Maciej", "middle": [], "last": "Malawski", "suffix": "", "affiliation": {}, "email": ""}, {"first": "Katarzyna", "middle": [], "last": "Rycerz", "suffix": "", "affiliation": {}, "email": ""}]}, "abstract": [{"text": "Many scientific processes and applications can be represented in the standardized form of workflows. One of the key challenges related to managing and executing workflows is scheduling. As an NPhard problem with exponential complexity it imposes limitations on the size of practically solvable problems. In this paper, we present a solution to the challenge of scheduling workflow applications with the help of the D-Wave quantum annealer. To the best of our knowledge, there is no other work directly addressing workflow scheduling using quantum computing. Our solution includes transformation into a Quadratic Unconstrained Binary Optimization (QUBO) problem and discussion of experimental results, as well as possible applications of the solution. For our experiments we choose four problem instances small enough to fit into the annealer's architecture. For two of our instances the quantum annealer finds the global optimum for scheduling. We thus show that it is possible to solve such problems with the help of the D-Wave machine and discuss the limitations of this approach.", "cite_spans": [], "ref_spans": [], "section": "Abstract"}], "body_text": [{"text": "The paradigm of workflows is commonly used for describing and preserving complex scientific processes and applications [13] . Workflows are usually represented as Directed Acyclic Graphs (DAG) [23] . Each vertex represents a task, while edges designate dependencies or data transfers between tasks. By using such a general representation it is possible to improve application portability and reusability. The abstract graph representation enables decoupling the application from a specific infrastructure and easily extract parts of the process with clear understanding of what the extracted part does and what its dependencies and outputs are. Some examples of scientific applications implemented as workflows include: Montage [4] -image mosaic software used to construct humanperceptible images of sky features from multiple images captured by telescopes; software used by the LIGO collaboration, designed to process data related to detecting gravitational waves [1] ; software designed to predict the occurrence and effects of earthquakes based on geological data [23] . One of the key challenges related to managing and executing scientific workflows is scheduling. The general goal of scheduling is to create a plan of execution with respect to given parameters such as deadline, budget and computing resources. For the scope of this paper we assumed a simple form of workflow scheduling, where we operate on the serverless infrastructure discussed in [3] . In this case the serverless infrastructure is implemented as a set of cloud functions, provided by major cloud service providers, such as Google, Amazon, Azure and IBM. Cloud functions have the potential to be used for compute-intensive tasks, as proposed in [27] , with particular emphasis on challenges which require high levels of infrastructure elasticity. Scheduling workflows for serverless infrastructures can be summarized as defining the runtime parameters of a function based on user-supplied deadline and budget. In this paper we assume that the serverless infrastructure consists of an infinite number of machine instances, while the number of machine types is finite, with each machine type associated with specific cost and performance.", "cite_spans": [{"start": 119, "end": 123, "text": "[13]", "ref_id": "BIBREF12"}, {"start": 193, "end": 197, "text": "[23]", "ref_id": "BIBREF22"}, {"start": 728, "end": 731, "text": "[4]", "ref_id": "BIBREF3"}, {"start": 965, "end": 968, "text": "[1]", "ref_id": "BIBREF0"}, {"start": 1067, "end": 1071, "text": "[23]", "ref_id": "BIBREF22"}, {"start": 1457, "end": 1460, "text": "[3]", "ref_id": "BIBREF2"}, {"start": 1722, "end": 1726, "text": "[27]", "ref_id": "BIBREF26"}], "ref_spans": [], "section": "Introduction"}, {"text": "In recent years, quantum computing has become popular due to its potential ability to solve problems that are beyond the capabilities of classical computing infrastructures. The research is still in its early stage, however there are many theoretical quantum algorithms already available, such as famous polynomial time Shor factorization [26] or O( \u221a N ) complexity Grover search in unsorted databases [16] . A good overview of the current status of theoretical quantum algorithms can be found in [18] . There are also various attempts to implement algorithms on the available quantum hardware: IBM-Q 1 , Rigetti computing 2 or D-Wave 3 . Scheduling problems are assumed to be one of the challenges which might be efficiently solved by this new approach.", "cite_spans": [{"start": 339, "end": 343, "text": "[26]", "ref_id": "BIBREF25"}, {"start": 403, "end": 407, "text": "[16]", "ref_id": "BIBREF15"}, {"start": 498, "end": 502, "text": "[18]", "ref_id": "BIBREF17"}], "ref_spans": [], "section": "Introduction"}, {"text": "In this paper, we present a solution for the workflow scheduling problem with the use of the D-Wave quantum annealer. In particular, we propose a method of reformulating the problem as Quadratic Unconstrained Binary Optimization (QUBO) [21] required by D-Wave. To achieve this, we developed a Binary Integer Linear Programming (BILP) [19] formulation of the problem, which is then translated to QUBO in a similar way as shown in [14] . Finally, we discuss results obtained on the annealer. We attempt to find the optimal solution for selected instances of workflow scheduling problems, which are constrained by the deadline and have the lowest cost possible. This paper is organized as follows. In Sect. 3 we provide the overview of quantum computation with the use of the quantum annealer. In Sect. 4 we present the precise formulation of the problem. In Sect. 5 we provide a complete description of transforming the workflow scheduling problem into a QUBO problem. First, the transformation to BILP is presented, which includes all the constraints necessary to be translated. Next comes BILP to QUBO problem translation, using methods from [14] . Finally, Sects. 6 and 7 present full results with a detailed commentary, as well as discussion and suggestions for future work in this matter.", "cite_spans": [{"start": 236, "end": 240, "text": "[21]", "ref_id": "BIBREF20"}, {"start": 334, "end": 338, "text": "[19]", "ref_id": "BIBREF18"}, {"start": 429, "end": 433, "text": "[14]", "ref_id": "BIBREF13"}, {"start": 1142, "end": 1146, "text": "[14]", "ref_id": "BIBREF13"}], "ref_spans": [], "section": "Introduction"}, {"text": "There is a significant body of knowledge available concerning the topic of scheduling workflows on cloud infrastructures. Due to its widespread adoption, most scheduling solutions operate on Infrastructure as a Service (IaaS) services. To the best of our knowledge, there is no other work directly addressing the problem of workflow scheduling on serverless infrastructures with help of quantum computing. In the presented case, the serverless infrastructure is represented by a Function as a Service (FaaS) type of service. For example, in [2] Arabnejad et al. propose a heuristic list scheduling algorithm with low computational complexity, designed for running workflows on IaaS. Work presented in this paper aims to provide similar features, albeit for FaaS and with help from quantum computing. In particular, we propose a method to create the final execution plan upfront in a short time and at low cost. One of the factors included in the presented algorithm is the sole cost of executing workflow tasks in the cloud. This problem was discussed in more detail in [30] . Zhou et al. addressed the problem of performance offered by cloud services with specific focus on the use case of running workflow applications. The matter of performance offered by serverless infrastructures was studied in [24] , with focus on potential parallelism and application of FaaS as an infrastructure for large-scale scientific workflows. The specific topic of scheduling workflows on serverless infrastructures was addressed by Kijak et al. in [20] , where they proposed a heuristic algorithm for scheduling workflows on cloud functions.", "cite_spans": [{"start": 541, "end": 544, "text": "[2]", "ref_id": "BIBREF1"}, {"start": 1070, "end": 1074, "text": "[30]", "ref_id": "BIBREF29"}, {"start": 1301, "end": 1305, "text": "[24]", "ref_id": "BIBREF23"}, {"start": 1533, "end": 1537, "text": "[20]", "ref_id": "BIBREF19"}], "ref_spans": [], "section": "Related Work"}, {"text": "Although solving scheduling problems with quantum computers is a novelty, some examples of such work are available. In particular, a promising approach is to use the D-Wave quantum annealer based on a chimera graph [5] . A possible method of solving a shop job scheduling problem (JSP) [15] using D-Wave is shown in [29] , however the proposed three-dimensional structure of the problem description is a strong limitation for scalability. In general, many NP-hard problems can be formulated as Ising problems [22] which can then be solved using a quantum annealer. For example [8] discusses the problem of finding maximum cliques in a graph. An important factor for solving problems with the use of quantum annealers is small machine size. In [25] the authors discuss heuristics for solving large-scale problems described in [8] .", "cite_spans": [{"start": 215, "end": 218, "text": "[5]", "ref_id": "BIBREF4"}, {"start": 286, "end": 290, "text": "[15]", "ref_id": "BIBREF14"}, {"start": 316, "end": 320, "text": "[29]", "ref_id": "BIBREF28"}, {"start": 509, "end": 513, "text": "[22]", "ref_id": "BIBREF21"}, {"start": 577, "end": 580, "text": "[8]", "ref_id": "BIBREF7"}, {"start": 743, "end": 747, "text": "[25]", "ref_id": "BIBREF24"}, {"start": 825, "end": 828, "text": "[8]", "ref_id": "BIBREF7"}], "ref_spans": [], "section": "Related Work"}, {"text": "D-Wave 2000Q [5] is an adiabatic quantum computer that, unlike its universal counterparts (e.g. IBM-Q or Rigetti), cannot run algorithms implemented with the use of general quantum circuits. Therefore, in spite of its architecture offering a relatively large number of qubits, its usage is limited to certain types of optimisation problems. It is a fully analog machine, the result of which depends on the value of the magnetic field applied to each qubit and the value of the connection between qubits (coupler). Programming the D-Wave 2000Q computer involves determining values of fields and associations. The aim of quantum annealing is to find the minimal energy state for the problem defined by a programmer. Annealing begins with an initial well-known quantum system for which the minimal energy state is known. Then it slowly switches to the quantum system related to the search problem. Ideally, during the whole process of switching, the system remains in its minimal energy state, so it should end up in the minimal energy state of the intended problem.", "cite_spans": [{"start": 13, "end": 16, "text": "[5]", "ref_id": "BIBREF4"}], "ref_spans": [], "section": "D-Wave Computing Overview"}, {"text": "From a programmer's perspective, the problems to be solved must be formulated as an objective function using the Ising model [22] or, alternatively, a QUBO problem description [21] . Both approaches are isomorphic and can be transformed into each other in polynomial time. In this study, we choose to use QUBO formulation of the problem. In general, a QUBO problem consists of a matrix Q of size NxN, where N is the number of used binary variables and the size of the vector of binary variables that constitute the searched state. It can be converted without loss of generality to the upper triangular matrix as described in [14] . The actual problem solved by D-Wave is to find the final state of n binary variables X = (x 1 , x 2 ...x n ) that minimizes the objective function defined as", "cite_spans": [{"start": 125, "end": 129, "text": "[22]", "ref_id": "BIBREF21"}, {"start": 176, "end": 180, "text": "[21]", "ref_id": "BIBREF20"}, {"start": 625, "end": 629, "text": "[14]", "ref_id": "BIBREF13"}], "ref_spans": [], "section": "D-Wave Computing Overview"}, {"text": "Elements with the same indexes (Q i,i ) are responsible for\"bias\", i.e. the initial value of the magnetic field applied to the qubit, and elements with unequal indexes are responsible for the links between qubits (couplers). Minimizing such function is an NP-hard problem which makes it well suited for solving with help from the D-Wave 2000Q quantum computer.", "cite_spans": [], "ref_spans": [], "section": "D-Wave Computing Overview"}, {"text": "The problem description does not limit the number of connections between qubits. However, the actual hardware is, in fact, a chimera graph (16 \u00d7 16 board of K(4, 4) graphs, degree 6); thus, the problem graph must be mapped onto that architecture, which is achieved by minor-embedding. It is a process of mapping each logical binary variable present in a problem description to a group (called a chain) of physical qubits on the actual machine so all required connections are realized. For dense matrices there is probably no better method than minorembedding based on complete graph embedding described in [11] . For sparse matrices it is reasonable to attempt heuristics to lower the qubit chain length (e.g. as described in [6] ).", "cite_spans": [{"start": 606, "end": 610, "text": "[11]", "ref_id": "BIBREF10"}, {"start": 726, "end": 729, "text": "[6]", "ref_id": "BIBREF5"}], "ref_spans": [], "section": "D-Wave Computing Overview"}, {"text": "In its general form, the workflow application can be represented as a Directed Acyclic Graph, where each task is represented by a vertex. An example graph is depicted in Fig. 1 . We assume that the serverless infrastructure consists of a finite number of machine types, albeit with an infinite number of instances for each type. Each machine type has an associated cost. Each task has an associated running time for each machine type. Our model can be applied to any DAG.", "cite_spans": [], "ref_spans": [{"start": 170, "end": 176, "text": "Fig. 1", "ref_id": "FIGREF1"}], "section": "Workflow Problem Formulation"}, {"text": "The goal is to assign a machine type to each task with minimal total cost, while respecting the deadline. For simplicity, we will use the term machine instead of machine type from now on. For the purpose of describing results, we apply the following terminology: a correct result meets all the constraints, the (global) optimum is a correct result which has the lowest cost possible for the problem instance, while a wrong result fails to meet at least one constraint.", "cite_spans": [], "ref_spans": [], "section": "Workflow Problem Formulation"}, {"text": "The problem addressed in this paper is NP-hard [9] . We provide its translation to a QUBO problem which consists of two steps. First, we propose a transformation of the problem to BILP, which is described in this section. The second step shows how to translate BILP to a QUBO problem using [14] .", "cite_spans": [{"start": 47, "end": 50, "text": "[9]", "ref_id": "BIBREF8"}, {"start": 290, "end": 294, "text": "[14]", "ref_id": "BIBREF13"}], "ref_spans": [], "section": "Transformation to QUBO Problem"}, {"text": "The general goal of solving a BILP problem (also called \"0-1 Integer Programming\" [19] ) is to find, for a given vector C = [c i ] n , n binary numbers X = [x 1 , ..., x n ], for which the function", "cite_spans": [{"start": 82, "end": 86, "text": "[19]", "ref_id": "BIBREF18"}], "ref_spans": [], "section": "Transformation to QUBO Problem"}, {"text": "is minimal, subject to constraints indicated by the following linear equation:", "cite_spans": [], "ref_spans": [], "section": "Transformation to QUBO Problem"}, {"text": "where A = [a i,j ] n\u00d7w stores w constraints for n binary numbers.", "cite_spans": [], "ref_spans": [], "section": "Transformation to QUBO Problem"}, {"text": "In our problem, the BILP binary variables are defined as x = [x i ] n where n = t\u00b7m (see Sect. 4) . Variable x i is set to 1 if the task with number (i mod t) runs on a machine with number (i div t) where div is an integer division. Table 1 contains an example mapping of x i parameters to task and machine combinations. The BILP minimization function can subsequently be defined as the total cost of running tasks on selected machines", "cite_spans": [{"start": 89, "end": 97, "text": "Sect. 4)", "ref_id": null}], "ref_spans": [{"start": 233, "end": 240, "text": "Table 1", "ref_id": "TABREF0"}], "section": "Translation from Initial Formulation to BILP"}, {"text": "where C = [c i ] n is the cost vector and c i indicates the cost of running task with number (i mod t) on the machine with number (i div t).", "cite_spans": [], "ref_spans": [], "section": "Translation from Initial Formulation to BILP"}, {"text": "The cost vector needed for BILP formulation of the problem is obtained from the problem definition (Sect. 4) as follows: first, the cost matrix [\u03b3 i,j ] t\u00d7m is created by multiplying \u03b3 i,j = \u03c4 i,j \u00b7 k j . Next, the cost vector C is obtained by row-by-row vectorization [\u03c4 i,j ] using c i+t\u00b7j = \u03c4 i,j . Finally, the time vector T = [t i ] n is obtained in an analogous manner by calculating t i+t\u00b7j = \u03b3 i,j .", "cite_spans": [], "ref_spans": [], "section": "Translation from Initial Formulation to BILP"}, {"text": "In addition to the minimization function, there are also two types of constraints, the deadline and machine usage, where it is necessary to ensure that only a single machine will be selected for a given task.", "cite_spans": [], "ref_spans": [], "section": "Translation from Initial Formulation to BILP"}, {"text": "We define a matrix R = [r i,j ] n\u00d7r , where r is the number of all possible paths in the workflow DAG. R stores the time for each machinebased task assignment i \u2208 [0..n \u2212 1], but only if the task belongs to the path \u03b8 \u2208 [0, r \u2212 1] as follows:", "cite_spans": [], "ref_spans": [], "section": "Deadline Constraints."}, {"text": "Next, we formulate a set of constraints corresponding to each path \u03b8", "cite_spans": [], "ref_spans": [], "section": "Deadline Constraints."}, {"text": "which we can rewrite as (for", "cite_spans": [], "ref_spans": [], "section": "Deadline Constraints."}, {"text": "To describe constraints as part of BILP according to (3) we need to transform an inequality (7) into an equality. To achieve this, we rely on the fact that there always exists a slack variable s such that for natural numbers", "cite_spans": [], "ref_spans": [], "section": "Deadline Constraints."}, {"text": "Therefore it is necessary to extend R with additional columns that represent all necessary slack variables [14] . Generally a slack value s is a natural number, so we represent it using standard binary expansion. If we indicate", "cite_spans": [{"start": 107, "end": 111, "text": "[14]", "ref_id": "BIBREF13"}], "ref_spans": [], "section": "Deadline Constraints."}, {"text": "as the minimum time of running tasks in path \u03b8, then the number of binary variables b for storing slack variables for each path \u03b8 equals:", "cite_spans": [], "ref_spans": [], "section": "Deadline Constraints."}, {"text": "Machine Usage Constraints. The next category of constraints comprises \"one machine per task only\" constraints. We define U = [u i,j ] n\u00d7t such that for each task s \u2208 [0, t \u2212 1] and its machine-based position i \u2208 [0, n \u2212 1]", "cite_spans": [], "ref_spans": [], "section": "Deadline Constraints."}, {"text": "Therefore, each row of U indicates all machine-based positions of a task corresponding to that row. Then, to assure that only one machine is assigned to each task, the following constraint must be fulfilled:", "cite_spans": [], "ref_spans": [], "section": "Deadline Constraints."}, {"text": "If we indicate s as the total number of slack variables, the final BILP constraints matrix (3) is defined as A = [a i,j ] (n+s)\u00d7(r+t) and combines all constraints together as follows:", "cite_spans": [], "ref_spans": [], "section": "Deadline Constraints."}, {"text": "To perform this operation, we need matrices of compatible sizes. Therefore, the matrix U must also be extended with slack variables, which are set to 0. Vector b from (3) is defined in a similar manner:", "cite_spans": [], "ref_spans": [], "section": "Deadline Constraints."}, {"text": "Translation from BILP to QUBO Problem Given matrices A, C and vector b a QUBO matrix can be calculated using the following formula (from [14] ):", "cite_spans": [{"start": 137, "end": 141, "text": "[14]", "ref_id": "BIBREF13"}], "ref_spans": [], "section": "Deadline Constraints."}, {"text": "By dropping the additive constant c, the exact QUBO problem form, which is minimizing x T Qx, can be formulated. However it is necessary to introduce two additional scalar parameters:", "cite_spans": [], "ref_spans": [], "section": "Deadline Constraints."}, {"text": "\u2022 P -relative strength of all constraints in relation to the objective function, see (14) \u2022 S -weight required for balancing R and U values so that the constraints they represent are efficiently included in the QUBO problem. Namely, it replaces constraints defined by (11) with", "cite_spans": [], "ref_spans": [], "section": "Deadline Constraints."}, {"text": "Both mentioned parameters, along with the minor embedding chain strength, need to be balanced, to make sure that (1) the solution meets constraints and (2) the objective function is minimized. Finding proper values for these parameters is not a trivial task. It is important to mention that the resulting QUBO problem might have high resolution, which can result in errors due to the limited resolution of the annealer's Digital to Analog Converter (DAC), so the hardware conversion from QUBO to analog values may not be accurate enough.", "cite_spans": [], "ref_spans": [], "section": "Deadline Constraints."}, {"text": "In this section we describe the experimental results obtained using D-Wave 2000Q, compared with selected classical reference methods. In order to match the limitations of the existing quantum annealer, we considered four sample instances of the problem. Their DAG representation is shown in Fig. 2 and parameters in Table 2 . Finding Parameters: P , S and Chain Strength. Parameters needed for QUBO problem formulation are dependent on the specific problem instance. For the purpose of this research, parameters were obtained using a metaheuristic. First, (1), we find an initial value of P basing on [14] . The potential initial value of parameter S should be similar to values in vector T in order to achieve proper balance between constraints. Then, (2), we search the discrete space of possible pairs (P, S) for values relatively close to the initial values, using a classical solver -Gurobi 4 . Next, (3), we set the chain strength between physical qubits for the minor-embedded problem basing on the D-Wave guidebook's [11] suggestion that it should be large enough to keep chains and small enough not to cover the actual problem. We have found that it should approximate the largest values of the Q matrix. Finally, (4), the selected chain strength is used as an input for the dwave.embedding library, which performs actual minor embedding. The final parameter values are presented in Table 3 . Deadline values for all four problems were selected in such a way that they yield similar percentages of correct solutions. Table 3 . Values of parameters P , S and chain strength found for each size of the workflow problem for the given deadline (which is predefined, but has an impact on the parameters' values). The rightmost column represents the percentage of correct solutions in relation to all possible solutions. Reference Methods. The problems discussed in this paper are small enough to be solved using classical methods. The following four classical methods have been used to verify D-Wave machine results:", "cite_spans": [{"start": 601, "end": 605, "text": "[14]", "ref_id": "BIBREF13"}, {"start": 1025, "end": 1029, "text": "[11]", "ref_id": "BIBREF10"}], "ref_spans": [{"start": 291, "end": 297, "text": "Fig. 2", "ref_id": "FIGREF2"}, {"start": 316, "end": 323, "text": "Table 2", "ref_id": "TABREF1"}, {"start": 1392, "end": 1399, "text": "Table 3", "ref_id": null}, {"start": 1526, "end": 1533, "text": "Table 3", "ref_id": null}], "section": "Results"}, {"text": "\u2022 A brute-force method using initial problem formulation. It was used to calculate exact results, along with minimal energy, through direct use of the objective function (1). \u2022 GNU Linear Programming Kit 5 library for solving BILP problem prior to its translation to QUBO. This method always finds the global optima. \u2022 Gurobi sampler for the QUBO problem without minor-embedding. This method always finds the global optima, provided that parameters P and S are set up properly. \u2022 Gurobi sampler for QUBO problem with minor-embedding, requiring three parameters (P , S, chain strength). The summary of the results is presented in Table 4 .", "cite_spans": [], "ref_spans": [{"start": 629, "end": 636, "text": "Table 4", "ref_id": "TABREF3"}], "section": "Results"}, {"text": "We perform experiments using the D-Wave 2000Q 5.0 machine sampled 2000 times with annealing time set to 8 \u00b5s. Figure 3 shows the energy distribution of the actual results. For Problem 1 and Problem 2, the minimal energy corresponds to the global optimum, while for Problem 3 it indicates a correct solution, but not the best possible one. All energies found for the most complex Problem 4 correspond to wrong solutions. It can be noticed that the count of wrong solutions grows along with the size of the solution space. In general, the obtained characteristics of energies remain similar to [17] . Details of the results are described in Table 5 , where the number of correct solutions found by D-Wave and their relation to the total number of correct solutions is presented. The results are compared to the global optima obtained by the brute force method. It can be noted that D-Wave results are comparable to Gurobi results. In the first two problems, workflow optimization was solved exactly and the global optimum was found. In problem 3, the Gurobi solution was still optimal, while the D-Wave solution was correct, but not the best (12% worse in terms of cost; 33th out of 132 correct solutions). For problem 4 neither sampler found the global optimum. ", "cite_spans": [{"start": 592, "end": 596, "text": "[17]", "ref_id": "BIBREF16"}], "ref_spans": [{"start": 110, "end": 118, "text": "Figure 3", "ref_id": "FIGREF4"}, {"start": 639, "end": 646, "text": "Table 5", "ref_id": null}], "section": "Experiments with D-Wave."}, {"text": "In this paper we showed that it is possible to translate the workflow scheduling problem into a QUBO problem, execute it on a quantum annealer and achieve not only correct, but also globally optimal results for some of the analyzed problem instances. However, the presented method of adapting the scheduling challenge for D-Wave significantly increases the size of the problem. For example, the 18-binary variable problem required each of 39 QUBO problem variables to be represented by 11 physical qubits; thus the initial problem with a solution space size of = 3 6 = 729 (m t , m = 3, t = 6, see Sect. 4) was converted into a problem with size 2 429 -10 143 (QUBO problem with 39 variables, 11 qubits each, 39 \u00b7 11 = 429). For such a large QUBO it is difficult for the quantum annealer to find the lowest energy solution. Therefore, in the future we will focus on solutions such as domain wall encoding [7] to reduce the number of binary variables. However, it is worth noting that for larger problems the brute force method would no longer be usable because of its exponential complexity. This leaves a space for experimenting with a quantum annealer for larger instances, as the annealing process is very fast.", "cite_spans": [{"start": 905, "end": 908, "text": "[7]", "ref_id": "BIBREF6"}], "ref_spans": [], "section": "Conclusions and Future Work"}, {"text": "To sum up, this work proved that it is possible to solve workflow scheduling problems with the use of currently existing quantum annealers. Future work might involve finding a better translation of the problem to a QUBO problem, making the Q matrix more sparse and using minor-embedding heuristics. Additionally, the problem solution could be tested on the Pegasus machine [12] upon its release. It may also be possible to divide the problem into smaller piecesthis means dividing the original problem or dividing the QUBO problem (or even using both methods in parallel) with tools such as D-Wave QBSolv [10] . Another interesting direction of research would be to compare the performance of the presented problem on the D-Wave 2000Q machine with a non-quantum Fujitsu digital annealer [28] as both machines are designed to solve problems with a similar approach but different hardware.", "cite_spans": [{"start": 373, "end": 377, "text": "[12]", "ref_id": "BIBREF11"}, {"start": 605, "end": 609, "text": "[10]", "ref_id": "BIBREF9"}, {"start": 787, "end": 791, "text": "[28]", "ref_id": "BIBREF27"}], "ref_spans": [], "section": "Conclusions and Future Work"}], "bib_entries": {"BIBREF0": {"ref_id": "b0", "title": "Observation of gravitational waves from a binary black hole merger", "authors": [{"first": "B", "middle": ["P"], "last": "Abbott", "suffix": ""}, {"first": "R", "middle": [], "last": "Abbott", "suffix": ""}, {"first": "T", "middle": [], "last": "Abbott", "suffix": ""}], "year": 2016, "venue": "Phys. Rev. Lett", "volume": "116", "issn": "6", "pages": "", "other_ids": {}}, "BIBREF1": {"ref_id": "b1", "title": "Low-time complexity budget-deadline constrained workflow scheduling on heterogeneous resources", "authors": [{"first": "H", "middle": [], "last": "Arabnejad", "suffix": ""}, {"first": "J", "middle": ["G"], "last": "Barbosa", "suffix": ""}, {"first": "R", "middle": [], "last": "Prodan", "suffix": ""}], "year": 2016, "venue": "Future Gener. Comput. Syst", "volume": "55", "issn": "", "pages": "29--40", "other_ids": {}}, "BIBREF2": {"ref_id": "b2", "title": "Serverless computing: current trends and open problems", "authors": [{"first": "I", "middle": [], "last": "Baldini", "suffix": ""}], "year": 2017, "venue": "Research Advances in Cloud Computing", "volume": "", "issn": "", "pages": "1--20", "other_ids": {"DOI": ["10.1007/978-981-10-5026-8_1"]}}, "BIBREF3": {"ref_id": "b3", "title": "Montage: a grid enabled image mosaic service for the national virtual observatory", "authors": [{"first": "G", "middle": [], "last": "Berriman", "suffix": ""}, {"first": "J", "middle": [], "last": "Good", "suffix": ""}, {"first": "A", "middle": [], "last": "Laity", "suffix": ""}], "year": 2004, "venue": "Astronomical Data Analysis Software and Systems (ADASS) XIII", "volume": "314", "issn": "", "pages": "", "other_ids": {}}, "BIBREF4": {"ref_id": "b4", "title": "The Ising model: teaching an old problem new tricks", "authors": [{"first": "Z", "middle": [], "last": "Bian", "suffix": ""}, {"first": "F", "middle": [], "last": "Chudak", "suffix": ""}, {"first": "W", "middle": ["G"], "last": "Macready", "suffix": ""}, {"first": "G", "middle": [], "last": "Rose", "suffix": ""}], "year": 2010, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF5": {"ref_id": "b5", "title": "A practical heuristic for finding graph minors", "authors": [{"first": "J", "middle": [], "last": "Cai", "suffix": ""}, {"first": "W", "middle": ["G"], "last": "Macready", "suffix": ""}, {"first": "A", "middle": [], "last": "Roy", "suffix": ""}], "year": 2014, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {"arXiv": ["arXiv:1406.2741"]}}, "BIBREF6": {"ref_id": "b6", "title": "Domain wall encoding of discrete variables for quantum annealing and QAOA", "authors": [{"first": "N", "middle": [], "last": "Chancellor", "suffix": ""}], "year": 2019, "venue": "Quantum Sci. Technol", "volume": "4", "issn": "4", "pages": "", "other_ids": {"DOI": ["https:/iopscience.iop.org/article/10.1088/2058-9565/ab33c2"]}}, "BIBREF7": {"ref_id": "b7", "title": "Finding maximum cliques on the D-Wave quantum annealer", "authors": [{"first": "G", "middle": [], "last": "Chapuis", "suffix": ""}, {"first": "H", "middle": [], "last": "Djidjev", "suffix": ""}, {"first": "G", "middle": [], "last": "Hahn", "suffix": ""}, {"first": "G", "middle": [], "last": "Rizk", "suffix": ""}], "year": 2019, "venue": "J. Signal Process. Syst", "volume": "91", "issn": "3", "pages": "363--377", "other_ids": {}}, "BIBREF8": {"ref_id": "b8", "title": "Computer and Job-Shop Scheduling Theory", "authors": [{"first": "E", "middle": ["G"], "last": "Coffman", "suffix": ""}, {"first": "J", "middle": ["L"], "last": "Bruno", "suffix": ""}], "year": 1976, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF9": {"ref_id": "b9", "title": "D-Wave Initiates Open Quantum Software Environment", "authors": [{"first": "D-Wave", "middle": [], "last": "Systems", "suffix": ""}], "year": 2017, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF10": {"ref_id": "b10", "title": "D'wave problem solving handbook", "authors": [{"first": "D-Wave Systems", "middle": [], "last": "Inc", "suffix": ""}], "year": null, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF11": {"ref_id": "b11", "title": "Pegasus: the second connectivity graph for large-scale quantum annealing hardware", "authors": [{"first": "N", "middle": [], "last": "Dattani", "suffix": ""}, {"first": "S", "middle": [], "last": "Szalay", "suffix": ""}, {"first": "N", "middle": [], "last": "Chancellor", "suffix": ""}], "year": 2019, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {"arXiv": ["arXiv:1901.07636"]}}, "BIBREF12": {"ref_id": "b12", "title": "Workflows and e-science: an overview of workflow system features and capabilities", "authors": [{"first": "E", "middle": [], "last": "Deelman", "suffix": ""}, {"first": "D", "middle": [], "last": "Gannon", "suffix": ""}, {"first": "M", "middle": [], "last": "Shields", "suffix": ""}, {"first": "I", "middle": [], "last": "Taylor", "suffix": ""}], "year": 2009, "venue": "Future Gener. Comput. Syst", "volume": "25", "issn": "5", "pages": "528--540", "other_ids": {}}, "BIBREF13": {"ref_id": "b13", "title": "A Tutorial on Formulating and Using QUBO Models", "authors": [{"first": "F", "middle": [], "last": "Glover", "suffix": ""}, {"first": "G", "middle": [], "last": "Kochenberger", "suffix": ""}, {"first": "Y", "middle": [], "last": "Du", "suffix": ""}], "year": 2018, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {"arXiv": ["arXiv:1811.11538"]}}, "BIBREF14": {"ref_id": "b14", "title": "Bounds for certain multiprocessing anomalies. ell Syst", "authors": [{"first": "R", "middle": ["L"], "last": "Graham", "suffix": ""}], "year": 1966, "venue": "Tech. J", "volume": "45", "issn": "9", "pages": "1563--1581", "other_ids": {"DOI": ["10.1002/j.1538-7305.1966.tb01709.x"]}}, "BIBREF15": {"ref_id": "b15", "title": "A fast quantum mechanical algorithm for database search", "authors": [{"first": "L", "middle": ["K"], "last": "Grover", "suffix": ""}], "year": 1996, "venue": "Proceedings of the Twenty-Eighth Annual ACM Symposium on Theory of Computing, STOC", "volume": "", "issn": "", "pages": "212--219", "other_ids": {}}, "BIBREF16": {"ref_id": "b16", "title": "Parallel in time dynamics with quantum annealers", "authors": [{"first": "K", "middle": [], "last": "Ja Lowiecki", "suffix": ""}, {"first": "A", "middle": [], "last": "Wi Eckowski", "suffix": ""}, {"first": "P", "middle": [], "last": "Gawron", "suffix": ""}, {"first": "B", "middle": [], "last": "Gardas", "suffix": ""}], "year": null, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {"arXiv": ["arXiv:1909.0429"]}}, "BIBREF17": {"ref_id": "b17", "title": "Quantum algorithms zoo web page", "authors": [{"first": "S", "middle": [], "last": "Jordan", "suffix": ""}], "year": null, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF18": {"ref_id": "b18", "title": "Reducibility Among Combinatorial Problems", "authors": [{"first": "R", "middle": ["M"], "last": "Karp", "suffix": ""}], "year": 1972, "venue": "", "volume": "", "issn": "", "pages": "85--103", "other_ids": {"DOI": ["10.1007/978-1-4684-2001-2_9"]}}, "BIBREF19": {"ref_id": "b19", "title": "Challenges for scheduling scientific workflows on cloud functions", "authors": [{"first": "J", "middle": [], "last": "Kijak", "suffix": ""}, {"first": "P", "middle": [], "last": "Martyna", "suffix": ""}, {"first": "M", "middle": [], "last": "Pawlik", "suffix": ""}, {"first": "B", "middle": [], "last": "Balis", "suffix": ""}, {"first": "M", "middle": [], "last": "Malawski", "suffix": ""}], "year": 2018, "venue": "11th IEEE International Conference on Cloud Computing", "volume": "", "issn": "", "pages": "460--467", "other_ids": {"DOI": ["10.1109/CLOUD.2018.00065"]}}, "BIBREF20": {"ref_id": "b20", "title": "Quadratic unconstrained binary optimization problem preprocessing: theory and empirical analysis", "authors": [{"first": "M", "middle": [], "last": "Lewis", "suffix": ""}, {"first": "F", "middle": [], "last": "Glover", "suffix": ""}], "year": 2017, "venue": "Networks", "volume": "70", "issn": "2", "pages": "79--97", "other_ids": {}}, "BIBREF21": {"ref_id": "b21", "title": "Ising formulations of many NP problems", "authors": [{"first": "A", "middle": [], "last": "Lucas", "suffix": ""}], "year": 2014, "venue": "Front. Phys", "volume": "2", "issn": "", "pages": "", "other_ids": {"DOI": ["https:/www.frontiersin.org/article/10.3389/fphy.2014.00005"]}}, "BIBREF22": {"ref_id": "b22", "title": "Simplifying construction of complex workflows for non-expert users of the southern california earthquake center community modeling environment", "authors": [{"first": "P", "middle": [], "last": "Maechling", "suffix": ""}, {"first": "H", "middle": [], "last": "Chalupsky", "suffix": ""}, {"first": "M", "middle": [], "last": "Dougherty", "suffix": ""}], "year": 2005, "venue": "ACM SIGMOD Rec", "volume": "34", "issn": "3", "pages": "24--30", "other_ids": {}}, "BIBREF23": {"ref_id": "b23", "title": "Performance considerations on execution of large scale workflow applications on cloud functions", "authors": [{"first": "M", "middle": [], "last": "Pawlik", "suffix": ""}, {"first": "K", "middle": [], "last": "Figiela", "suffix": ""}, {"first": "M", "middle": [], "last": "Malawski", "suffix": ""}], "year": 2019, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {"arXiv": ["arXiv:1909.03555"]}}, "BIBREF24": {"ref_id": "b24", "title": "Solving large maximum clique problems on a quantum annealer", "authors": [{"first": "E", "middle": [], "last": "Pelofske", "suffix": ""}, {"first": "G", "middle": [], "last": "Hahn", "suffix": ""}, {"first": "H", "middle": [], "last": "Djidjev", "suffix": ""}], "year": 2019, "venue": "QTOP 2019", "volume": "11413", "issn": "", "pages": "123--135", "other_ids": {"DOI": ["10.1007/978-3-030-14082-3_11"]}}, "BIBREF25": {"ref_id": "b25", "title": "Algorithms for quantum computation: discrete logarithms and factoring", "authors": [{"first": "P", "middle": ["W"], "last": "Shor", "suffix": ""}], "year": 1994, "venue": "Proceedings 35th Annual Symposium on Foundations of Computer Science", "volume": "", "issn": "", "pages": "124--134", "other_ids": {}}, "BIBREF26": {"ref_id": "b26", "title": "FaaSter, better, cheaper: the prospect of serverless scientific computing and HPC", "authors": [{"first": "J", "middle": [], "last": "Spillner", "suffix": ""}, {"first": "C", "middle": [], "last": "Mateos", "suffix": ""}, {"first": "D", "middle": ["A"], "last": "Monge", "suffix": ""}], "year": 2017, "venue": "CCIS", "volume": "796", "issn": "", "pages": "154--168", "other_ids": {"DOI": ["10.1007/978-3-319-73353-1_11"]}}, "BIBREF27": {"ref_id": "b27", "title": "An accelerator architecture for combinatorial optimization problems", "authors": [{"first": "S", "middle": [], "last": "Tsukamoto", "suffix": ""}, {"first": "M", "middle": [], "last": "Takatsu", "suffix": ""}, {"first": "S", "middle": [], "last": "Matsubara", "suffix": ""}, {"first": "H", "middle": [], "last": "Tamura", "suffix": ""}], "year": 2017, "venue": "Fujitsu Sci. Tech. J", "volume": "53", "issn": "5", "pages": "8--13", "other_ids": {}}, "BIBREF28": {"ref_id": "b28", "title": "Quantum annealing implementation of job-shop scheduling", "authors": [{"first": "D", "middle": [], "last": "Venturelli", "suffix": ""}, {"first": "D", "middle": ["J J"], "last": "Marchand", "suffix": ""}, {"first": "G", "middle": [], "last": "Rojo", "suffix": ""}], "year": 2015, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {"arXiv": ["arXiv:1506.08479"]}}, "BIBREF29": {"ref_id": "b29", "title": "Monetary cost optimizations for hosting workflow-asa-service in IaaS clouds", "authors": [{"first": "A", "middle": ["C"], "last": "Zhou", "suffix": ""}, {"first": "B", "middle": [], "last": "He", "suffix": ""}, {"first": "C", "middle": [], "last": "Liu", "suffix": ""}], "year": 2015, "venue": "IEEE Trans. Cloud Comput", "volume": "4", "issn": "1", "pages": "34--48", "other_ids": {}}}, "ref_entries": {"FIGREF0": {"text": "Springer Nature Switzerland AG 2020 V. V. Krzhizhanovskaya et al. (Eds.): ICCS 2020, LNCS 12142, pp. 516-530, 2020. https://doi.org/10.1007/978-3-030-50433-5_40", "latex": null, "type": "figure"}, "FIGREF1": {"text": "Example workflow problem as a graph with task count t = 8. We search for an assignment of each task to one of the machine types. For example, with machine count m = 3 vector K = [k0, k1, k2] describes the cost of time unit execution on each machine while matrix T = [\u03c4i,j]8\u00d73 describes the execution time of task i running on machine jThe formal definition of the problem addressed in this paper consists of:\u2022 a time matrix T = [\u03c4 i,j ] t\u00d7m where t is the number of tasks, m is the number of machines and \u03c4 i,j expresses the execution time of task with number i on the machine with number j; \u2022 a machine cost per time unit vector K = [k i ] m measured in currency units per time unit. This matrix can be used to calculate the cost of running the workflow; \u2022 a deadline d (an integer, limiting this value is crucial for the size of the resulting QUBO problem); \u2022 a list \u0398 of paths from the vertex representing the first task to the vertex representing the final task (both inclusive) in a DAG representing the problem.", "latex": null, "type": "figure"}, "FIGREF2": {"text": "Graph representations of the tested workflow problems.", "latex": null, "type": "figure"}, "FIGREF3": {"text": "Summary of D-Wave 2000Q results. The fourth column presents the number of D-Wave unique correct solutions in relation to the total number of brute force correct solutions. The fifth column indicates whether the global optimum was found, listing the absolute energy error between the lowest D-Wave solution and the brute-force global optimum. The two rightmost columns refer to the execution time and cost of the lowest D-Wave solution respectively (min means global optimum cost).", "latex": null, "type": "figure"}, "FIGREF4": {"text": "Histograms of results for the four types of workflow problems tested. The x axis represent values of energies equal to the value of minimized objective function (1). The y axis represents the probability density. For Problems 1-3 the correct solutions found are shown on the left-hand side of the spectrum.", "latex": null, "type": "figure"}, "TABREF0": {"text": "The", "latex": null, "type": "table", "html": "<html><body><table><tr><td>\u00a0</td><td>\u00a0</td><td>Task\n</td><td>\u00a0</td><td>\u00a0</td><td>\u00a0</td><td>\u00a0</td><td>\u00a0</td><td>\u00a0</td></tr><tr><td>\u00a0</td><td>\u00a0</td><td>1 </td><td>2 </td><td>3 </td><td>4 </td><td>5 </td><td>6 </td><td>7 </td><td>8\n</td></tr><tr><td>Machine </td><td>0 </td><td>x0 </td><td>x1 </td><td>x2 </td><td>x3 </td><td>x4 </td><td>x5 </td><td>x6 </td><td>x7\n</td></tr><tr><td>1 </td><td>x8 </td><td>x9 </td><td>x10 </td><td>x11 </td><td>x12 </td><td>x13 </td><td>x14 </td><td>x15\n</td></tr><tr><td>\u00a0</td><td>2 </td><td>x16 </td><td>x17 </td><td>x18 </td><td>x19 </td><td>x20 </td><td>x21 </td><td>x22 </td><td>x23\n</td></tr><tr><td>\u00a0</td><td>3 </td><td>x24 </td><td>x25 </td><td>x26 </td><td>x27 </td><td>x28 </td><td>x29 </td><td>x30 </td><td>x31\n</td></tr></table></body></html>"}, "TABREF1": {"text": "The", "latex": null, "type": "table", "html": "<html><body><table><tr><td>\u00a0</td><td>\u00a0</td><td>Task\n</td><td>\u00a0</td><td>\u00a0</td><td>\u00a0</td><td>\u00a0</td><td>\u00a0</td><td>\u00a0</td></tr><tr><td>\u00a0</td><td>\u00a0</td><td>1 </td><td>2 </td><td>3 </td><td>4 </td><td>5 </td><td>6 </td><td>7 </td><td>8\n</td></tr><tr><td>Machine </td><td>0 </td><td>x0 </td><td>x1 </td><td>x2 </td><td>x3 </td><td>x4 </td><td>x5 </td><td>x6 </td><td>x7\n</td></tr><tr><td>1 </td><td>x8 </td><td>x9 </td><td>x10 </td><td>x11 </td><td>x12 </td><td>x13 </td><td>x14 </td><td>x15\n</td></tr><tr><td>\u00a0</td><td>2 </td><td>x16 </td><td>x17 </td><td>x18 </td><td>x19 </td><td>x20 </td><td>x21 </td><td>x22 </td><td>x23\n</td></tr><tr><td>\u00a0</td><td>3 </td><td>x24 </td><td>x25 </td><td>x26 </td><td>x27 </td><td>x28 </td><td>x29 </td><td>x30 </td><td>x31\n</td></tr></table></body></html>"}, "TABREF3": {"text": "Gurobi solutions table. The rightmost column shows whether the global optimum was found, with the absolute energy error between the lowest Gurobi solution and the brute force global optimum.No. Binary variables number Global optimum found", "latex": null, "type": "table"}}, "back_matter": [{"text": "Acknowledgements. The research presented in this paper has been partially supported by the National Science Centre, Poland, Grant no. 2016/21/B/ST6/01497. The authors also thank Piotr Gawron, Bart lomiej Gardas, Andy Mason and Piotr Nowakowski for helpful remarks.", "cite_spans": [], "ref_spans": [], "section": "acknowledgement"}]}